<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小二小二不停步</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-05T17:16:27.603Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小二小二不停步</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka消费者</title>
    <link href="http://example.com/2022/09/06/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://example.com/2022/09/06/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2022-09-05T17:13:17.000Z</published>
    <updated>2022-09-05T17:16:27.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>消费者<em><strong>负责订阅Kafka中的主题，并且从订阅的主题上拉取消息</strong></em>，与其他消息中间件不同的是，kafka的消费理念中有一层消费组的概念。<em><strong>每一个分区只能被同一个消费组中的一个消费者消费</strong></em></p><p>消费者和消费者组的模型可以让整体的消费能力具备横向伸缩性，可以改变消费者的个数而改变消费能力，过多或过少都不能改变能力。</p><p>消费组是一个<em><strong>逻辑上的概念</strong></em>，将里面的消费者归于一类，每个消费者只属于一个消费组（有固定名称），消费者在消费前需要指定所属组的名称；消费者是<em><strong>实际的应用实例</strong></em>，可以是一个线程或进程，同一个消费组内的消费者可部署在同一机器或不同机器</p><p>对于消息中间件一般由两种消息投递模式：</p><ul><li>点对点模式：基于队列，消息生产者发送消息到队列，消息消费者从队列中接收消息。</li><li>发布&#x2F;订阅模式：定义了如何向一个内容节点（主题）发布和订阅消息。主题相当于消息传递的中介。消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息，主题使得两者互相保持独立，不需要进行接触就可以保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li></ul><p>而Kafka同时支持以上两种消息投递模式：若所有消费者在同一个组，那么所有消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，就相当于点对点；若所有消费者在不同消费者，那么所有消息都会被广播给所有消费者，即每条消息都会被所有消费者处理，就相当于发布&#x2F;订阅模式的应用</p><p>正常的消费逻辑：订阅消费者客户端参数以及创建相应的消费者实例；订阅主题；拉取消息并消费；提交消费位移；关闭消费者实例</p><p>Kafka中的消费<em><strong>基于拉模式</strong></em>。消息的消费模式一般由两种模式：推模式（服务端主动将消息推送给消费者）和拉模式（消费者主动向服务端发起请求来拉取消息）。Kafka中的消息消费是一个不断轮询的过程，消费者就重复调用poll()方法，获取的就是所订阅的主题（分区）上的一组消息。</p><p>对于Kafka的分区，每条消息都有唯一的offset，消费偏移量，表示消息在分区中对应的位置。而消费者使用offset表示消费到分区中某个消息所在的位置，位移。在每次调用poll()方法，返回的是还没有被消费过的消息集，所以需要记录上一次消费时的消费位移，且该消费位移需要持久化保持（不能是保存在内存，不然重启后消费者就不知道位移了；若新的消费者加入，就会有均衡动作，对于同一分区，会可能在均衡后分配给新的消费者）</p><p><img src="/2022/09/06/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/next.png"></p><p>X就是某一次拉取操作中此分区消息的最大偏移量。所以当前消费者需要提交的消费位移就是X+1</p><p>消费者中也有控制消费速度的方法。pause()和resume()分别实现暂停某些分区在拉取操作时返回数据给客户端和恢复某些分区向客户端返回数据的操作</p><p>再均衡：分区的所属权从一个消费者转移到另一消费者的行为，它为消费者具备高可用性和伸缩性提供保障，我们能安全方便的删除或添加消费组内的消费者。但是在均衡发生时间内，消费组不可用；一个分区被重新分配给另一个消费者时，消费者当前状态也会丢失。</p><p>消费者拦截器<em><strong>主要在消费到消息或在提交消费位移时进行定制化的操作</strong></em></p><p>KafkaConsumer&#x3D;&#x3D;非线程安全&#x3D;&#x3D;。里有acquire()方法检测当前是否只有一个线程在操作，若有多个线程就抛异常，与锁不同，因为它不会造成阻塞等待，仅仅通过&#x3D;&#x3D;线程操作计算标记的方式来检测线程是否发生了并发操作&#x3D;&#x3D;。KafkaConsumer中的每个公用方法执行前都会调用该方法（除了wakeup()方法）。</p><p>KafkaConsumer的非线程安全不是意味着消费消息只能单线程方式执行。若生产者发送消息的速度比消费者的速度更快，就会有越来越多消息来不及消费而造成延迟。Kafka中消息由保留作用，有些消息可能在被消费前就被清理了，从而消息丢失。使用多线程消息消费可以提高整体消费能力。</p><p>多线程实现方式：</p><ul><li>线程封闭：即每个线程实例化一个KafkaConsumer对象，一个线程对应一个KafkaConsumer实例，消费线程。一个消费线程可以消费一个或多个分区中的消息，所有消费线程属于同一个消费组。该方法的并发度受限于分区的实际个数，消费线程更多，会有部分空闲</li><li>多个消费线程消费同一个分区，可提高消费能力，但位移提交和顺序控制的处理会很复杂，使用的极少。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;消费者&lt;em&gt;&lt;strong&gt;负责订阅Kafka中的主题，并且从订阅的主题上拉取消息&lt;/strong&gt;&lt;/em&gt;，与其他消息中间件不同的是，</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka生产者</title>
    <link href="http://example.com/2022/09/04/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <id>http://example.com/2022/09/04/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/</id>
    <published>2022-09-03T16:15:57.000Z</published>
    <updated>2022-09-03T16:21:39.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><p>消息生产者，把消息投递到Kafka中</p><p>当创建真正的生产者实例前需要配置相应的参数。比如连接的Kafka集群地址。</p><p>&#x3D;&#x3D;producer线程安全&#x3D;&#x3D;，可以在多个线程中共享单个producer实例，也可以将实例进行池化来供其他线程调用</p><p>发送消息的三种模式：发后即忘（发送消息不管是否到达，在某些时候会造成消息丢失，性能最高可靠性最差）、同步、异步。</p><p>两种异常：可重试异常和不可重试的异常</p><p>生产者需要用序列化器把对象转成字节数组才能通过网络发给Kafka。相对的，消费者需要反序列化器把字节数组转换成相应的对象。两者需要一一对应。</p><p>消息通过send方法发往broker的过程，可能要拦截器（非必须）、序列化器（必须）、分区器的系列作用之后才能发往broker。若没有指定partition字段，就需要依赖分区器，根据key计算partition的值。</p><p>生产者拦截器：在消息发送前做一些准备工作，比如按某个规则过滤消息等等。producer在序列化和计算分区之前调用拦截器的onsend()方法对消息进行定制化操作</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>生产者客户端整体架构</p><p><img src="/2022/09/04/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/liucheng.png"></p><p>整个生产者客户端由两个线程协调运行（主线程和sender线程）。发送线程负责从RecordAccumulator中获取消息并将其发送到Kafka中。</p><p><em><strong>RecordAccumulator主要是用来缓存消息，让sender线程可以批量发送，以减少网络传输的资源消耗以提升性能</strong></em>。（默认32MB）。若生产者发送消息的速度超过发送到服务器的速度，生产者空间就会不足，此时的send()方法会被阻塞或抛异常。内部为每个分区都维护一个双端队列（producerBatch，一个消息批次）；消息在网络上是以字节的形式传输，发送前要创建一块内存区域来保存对应的消息，内部还有一个BufferPool，以实现ByteBuffer的复用，实现缓存高效利用。</p><p>主线程发送的消息会追加到RecordAccumulator的某个双端队列中，sender读取消息时从队列的头部读取消息，从缓存中获取消息，会改变原本的保存形式&lt;Node,List<ProducerBatch>&gt;，node就是Kafka集群中的broker节点。对于网络连接，生产者客户端是与具体的broker节点建立连接和发送消息，而不关心消息属于哪个分区；而producer的应用逻辑而言，只关注向哪个分区中发送哪些消息。</ProducerBatch></p><p>&lt;Node,List<ProducerBatch>&gt;还会封装成&lt;Node,Request&gt;，就可以将request请求发往各个node。Request是Kafka的各种协议请求。</ProducerBatch></p><p>请求从sender发往Kafka之前还会保存在InFlightRequests中。InFlightRequests中对象形式是Map&lt;NodeId,Deque<Request>&gt;就是<em><strong>缓存了已经发出去但没有收到响应的请求</strong></em>（NodeId是节点的id编号，String类型）；还提供了管理类的方法，可通过参数限制每个连接最多缓存的请求数</Request></p><h2 id="元数据更新"><a href="#元数据更新" class="headerlink" title="元数据更新"></a>元数据更新</h2><p>InFlightRequests可以获得leastLoadedNode，即所有Node节点中负载最小的（比如上图的node2）。选择该节点可以让它尽快发出，避免因网络阻塞等异常而影响整体的进度。</p><p>producer需要将消息追加到指定主题的某个分区所对应的leader副本之前，要知道主题的分区数量，再计算出目标分区，之后producer需要leader副本所在broker节点的地址、端口等信息才能建立连接，最终才能发送到Kafka。该过程中所需要的信息都是元数据信息。</p><p>元数据指Kafka集群的元数据，记录了集群中有哪些主题，主题有哪些分区，每个分区的leader副本、follow副本分配在哪个节点上，哪些副本在AR、ISR等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。元数据的更新操作是在客户端内部进行，对客户端的外部使用者不可见。需要更新时，先选leastLoadedNode，再向该Node发送请求获取具体的元数据信息（sender线程发起），请求同样会存入InFightRequests。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生产者&quot;&gt;&lt;a href=&quot;#生产者&quot; class=&quot;headerlink&quot; title=&quot;生产者&quot;&gt;&lt;/a&gt;生产者&lt;/h1&gt;&lt;p&gt;消息生产者，把消息投递到Kafka中&lt;/p&gt;
&lt;p&gt;当创建真正的生产者实例前需要配置相应的参数。比如连接的Kafka集群地址。&lt;/p</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>as-if-serial和happens-before</title>
    <link href="http://example.com/2022/08/31/as-if-serial%E5%92%8Chappens-before/"/>
    <id>http://example.com/2022/08/31/as-if-serial%E5%92%8Chappens-before/</id>
    <published>2022-08-31T15:48:18.000Z</published>
    <updated>2022-08-31T15:52:04.646Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道为了提高并行度，优化程序性能，编译器和处理器会对代码进行指令重排序。但为了不改变程序的执行结果，尽可能地提高程序执行的并行度，我们需要了解as-if-serial规则和happens-before规则。</p><h3 id="as-if-serial规则"><a href="#as-if-serial规则" class="headerlink" title="as-if-serial规则"></a>as-if-serial规则</h3><p>as-if-serial语义的意思指：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</strong> 编译器、runtime和处理器都必须遵守as-if-serial语义。<br>为了遵守as-if-serial语义，<strong>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</strong> 但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYint a=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c=a+b;</span><br></pre></td></tr></table></figure><p>a和c之间存在数据依赖关系，同时b和c之间也存在数据依赖关系。因此在最终执行的指令序列中，c不能被重排序到A和B的前面（c排到a和b的前面，程序的结果将会被改变）。但a和b之间没有数据依赖关系，编译器和处理器可以重排序a和b之间的执行顺序。</p><h3 id="happens-before（先行发生）规则"><a href="#happens-before（先行发生）规则" class="headerlink" title="happens-before（先行发生）规则"></a>happens-before（先行发生）规则</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：</p><ol><li><strong>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong></li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。<strong>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM允许这种重排序。</strong></li></ol><h4 id="八大规则"><a href="#八大规则" class="headerlink" title="八大规则"></a>八大规则</h4><table><thead><tr><th>规则</th><th>解释</th></tr></thead><tbody><tr><td>程序次序规则</td><td>在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td>管程锁定规则</td><td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td>volatile 变量规则</td><td>volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td>线程启动规则</td><td>Thread 对象的 start() 方法先行发生于此线程的每一个动作</td></tr><tr><td>线程终止规则</td><td>线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td></tr><tr><td>线程中断规则</td><td>对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生 (通过 Thread.interrupted() 方法检测)</td></tr><tr><td>对象终结规则</td><td>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td>传递性</td><td>如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="as-if-serial规则和happens-before规则的区别"><a href="#as-if-serial规则和happens-before规则的区别" class="headerlink" title="as-if-serial规则和happens-before规则的区别"></a>as-if-serial规则和happens-before规则的区别</h3><ol><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证<strong>正确同步的多线程</strong>程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻觉：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻觉：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道为了提高并行度，优化程序性能，编译器和处理器会对代码进行指令重排序。但为了不改变程序的执行结果，尽可能地提高程序执行的并行度，我们需要了解as-if-serial规则和happens-before规则。&lt;/p&gt;
&lt;h3 id=&quot;as-if-serial规则&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Eureka部分源码</title>
    <link href="http://example.com/2022/08/27/Eureka%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2022/08/27/Eureka%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/</id>
    <published>2022-08-27T13:35:29.000Z</published>
    <updated>2022-08-27T13:42:55.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>底层通过Jersey框架在AWS背景下实现，用过滤器做服务的拦截。核心就是把<em><strong>过滤器注册进Tomcat</strong></em></p><p>多个模块都会向eureka发送服务注册的请求（会有注册信息），eureka底层会有一个注册表，当各个模块间进行通信的时候会定期拉取注册表的信息。模块要向另一个模块通信的时候会看是否有注册信息，有就通过信息得到对应的地址，就可以访问。</p><p>会维护心跳连接&#x2F;服务下架&#x2F;服务剔除&#x2F;服务续约。自我保护机制、集群通讯。</p><p>模块包括：定期拉取注册表信息、全量拉取、增量拉取 </p><h1 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在启动类点击@EnableEurekaServer注解</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;EurekaServerMarkerConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableEurekaServer &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由Import注解可知，使用了动态代理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerMarkerConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EurekaServerMarkerConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EurekaServerMarkerConfiguration.Marker <span class="title function_">eurekaServerMarkerBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EurekaServerMarkerConfiguration</span>.Marker();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Marker</span> &#123;</span><br><span class="line">        Marker() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虽然逻辑是空的，但是由于自动装配，它会往容器里面装配开发人员所写的配置文件的内容。作用在后面</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/Eureka%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/factories.png"></p><p>Spring.factories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration<span class="comment">//该类才是eureka核心</span></span><br></pre></td></tr></table></figure><h2 id="EurekaServerAutoConfiguration"><a href="#EurekaServerAutoConfiguration" class="headerlink" title="EurekaServerAutoConfiguration"></a>EurekaServerAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明配置类</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//动态注入bean到容器</span></span><br><span class="line"><span class="meta">@Import(&#123;EurekaServerInitializerConfiguration.class&#125;)</span></span><br><span class="line"><span class="comment">//条件注入，判断当前Spring容器是否会有Marker的bean。</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(&#123;Marker.class&#125;)</span></span><br><span class="line"><span class="comment">//所以，到目前为止，当在启动类中加入EnableEurekaServer注解后，会将Marker注入到Spring容器里面，然后在配置eureka时，发现了有Marker就会把EurekaServerAutoConfiguration注入</span></span><br><span class="line"><span class="comment">//相应的配置文件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;EurekaDashboardProperties.class, InstanceRegistryProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:/eureka/server.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">......</span><br><span class="line">     <span class="comment">//核心，把过滤器注册进Tomcat</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;?&gt; jerseyFilterRegistration(Application eurekaJerseyApp) &#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; bean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> <span class="title class_">ServletContainer</span>(eurekaJerseyApp));</span><br><span class="line">        bean.setOrder(<span class="number">2147483647</span>);</span><br><span class="line">        bean.setUrlPatterns(Collections.singletonList(<span class="string">&quot;/eureka/*&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所定义的过滤器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Application <span class="title function_">jerseyApplication</span><span class="params">(Environment environment, ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathScanningCandidateComponentProvider</span>(<span class="literal">false</span>, environment);</span><br><span class="line">        provider.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Path.class));</span><br><span class="line">        provider.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Provider.class));</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        String[] var5 = EUREKA_PACKAGES;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var5.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> var5[var7];</span><br><span class="line">            Set&lt;BeanDefinition&gt; beans = provider.findCandidateComponents(basePackage);</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var10</span> <span class="operator">=</span> beans.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var10.hasNext()) &#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> (BeanDefinition)var10.next();</span><br><span class="line">                Class&lt;?&gt; cls = ClassUtils.resolveClassName(bd.getBeanClassName(), resourceLoader.getClassLoader());</span><br><span class="line">                classes.add(cls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; propsAndFeatures = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        propsAndFeatures.put(<span class="string">&quot;com.sun.jersey.config.property.WebPageContentRegex&quot;</span>, <span class="string">&quot;/eureka/(fonts|images|css|js)/.*&quot;</span>);</span><br><span class="line">        <span class="type">DefaultResourceConfig</span> <span class="variable">rc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResourceConfig</span>(classes);</span><br><span class="line">        rc.setPropertiesAndFeatures(propsAndFeatures);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端启动时会发送服务注册的请求就会进入该方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationResource</span> &#123;</span><br><span class="line"><span class="meta">@POST</span></span><br><span class="line">    <span class="meta">@Consumes(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//info里面就是相关的注册信息</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">addInstance</span><span class="params">(InstanceInfo info, <span class="meta">@HeaderParam(&quot;x-netflix-discovery-replication&quot;)</span> String isReplication)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Registering instance &#123;&#125; (replication=&#123;&#125;)&quot;</span>, info.getId(), isReplication);</span><br><span class="line">        <span class="comment">//必要的信息一定不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isBlank(info.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">&quot;Missing instanceId&quot;</span>).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isBlank(info.getHostName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">&quot;Missing hostname&quot;</span>).build();</span><br><span class="line">        &#125; </span><br><span class="line">        ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其他信息的处理</span></span><br><span class="line">           ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.registry.register(info, <span class="string">&quot;true&quot;</span>.equals(isReplication));</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发布监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title class_">PeerAwareInstanceRegistryImpl</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="type">boolean</span> isReplication)</span> &#123;</span><br><span class="line">         <span class="comment">//监听事件。（自己指定事件，在类上添加@Compoent，在方法上@EventListener，方法参数就是事件类型）</span></span><br><span class="line">        <span class="built_in">this</span>.handleRegistration(info, <span class="built_in">this</span>.resolveInstanceLeaseDuration(info), isReplication);</span><br><span class="line">        <span class="built_in">super</span>.register(info, isReplication);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//集群间的信息共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeerAwareInstanceRegistryImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title class_">PeerAwareInstanceRegistry</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(InstanceInfo info, <span class="type">boolean</span> isReplication)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leaseDuration</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">                <span class="keyword">if</span> (info.getLeaseInfo() != <span class="literal">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//完成注册。通过读写锁</span></span><br><span class="line">                <span class="built_in">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">               <span class="comment">//往其他euraka服务器发送数据</span></span><br><span class="line">                <span class="built_in">this</span>.replicateToPeers(PeerAwareInstanceRegistryImpl.Action.Register, info.getAppName(), info.getId(), info, (InstanceStatus)<span class="literal">null</span>, isReplication);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h1><p>Eureka Server进入自我保护机制后，会出现以下情况：Eureka不再从注册列表中剔除因为长时间没收到心跳而过期的服务；Eureka Server依然可以接受新服务的注册和查询请求，但不会同步到其他节点；网络稳定时，当前实例新的注册信息会被同步到其他节点中。</p><p>自我保护机制是为了<em><strong>防止误杀服务</strong></em>。当个别客户端出现心跳失联，则认为是客户端的问题，剔除客户端；当Eureka捕获到大量的心跳失败，则认为可能是网络问题，进入自我保护；当客户端心跳恢复，Eureka会退出自我保护；</p><p>若在保护期内该服务提供者非正常下线，服务消费者会拿到无效的服务实例，就调用失败。</p><h1 id="对等复制架构"><a href="#对等复制架构" class="headerlink" title="对等复制架构"></a>对等复制架构</h1><p>Eureka本身依赖了Eureka Client，每个Server是作为其他Server 的Client。在单个Eureka Server启动，会有一个syncUP操作，通过Client请求其他Server节点中的一个节点获取注册应用实例信息，再复制到其他peer节点</p><p>EurekaServer采用Peer to peer的复制模式，重点解决数据复制的冲突问题：lastDirtyTimestamp标识和heartbeat。</p><p>针对数据不一致，一般通过比较版本号机制，最后在不同副本之间只需要判断请求复制数据的版本号与本地数据的版本号高地，eureka本身没有版本号属性，所以采用叫做lastDirtyTimestamp字段对比。peer节点之间的相互复制不能保证所有操作都能成功，所以eureka还通过应用实例与Server之间的heatbeat进行数据的最终修复，即发现应用实例数据与某个Server的数据出现不一致，则Server返回404，应用程序重新register。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;底层通过Jersey框架在AWS背景下实现，用过滤器做服务的拦截。核心就是把&lt;em&gt;&lt;strong&gt;过滤器注册进Tomcat&lt;/strong</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Eureka" scheme="http://example.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>IOC和AOP</title>
    <link href="http://example.com/2022/08/22/IOC%E5%92%8CAOP/"/>
    <id>http://example.com/2022/08/22/IOC%E5%92%8CAOP/</id>
    <published>2022-08-22T11:55:28.000Z</published>
    <updated>2022-08-22T12:00:57.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>一种设计思想，控制反转，将设计好的对象交给容器控制。在调用某个类时，容器会实例化，即容器控制对象的创建。实际就是个BeanDefinitionMap，里面放的就是各种对象</p><p>IOC容器实例化过程中，一般不包含bean的依赖注入，bean的注册和依赖注入是两个过程，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xml中配置，在容器初始化的时候，这个bean就完成了初始化。</p><p>Bean是工厂模式创建；数据是通过反射注入，目的是降低耦合度</p><p><a href="https://xiaoerbutingbu.github.io/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">结合Bean的生命周期</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>类比于：我自己找女朋友和我通过婚介公司找女朋友</p><p>控制反转，把我们写好的对象的控制权交给Spring框架，由框架来控制对象的生命周期（创建、销毁，这些对象之间的依赖关系），开发人员不用主动去new这些对象，IOC就是一个容器去创建这些对象，把所有的类都放到容器里面去登记，需要某个对象的时候告诉容器就行。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>  面向切面编程基于IOC。简单说就是将部分重复的代码抽取出来，需要执行的时候用动态代理价技术。不修改代码进行功能增强。<em><strong>解耦</strong></em></p><p>  降低了耦合度，提高了程序的可重用性，同时提高了开发效率</p><p>  底层使用动态代理</p><p>  实现业务和切入类的解耦</p><p>  与OOP相比，一个是横向一个纵向在</p><p>面向切面编程，使用了动态代理，两种实现方式：cglib和JDKProxy</p><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><p>系统由不同的组件组成，不同组件负责不同的功能，会存在很多组件与业务无关（日志、事务、权限等等），而写组件经常融入具体的业务逻辑，若每个具体业务逻辑都添加这些代码，就代码冗余，所以需要将公共的代码逻辑抽象出来变成一个切面，然后注入到具体的业务中。</p><p>所以AOP基于该思路，采用动态代理的方式，将需要注入切面的对象进行代理，在进行调用时候只将公共逻辑添加进去，而不需要修改原有的逻辑代码，只需要在原来的业务逻辑基础上做一些增强功能即可。</p><h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>在bean进行初始化后，beanPostProcessor中有一个AnnotationAwareAspectjAutoProxyCreator的去生成bean对应的代理对象，然后通过getAdvicesAndAdvisorsForBean获取切面信息并返回所有通知的方法；再就是解析切面，通过beanName创建每个对应的Class，再通过遍历含有@Aspect注解类的每个方法，拿到含有@Before等标签的方法，方法即通知，为每个通知创建一个advisor对象并以List形式返回。再筛选作用域当前bean上的增强器；再通过ProxyFactory创建代理对象，返回的是AopProxy接口（cglib和JDK两个实现类）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC&quot;&gt;&lt;/a&gt;IOC&lt;/h1&gt;&lt;p&gt;一种设计思想，控制反转，将设计好的对象交给容器控制。在调用某个类时，容器会实例化，即容器控制对象的创建。实际就是个BeanDefin</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用模型</title>
    <link href="http://example.com/2022/08/19/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2022/08/19/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2022-08-18T21:48:05.000Z</published>
    <updated>2022-08-18T21:53:59.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>程通过告诉多路复用器（内核）所有的socket号，多路复用器再去获取每一个socket的状态，当程序获取到某个socket号有事件发生了，则去该socket号上进行处理对应的事件，read事件或者是recived事件。</p><p>一个线程监测多个IO操作</p><h1 id="Select模型"><a href="#Select模型" class="headerlink" title="Select模型"></a>Select模型</h1><p>属于linux下的标准函数。时间O(N)。</p><p>仅仅知道有几个I&#x2F;O事件发生，但不知道具体是哪几个socket连接有I&#x2F;O事件，还需要轮询去找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="comment">//需要监听和扫描最大fd个数</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> maxfd,</span></span><br><span class="line"><span class="params">    <span class="comment">//本身是fdset集合，文件描述符。分别为 读事件列表、写事件列表、异常事件列表</span></span></span><br><span class="line"><span class="params">    fd_set *readset,</span></span><br><span class="line"><span class="params">    fd_set *writeset,</span></span><br><span class="line"><span class="params">    fd_set *exceptset,</span></span><br><span class="line"><span class="params">    <span class="comment">//监听时间，超时返回0，错误返回1，正常有数据可读的话就返回fd的个数</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>   从用户空间拷贝fd_set到内核空间；再遍历所有fd文件，并将当前进程挂到每个fd的等待队列中，并将当前进程挂到每个fd的等待队列中，当某个fd文件收到消息后，会唤醒等待队列上睡眠的进程，那么当前进程就会被唤醒；若遍历完fd都没有I&#x2F;O事件，当前进程会睡眠直到某个fd文件有I&#x2F;O事件或睡眠超时</p><p>​    缺陷：&#x3D;&#x3D;对socket进行线性扫描（轮询）IO&#x3D;&#x3D;，效率低，程序不知道哪些socket收到数据，需要每次全部遍历，浪费CPU；限定大小，因为保存文件描述符的bitmaps32位是1024，64位2048；内核态与用户态频繁复制fd数据开销大；每次调用都要把fd从用户态拷贝到内核态；</p><p>交互流程：用户态监听socket，再调用select（然后用户态就开始线程阻塞），内核态执行准备数据，准备完毕后告诉用户态select可读，用户态就read请求，内核态数据拷贝到用户态，用户态read完成。就完成一个交互流程</p><h1 id="poll模型"><a href="#poll模型" class="headerlink" title="poll模型"></a>poll模型</h1><p>本质与select无区别；将用户给的数组拷贝进内核，查询每个fd对应设备的状态。时间O(N)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> pollfd *fds, <span class="comment">//需要监听的文件描述符列表</span></span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> nfds,<span class="comment">//文件描述符个数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout  <span class="comment">//超时时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;      <span class="comment">//需要监视的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;<span class="comment">//内核扫描的事件集合</span></span><br><span class="line">    <span class="type">short</span> revents;<span class="comment">//events扫描完派生出需要返回给用户态的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于select突破了1024的限制（因为采用了pollfd数据结构，是一个链表）；</p><p>标志准备就绪的，用户态只关心revents，内核态也不用重置原数据</p><p>若遍历fd都没有就绪设备就挂起当前线程，直到设备就绪或主动超时，被唤醒后再次遍历fd</p><p>​             没有最大连接次数（因为恢复revents）；大量fd数组复制进内核（有些无意义）；若报告的fd没处理，那下次poll会再次报告fd</p><p>​           有超时时间，5个FD拷贝到内核态并监听数据</p><p>​           有数据时内核会对revents字段置位，poll返回，遍历找置位读数据</p><h1 id="Epoll模型"><a href="#Epoll模型" class="headerlink" title="Epoll模型"></a>Epoll模型</h1><p>可水平触发（LT）和边缘触发（ET），默认是LT；<em><strong>不是轮询，是回调机制</strong></em>。O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内核态创建epoll实例。底层是红黑树和就绪链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//对红黑树操作，添加所有socket节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> op,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//线程阻塞，内核查找红黑树中ready的socket，放入就绪列表，就绪列表中内置内存到events</span></span><br><span class="line"><span class="comment">//算是事件通知，只把准备好的事件告诉用户态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events,</span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有最大并发连接的限制；效率提升；内存拷贝</p><p>​             连接数较多且很多的不活跃连接时，epoll效率更好；反之，epoll因需要回调，所以性能此时会低</p><p>每个文件描述符上都有一个callback函数，当socket有事件时会回调这个函数将该fd的引用放到列表中，且会指出哪些文件描述符就绪。所以，可以直接处理</p><p>LT（阻塞和非阻塞皆可）：当文件描述符上的事件就绪后，若事务没有处理完或没有处理，那epoll会在下次提醒应用程序。就是内核会持续通知文件描述符已经就绪，我就可以对就绪的FD执行I&#x2F;O操作。</p><p>ET（仅阻塞）：当文件描述符上的事件就绪后，若事务没有处理完或没有处理，下一次epoll就不会提醒应用程序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;程通过告诉多路复用器（内核）所有的socket号，多路复用器再去获取每一个socket的状态，当程序获取到某个socket号有事件发生了，则</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="IO模型" scheme="http://example.com/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis核心类</title>
    <link href="http://example.com/2022/08/17/Mybatis%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
    <id>http://example.com/2022/08/17/Mybatis%E6%A0%B8%E5%BF%83%E7%B1%BB/</id>
    <published>2022-08-16T17:38:46.000Z</published>
    <updated>2022-08-16T17:44:30.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h1><p>是利用XML或Java编码编码获得资源来构建SqlSessionFactory（可以构建多个），一旦构建完，作用就没了，就可以回收。它的生命周期只存在与方法的局部，<em><strong>作用就是生产SqlSessionFactory</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;</span><br><span class="line">    <span class="comment">//各种构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSessionFactoryBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, (String)<span class="literal">null</span>, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, environment, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, (String)<span class="literal">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得XMLConfigBuilder，new出一个成员变量configuration</span></span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">            var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, (String)<span class="literal">null</span>, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, environment, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, (String)<span class="literal">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">            var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h1><p>每个基于MyBatis的应用都是一个SqlSessionFactory的实例为中心的，该实例通过SqlSessionFactoryBuilder获得。而Builder可以从XML配置文件或通过java的方式构建SqlSessionFactory实例。</p><p><em><strong>作用就是去创建SqlSession</strong></em>。每次应用需要访问数据库，就要通过SqlSessionFactory创建SqlSession。若多次创建同一个数据库的SqlSessionFactory，则每次创建的都会打开更多数据库连接资源，所以连接资源会被消耗。所以<em><strong>SqlSessionFactory是唯一的</strong></em>，于是采用单例模式，若采用多例就对数据库连接消耗大且不利于管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSessionFactory</span> &#123;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">()</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(Connection var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, <span class="type">boolean</span> var2)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, TransactionIsolationLevel var2)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, Connection var2)</span>;</span><br><span class="line">    Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个工厂，创建SqlSession对象，SqlSession是MyBatis面向数据库的高级接口，提供了执行查询sql、更新sql等</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>首先需要提供配置文件和相关的参数。采用<em><strong>构造模式</strong></em>去创建SqlSessionFactory，通过SqlSessionFactoryBuilder构建</p><p>分两步：</p><p>​解析XML文件，读出配置参数，将读取的数据存入Configuration（MyBatis基本所有的配置都是在这）</p><p>​使用Configurattion对象去创建SqlSessionFactory。因SqlSessionFactory本身是一个接口，一般情况使用其实现类之中的DefaultSqlSessionFactory。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>作用：读入配置文件，包括基础配置XML文件和映射器XML文件；初始化基础配置（别名啊、类的对象啊）；提供单例，为后续创建SessionFactory服务并提供配置的参数；执行一些重要的对象的方法，初始化配置信息；</p><p>configuration做的初始化信息：全局参数、设置、别名、插件、类型处理器等等</p><h1 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h1><p>MyBatis的顶层API接口，作为会话访问，完成CRUD，有两个实现类，通过内部存放的执行器来对数据进行CRUD操作，<em><strong>非线程安全</strong></em>，所以每次都要close关闭。</p><p>一个会话，相当于JDBC的一个Connection对象，长期的存在会让数据库连接池的活动资源减少</p><h2 id="四大对象"><a href="#四大对象" class="headerlink" title="四大对象"></a>四大对象</h2><p>映射器就是一个动态代理对象，进入到MapperMethod的executte方法。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>真正执行Java和数据库交互的东西。</p><p>有三种：</p><p>​SIMPLE：简易执行器，默认的</p><p>​REUSE：执行器重用预处理语句</p><p>​BATCH：执行器重用语句和批量更新，针对批量专用的执行器</p><p>三种都提供了查询和更新方法，以及相关的事务方法</p><h3 id="数据库会话器"><a href="#数据库会话器" class="headerlink" title="数据库会话器"></a>数据库会话器</h3><p>专门处理数据库会话的。</p><p>定义了一个对象的适配器delegate，根据配置来适配对应的StatementHandler对象。作用就是给实现类对象的使用提供一个同一、简易的使用适配器。可以使用现有的类和方法对外提供服务、可以根据实际的需求对外屏蔽一些方法甚至加入新服务。</p><h3 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h3><p>参数处理器对预编译语句进行参数设置</p><h3 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h3><p>组装结果集的返回。</p><p>MyBatis提供了DefaultResultSetHandler类，默认状况都是这个类进行处理</p><h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>SqlSession是通过Executor创建StatementHandler运行，statement需要经过：</p><ul><li>prepared预编译SQL</li><li>parameterize设置参数：调用paremeterHandler方法设置，参数类型根据类型处理器typeHandler处理</li><li>query&#x2F;update执行SQL：通过resultHandler进行处理结果的封装，若是update就返回整数，反之通过typeHandler处理结果类型，再用ObjectFactory提供的规则组装对象，返回调用者</li></ul><h1 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h1><p>一个接口，没有任何实现类，作用就是发送SQL，在一个SqlSession事务方法之内，是一个方法级别的东西。如果JDBC的一条SQL语句执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SqlSessionFactoryBuilder&quot;&gt;&lt;a href=&quot;#SqlSessionFactoryBuilder&quot; class=&quot;headerlink&quot; title=&quot;SqlSessionFactoryBuilder&quot;&gt;&lt;/a&gt;SqlSessionFact</summary>
      
    
    
    
    <category term="Mybatis" scheme="http://example.com/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="http://example.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://example.com/2022/08/13/MAC/"/>
    <id>http://example.com/2022/08/13/MAC/</id>
    <published>2022-08-12T20:15:17.000Z</published>
    <updated>2022-08-12T20:24:46.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>MAC（数据链路层）是实现 直连 两个设备之间通信</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>该层是负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报</p><p>该层是在物理层提供服务的基础上向网络层提供服务，最基本的就是将原子网络层的数据可靠的传输到相邻节点的目标机网络层。作用是<em><strong>加强物理层传输原始比特流的功能</strong></em>，将物理层提供的可能出错的物理连续改造为***逻辑上无差错的数据</p><p>使用的信道有两种：点对点信道和广播信道</p><h1 id="三大特定"><a href="#三大特定" class="headerlink" title="三大特定"></a>三大特定</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>帧：链路层的协议数据单元，封装网络层数据报。<em><strong>只有数据链路层才能识别帧，物理层只是传输比特流</strong></em></p><p>因为物理层只是负责传输，无法控制和判断是否出错，且在传输过程中容易受到环境干扰，进行产生错误。于是数据链路层需要负责<em><strong>差错检测</strong></em>的工作</p><h3 id="帧的结构"><a href="#帧的结构" class="headerlink" title="帧的结构"></a>帧的结构</h3><p>网络层将IP数据报传送到数据链路层作为帧的数据部分，数据链表路层分别在前后增加了一个标记（SOH和EOT），作为数据开始和结束。帧在物理层就是一串01比特流。<em><strong>帧首部和尾部是特定的控制字符</strong></em></p><p>​||帧首部||帧数据部分||帧尾部||</p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>无论什么样的比特组合的数据能通过数据链路层。数据看不见链路层有什么阻碍数据传输的东西，所以对这些数据来说就是透明的。</p><p>解决：发送端的数据链路层在数据中出现控制字符（EOT或SOH）的前面插入一个转义字符（ESC）。字节填充或字符填充</p><p>方法有比特填充法和字符填充</p><p>&#x3D;&#x3D;帧采用零比特填充&#x3D;&#x3D;：发送端发现有连续的5个1，就填入1个0；接收端发现有5个连续的1就删除其后的0。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>在传输过程中可能出现比特差错：1和0可能变化。为了保证数据传输的可靠性，在计网传输数据时，必须采用各种差错检测措施。</p><p>奇偶校验码和循环冗余检验码CRC。</p><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><img src="/2022/08/13/MAC/data.png"></p><p>根据IP地址寻找MAC地址</p><p>源MAC地址就是发送数据的计算机的MAC地址，很轻易获取</p><h2 id="公理"><a href="#公理" class="headerlink" title="公理"></a>公理</h2><p>每一个计算机或路由器都有一个<em><strong>ARP高速缓存表</strong></em>，也就是IP地址与MAC地址的映射表</p><p>ARP高速缓存表中只会存储<em><strong>当前局域网</strong></em>内的设备信息，包括不限于连接此局域网接口所对应的<em><strong>IP与MAC映射信息</strong></em></p><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p>首先计算机判断目的IP地址是否是同网段的IP</p><h3 id="源主机和目标主机在同一局域网"><a href="#源主机和目标主机在同一局域网" class="headerlink" title="源主机和目标主机在同一局域网"></a>源主机和目标主机在同一局域网</h3><p>计算机在ARP地址表中查询目的IP地址</p><p>若ARP地址表能查到，就会获取IP地址对应的MAC地址，将信息发送到这个MAC地址对应的计算机中。</p><p>若ARP地址表查不到，就以<em><strong>单播</strong></em>的方式，将自己的IP地址和MAC地址根据请求中的源IP地址响应给计算机；计算机将接收到到IP地址和MAC地址添加到自己的ARP地址表中，再根据MAC地址将数据发送给对方</p><h4 id="源主机和目标主机在不同局域网"><a href="#源主机和目标主机在不同局域网" class="headerlink" title="源主机和目标主机在不同局域网"></a>源主机和目标主机在不同局域网</h4><p>计算机通过路由器与局域网的连接口，先将数据发送给路由器（路由器的每个接口都有对应的IP地址和MAC地址），路由器通过算法选择最优路线将信息发给<em><strong>目标主机所在局域网的路由器上</strong></em></p><p>目标主机的路由器收到信息后，先检查自己的ARP地址表：若有目标IP地址，就直接发；若没有，在局域网内&#x3D;&#x3D;广播&#x3D;&#x3D;，目标主机收到广播后会返回自己的IP和MAC地址，路由器将收到IP地址和MAC地址并存储到自己的ARP地址表中，然后发主机过去</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2022/08/13/MAC/liucheng.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;p&gt;MAC（数据链路层）是实现 直连 两个设备之间通信&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; cl</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构</title>
    <link href="http://example.com/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-08-10T17:30:38.000Z</published>
    <updated>2022-08-10T17:36:33.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>最基本的，动态可修改字符串，二进制安全，存数字时底层是int编码；长字符串（长度&gt;39字节）raw编码；短字符串（长度&lt;39字节）embstr编码。长度不能超过512MB。整体类似于ArrayList</p><p>​存储double类型的浮点数是先转换为字符串再存储。raw和embstr编码效果相同，不同于内存分配释放，raw一次，embstr两次；embstr内存快连续，能更好的利用缓存带来的优势；</p><p>利用key的生命周期做投票系统；String特点数据刷新；利用数值操作特征为分布式数据库自增。访问次数、点赞、转发量；计数器、限流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line">struct sdshdr&#123;</span><br><span class="line">    <span class="comment">//记录SDS所保存的字符串长度</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组未使用的空间数量</span></span><br><span class="line"><span class="type">int</span> free;</span><br><span class="line">    <span class="comment">//字符串数组，保存字符串</span></span><br><span class="line"><span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//综上：常数获取字符串长度；避免缓冲区移除；减少重分配次数：内存不足时，会触发自动扩容；SDS API会以处理二进制的方式处理存放的buf数组里的数据，程序不会对其中做任何限制、过滤、假设，二进制安全；</span></span><br></pre></td></tr></table></figure><p>del key,get key,set key value</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>简单的字符串列表，<em><strong>底层是linkedlist和ziplist</strong></em>（元素数量&lt;512，所有对象元素长度小于64字节就使用ziplist反之就linkedlist）。</p><p>​ziplist：将所有元素紧挨着一起存储，分配的是一块连续的内存</p><p>​linkedlist:会有前驱后驱指针</p><p>可用于消息队列；顺序特性实现朋友圈点赞；顺序特性进行分布式日志顺序性展示；发布和订阅；慢查询</p><p>  Lpush,lpop,rpop,rush,</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>是一个键值对集合，是一个String类型的key和value的映射表。相当于hashmap。存放对象类型的数据，可避免键名冲突。 用户的购物车；hash作为商品秒杀技术对象完成商品秒杀系统</p><p>底层：ziplist（元素数量&lt;512个，所有值&lt;64字节）和hashtable</p><p>redis为了提高性能，不能阻塞服务，采用了渐进式策略</p><p>hset,hgetall,hlen,hget</p><p>用来缓存作为用户信息</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>String类型的无序集合，底层哈希表和intset（所有元素是整数，元素数量小于512）</p><p>​intset：有序不重复的连续空间；</p><p>sadd key element[ ]</p><p>比如标签；黑白名单；获取所有业务的权限、用户标签</p><h1 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h1><p>组成：ziplist（元素数量小于128，所有元素长度&lt;64）和跳跃表+哈希结合，value保证唯一性，又可为每个value代表权重的值。</p><p>跳表：每一层都是一个有序链表，默认升序。跳表中有表头节点和表尾节点。zskiplistNode中包含层、后退指针、分值、成员对象。底层拥有所有元素，插入元素的时候会随机生成一个“层次数字”，然后元素插入达到这个层次的所有底层，直到原始链表层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;<span class="comment">//跳表，目的就是为了高效支持范围查找</span></span><br><span class="line">&#125; zset;</span><br><span class="line"><span class="comment">//跳表节点</span></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    <span class="comment">//保存数据</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//权重</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    level数组</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        <span class="comment">//前向指针</span></span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        <span class="comment">//跨度，记录跨越了level0上的几个结点</span></span><br><span class="line">        unsigned <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"><span class="comment">//跳表</span></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">   <span class="comment">//跳表的头结点和尾结点 </span></span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">   <span class="comment">//最大长度 </span></span><br><span class="line">    unsigned <span class="type">long</span> length;</span><br><span class="line">   <span class="comment">//最大层数 </span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳表会从头节点的最高层开始查找下一个节点，因为节点中有元素和权值，所以两者都要比较</span></span><br><span class="line"><span class="comment">//若当前定位的元素权值更小，就访问该层下一个节点</span></span><br><span class="line"><span class="comment">//若当前定位的元素权值与需要查询的权值相同，就比较元素值，若定位的元素值数据更小，还是访问该层下一个节点</span></span><br><span class="line"><span class="comment">//以上两个条件都不满足就会访问level数组的下一层指针，沿着下一层指针找</span></span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">           ...</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>跳表在创建节点的时候，采用了随机生成节点层数的方法。&lt;&#x3D;25%</p><p>排行榜系统；带权重任务队列；根据权重进行排序</p><p>zadd  key score member[]</p><p>搜索路径如图：要检索19</p><p><img src="/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/19.png"></p><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>Bitmaps:String类型上的一组面向bit操作的集合，不是真的数据结构，优点就是存储信息可节省大量空间。一般用于实时分析，存储对象ID关联的节省空间且高性能的布尔信息。底层是String</p><p>HyperLogLogs：用于计算唯一事物的概率数据结构。可用于计算用户每天在搜索框中执行唯一的搜索。底层是String</p><p>  GEO：存储用户给定的地理位置信息，并对这些信息操作。底层是zset</p><p>  Streams：内存版的kafka</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt;最基本的，动态可修改字符串，二进制安全，存数字时底层是int编码；长字符串（长度&amp;gt;39字节）raw编码</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>基础题1</title>
    <link href="http://example.com/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/"/>
    <id>http://example.com/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/</id>
    <published>2022-08-08T16:11:35.000Z</published>
    <updated>2022-08-08T16:28:37.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h1><p>Java9之后就是通过byte[] value 实现</p><p><img src="/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/String.png"></p><h1 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h1><p>主要用在 变量、方法、类</p><p>修饰类对象的时候，属性值还是可以变化。</p><p>使用原因：把方法锁定，防止任何类修改它的含义；提升效率性能；多线程下保持了线程安全。</p><p>修饰基本类型值不变，<em><strong>修饰引用类型只是引用不可变，但是引用所指向的地址的内容可以改变</strong></em></p><p><strong>只被final修饰但是没给初始值的情况下的基本数据类型是可以通过反射改变值</strong></p><p>final修饰的属性的初始化可以在编译器、运行期，初始化后不能被改变</p><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><p>当变量被static final修饰时，该变量的值是不能被改变且必须给初始值；</p><p>只被final修饰的变量在定义时没给初始值是能通过反射改变代码运行期间所赋予的值，而在定义时就给了初始值的通过反射也不能改变值</p><h1 id="为什么重写equals要重写hashcode"><a href="#为什么重写equals要重写hashcode" class="headerlink" title="为什么重写equals要重写hashcode"></a>为什么重写equals要重写hashcode</h1><p><img src="/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/hashcode.png"></p><p>首先hashCode是一个本地方法，不同虚拟机有不同实现，主要是为了给HashMap这样的哈希表的使用。</p><p>设计该方法的重要因素：对同一个对象调用该方法应该产生相同的值，所以需要快、不需要唯一性。</p><p>equals相等，hashcode一定相等：</p><p>equals不等，hashcode不一定不等：这是为了尽量减少哈希冲突，因为hashcode是int类型，有范围，难免冲突，此时hashmap通过拉链法解决冲突</p><p>hashcode不等，equals一定不等</p><p>hashcode相等，equals不一定相等</p><p>综上：</p><p>若重写equals，就一定要重写hashCode</p><p>提高效率：先进行hashcode比较，若不同就不用再比较，就提高了效率</p><h1 id="抽象类（JDK8）"><a href="#抽象类（JDK8）" class="headerlink" title="抽象类（JDK8）"></a>抽象类（JDK8）</h1><p>不一定要有抽象方法</p><p>不能用final修饰，因为final修饰了就不能被修改和继承了</p><h2 id="与接口的区别"><a href="#与接口的区别" class="headerlink" title="与接口的区别"></a>与接口的区别</h2><ul><li>抽象类可以提供成员方法的实现细节，而接口只能包含抽象方法、普通方法。</li><li>抽象类的成员变量可以是各种类型，接口中的成员变量只能是public static final</li><li>抽象类可有静态代码和静态静态方法，接口不能含有静态代码块和静态方法</li><li>抽象类可有构造器，接口不能有有构造器</li><li>一个子类只存在一个父类，一个子类可以存在多个接口</li></ul><h2 id="与普通类"><a href="#与普通类" class="headerlink" title="与普通类"></a>与普通类</h2><p>普通类：不能含有抽象方法，可以直接实例化</p><p>抽象类：可以有抽象方法，不能直接实例化</p><h1 id="x3D-x3D-和equals"><a href="#x3D-x3D-和equals" class="headerlink" title="&#x3D;&#x3D;和equals"></a>&#x3D;&#x3D;和equals</h1><table><thead><tr><th align="center">&#x3D;&#x3D;</th><th align="center">Equals</th></tr></thead><tbody><tr><td align="center">运算符</td><td align="center">方法</td></tr><tr><td align="center">若比较基本类型，则比较数值（即使数据类型不同，比如 int  i&#x3D;1,double k &#x3D;1.0）；若是引用数据类型，则比较内存地址值</td><td align="center">比较方法的两个对象内容是否相等  不能比较基本数据类型的变量；  若没有重写（也是默认情况），则比较的是引用数据类型的变量所指向的对象的地址</td></tr><tr><td align="center">比较浮点型数据时导致数据精度丢失</td><td align="center"></td></tr></tbody></table><h1 id="解决Hash冲突"><a href="#解决Hash冲突" class="headerlink" title="解决Hash冲突"></a>解决Hash冲突</h1><p>开放地址法：一旦发生了冲突，就寻找下一个空的散列地址。 H<del>i</del>&#x3D; (H(key) + d<del>i</del>)%m;  m为哈希表长，d<del>i</del>为增量序列</p><p>再哈希算法：一直调用哈希函数，计算地址，直到没有冲突。不易发生聚集，但增加了计算时间</p><p>链地址（HashMap所用）：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接。</p><p>建立公共溢出区：将哈希表分为基本表和溢出表两个部分，凡是和基本表发生冲突的元素都填入溢出表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;StringBuilder和StringBuffer&quot;&gt;&lt;a href=&quot;#StringBuilder和StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;StringBuilder和StringBuffer&quot;&gt;&lt;/a&gt;StringBu</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="题" scheme="http://example.com/tags/%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集系统</title>
    <link href="http://example.com/2022/08/04/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2022/08/04/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-08-04T08:01:59.000Z</published>
    <updated>2022-08-04T08:13:42.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>运行过程中，会产生大量内存垃圾，为确保程序运行时的性能，虚拟机在程序执行过程中药不断进行自动的垃圾回收</p><p> 收集 三个内存区域</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>历史最悠久的，单线程工作，垃圾收集时会暂停其他所有工程线程，直到收集结束（用户不可知）</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial收集器的多线程并发版本</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>一款以<em><strong>最短回收停顿时间为目标</strong></em>的收集器。</p><p>基于标记-清除算法实现。四个步骤：初始标记、并发标记、重新标记、并发清除</p><p>优点：并发收集、低停顿</p><p>缺点：对处理器资源敏感、无法处理“浮动垃圾”、大量空间碎片</p><h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>低延迟的，<em><strong>染色指针技术</strong></em>：将少量额外的信息存储在指针上的技术。</p><p>步骤：并发标记、并发预备重分配、并发重分配、并发重映射</p><h1 id="判断是否可以回收"><a href="#判断是否可以回收" class="headerlink" title="判断是否可以回收"></a>判断是否可以回收</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p> 引用计数法：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。原理简单，效率也很高。已被淘汰，它不能解决循环引用。</p><p>  可达性分析算法：从GC Roots作为根对象开始向下搜索，搜索所走过的路径被称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收</p><p>可作为GC roots：栈帧中的本地变量表中引用的对象（比如：堆栈中用到的参数、局部变量、临时变量）；方法区中静态属性引用的对象（java类的引用类型静态变量）；方法区中常量引用的对象（字符串常量池的引用）；本地方法栈中native方法引用的对象；所有同步锁（synchronized）持有的对象</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>当经过可达性分析算法判定为可以删除后，就只是对其进行一次标记，之后还要筛选，看该对象是否有必要执行finalize方法，如果没有覆盖finalize方法或者已经被虚拟机调用那就视为“没有必要执行”。</p><p>如果该对象判定为有必要执行方法，那该对象就被放置一个名为F-Queue的队列之中，之后在由虚拟机自动建立的、低调度优先级的Finalizer线程执行finalize方法（但虚拟机不一定会等待它运行结束），稍后收集器对F-Queue中的对象进行第二次标记，第二次标记成功就代表要被回收了。</p><p>如果对象要从F-Queue中逃脱，就要重新与引用链上的任一对象关联。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记无用对象，然后进行清除回收。效率不高，无法清理出垃圾碎片；执行效率不稳定。因为标记和清除的效率随着需清理对象的增长而降低</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>按容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，再把已使用的内存空间一次清理。适合对象较少的时候，即使用年轻代；会产生大量的内存间复制的开销</p><p>但对于多数对象要回收的情况，需要复制的对象就较少，也不用考虑空间碎片，只要移动堆顶的指针，按顺序分配即可。但因为内存对半分开，空间浪费</p><h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><p>标记无用对象，让所有存活的对象向一端移动，然后直接清除掉边界外的内存</p><p>分代收集算法：根据对象存活周期的不同将内存划分几块，一般是新生代（复制算法清除）和老年代（标记整理算法清除）</p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>Minor GC(Young GC):只是新生代的垃圾收集</p><p>​年轻代空间不足时，就触发，即Eden代满了，survivor满不会引发gc</p><p>​非常频繁，回收速度也快</p><p>Major GC(old gc)：只是老年代的垃圾收集，执行速度比Minor GC慢10倍以上</p><p>​只有CMS GC会有单独收集老年代的行为</p><p>Mixed GC：收集整个新生代以及部分老年代的垃圾收集</p><p>Full gc：回收这个堆和方法区的垃圾收集</p><h1 id="频繁发生Full-GC"><a href="#频繁发生Full-GC" class="headerlink" title="频繁发生Full GC"></a>频繁发生Full GC</h1><p>发生在system.gc()调用，老年代空间不足，永生区空间不足，堆分配了大对象</p><p>注意两种数据结构：linkedBlockingQueue：当数据量很大，就会无限放数据，就导致full gc；所以要使用有参构造函数并合理设置节点数量</p><p>线程池：消息量大造成内存消耗过快，是因为队列无限存放数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;运行过程中，会产生大量内存垃圾，为确保程序运行时的性能，虚拟机在程序执行过程中药不断进行自动的垃圾回收&lt;/p&gt;
&lt;p&gt; 收集 三个内存区域&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="http://example.com/2022/08/01/LinkedList/"/>
    <id>http://example.com/2022/08/01/LinkedList/</id>
    <published>2022-08-01T10:02:48.000Z</published>
    <updated>2022-08-01T10:04:58.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>基于双向链表实现，可作为双向队列，随机访问集合元素较能较差，因为需要在双向链表中招待index位置再返回。底层是Node数据结构，有两个指针first和last分贝指向头和尾。</p><p>更适合删除添加</p><p>但查询最链表的第一个和最后一个元素也很快，不用遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br><span class="line">    <span class="comment">// LinkedList的大小，其实就是其内部维护的双向链表存储元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 头结点，指向第一个节点的指针或引用，默认为 null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">// 尾节点，指向最后一个节点的指针或引用，默认为 null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 因为LinkedList是双向链表，所以node需要前驱和后驱指针</span></span><br><span class="line"><span class="comment">    * 一定要是static的：若不用static修饰，那node就是一个普通的内部类，java中一个普通的内部类在实例化后，默认会有外部类的引用，所以就有可能会内存泄露</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">            <span class="comment">// 存储的元素</span></span><br><span class="line">            E item;</span><br><span class="line">            <span class="comment">// 指向下一个节点</span></span><br><span class="line">            Node&lt;E&gt; next;</span><br><span class="line">            <span class="comment">// 指向上一个节点</span></span><br><span class="line">            Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">                <span class="built_in">this</span>.item = element;</span><br><span class="line">                <span class="built_in">this</span>.next = next;</span><br><span class="line">                <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     * 构造包含指定元素的列表集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 如果 c 为 null，则会抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">// 指向无参的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素添加到指定的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引角标不合法，则抛出索引越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 index 是否合法，不合法则抛出索引越界异常</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 判断要添加的是否是最后一个索引位置</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素 e 添加到链表最后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果当前链表还没有元素，则将当前元素赋值为 first</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 用来记录 LinkedList 结构性变化的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素 e 插入到指定的 index 索引位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取原本 index 索引位置的元素的前节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 用来记录 LinkedList 结构性变化的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素索引处的(非空)节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 它对 index 与集合长度的一半做比较，来确定是在集合的前半段还是后半段进行查找，</span></span><br><span class="line">    <span class="comment">// 从而达到节省一半的时间。</span></span><br><span class="line">    <span class="comment">// size&gt;&gt;1 相当于 size/2，这里的意思就是判断 index 的位置在前半段还是后半段</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h1&gt;&lt;p&gt;基于双向链表实现，可作为双向队列，随机访问集合元素较能较差，因为需要在双向链表中招待index位置再返回。底层是Node数据结构，有两个指针</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="List" scheme="http://example.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>AQS-ReentrantLock</title>
    <link href="http://example.com/2022/07/29/AQS-ReentrantLock/"/>
    <id>http://example.com/2022/07/29/AQS-ReentrantLock/</id>
    <published>2022-07-28T19:21:09.000Z</published>
    <updated>2022-07-28T19:47:57.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>用来构建锁和同步器的框架，AQS能简单且高效的构造出应用广泛的大量的同步器</p><p>是JDK提供的一个同步框架，内部维护着FIFO双向队列，即CLH同步队列</p><p><img src="/2022/07/29/AQS-ReentrantLock/FIFO.png"></p><p>AQS依赖它来完成同步状态管理（Volaile修饰的static，用于标志是否持有锁）。如果获取<em><strong>同步状态state</strong></em>失败时，会将当前线程及等待信息封装成一个Node，将Node放到FIFO队列里，同步阻塞当前线程，当线程将同步状态state释放时，会把FIFO队列中的首节唤醒，</p><p>队列中的头部有一个为空的线程，占位的，称呼为傀儡节点或哨兵节点。一开始没有，往队列中插入第一次线程（Node）时插入</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>CountDownLatch(计时器)：允许count个线程阻塞在一个地方，直至所有线程的任务都执行完</p><p>Semaphore(信号量)、CyclicBarrier（循环栅栏）、ReentrantLock、ReetrantReadWriteLock（读写锁）</p><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>抢到资源的线程直接使用处理业务逻辑，若请求的共享资源被占用即没抢到资源，那就需要一套线程阻塞等待以及被唤醒时锁分配的机制（AQS是用CLH队列锁实现），将暂时获取不到的锁的线程加入队列。队列就是AQS的抽象表现。将请求共享资源的线程封装成队列的结点node，通过CAS、自旋以及LockSupport.park()维护state变量的状态，使并发达到同步效果</p><p><img src="/2022/07/29/AQS-ReentrantLock/zhuangtai.png"></p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>里面会有一个volatile修饰的int同步状态变量state，通过CAS去修改这个变量值，若修改成功，线程就会表示获取到了锁，没有成功或state已经是一个加锁的状态了，就通过一个waiter这个对象封装线程添加到FIFO等待队列里面，再把它挂起等待被唤醒。</p><h1 id="AQS部分源码"><a href="#AQS部分源码" class="headerlink" title="AQS部分源码"></a>AQS部分源码</h1><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractQueuedSynchronizer</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//同步器指向队列的头节点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">//同步器指向队列的尾巴节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">//当前锁的状态</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock部分源码"><a href="#ReentrantLock部分源码" class="headerlink" title="ReentrantLock部分源码"></a>ReentrantLock部分源码</h1><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node队列"><a href="#Node队列" class="headerlink" title="Node队列"></a>Node队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//指示节点在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">//指示节点以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//各种状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//node处于上述状态的标志位</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">//前驱、后驱指针</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//封装到node的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//连接到等待条件的下一个节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，默认创造非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// true和false创造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//看state是否是0，即判断是否有人占用</span></span><br><span class="line">            <span class="comment">//若没有人占用锁，就让当前线程持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//非公平锁相比与公平锁相比，少了一个判断!hasQueuePredecessors()</span></span><br><span class="line"><span class="comment">//后面没有抢到锁的线程   此时的arg=1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">//将该节点放入队列</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//模板方法设计模式，必须有这个实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用非公平锁的尝试获取</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">     <span class="comment">//获取state状态变量</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">     <span class="comment">//=0,锁就没有线程获取</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//该线程是否抢到了锁</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//把当前线程放入持有者</span></span><br><span class="line">             setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//当前线程是否是持有锁的线程.可重入锁</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//enq：准备进入队列。让该线程的头结点就指向队列中的最后一个线程（若队列没线程，就加一个傀儡节点），最后一个线程的next指针指向该线程，同步器的尾指针指向该线程。</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;用来构建锁和同步器的框架，AQS能简单且高效的构造出应用广泛的大量的同步器&lt;/p&gt;
&lt;p&gt;是JDK提供的一个同步框架，内部维护着FIFO双向</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ReentrantLock" scheme="http://example.com/tags/ReentrantLock/"/>
    
    <category term="AQS" scheme="http://example.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList部分解析</title>
    <link href="http://example.com/2022/07/26/ArrayList/"/>
    <id>http://example.com/2022/07/26/ArrayList/</id>
    <published>2022-07-25T21:35:26.000Z</published>
    <updated>2022-07-25T21:44:23.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>基于数组实现容量大小动态变化，基于索引的数据结构，随机访问集合元素上有较好的性能，<em><strong>扩容机制是1.5倍</strong></em>。底层是Object数组实现，地址连续，动态扩容，允许包括null在内的任何元素插入；非线程安全，异步；</p><p>创建对象时，若用的无参构造器，初始elementData容量为0，第一次添加则扩容到10，再扩容就是1.5倍；构造器也可以指定大小</p><p>更适合随机查找，查询块，也可以根据下标查询</p><p>扩容有两个部分：确定最小容量的值，调用grow方法。Arrays.copyOf完成扩容</p><p>把传入集合转换为数组，再通过Arrays.copyOf()拷贝到elementData</p><p>add方法需要先确定是否要扩容再进行赋值操作</p><h1 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">//初始化的容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空数组（用于空实例）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认大小空实例的共享空数组实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//保存ArrayList数据的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">//所含有的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）      </span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="add"><a href="#add" class="headerlink" title="add"></a>add</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">// 扩容</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">       <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">       <span class="comment">//是否越界</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       <span class="comment">//保证此时的容量大小</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//arraycopy()实现数组之间复制的方法，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以最小容量进行扩容</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组. 若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间（newCapacity的连续空间）</span></span><br><span class="line">        <span class="comment">// 并将elementData的数据复制到新的内存空间</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比较 minCapacity 和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;基于数组实现容量大小动态变化，基于索引的数据结构，随机访问集合元素上有较好的性能，&lt;em&gt;&lt;strong&gt;扩容机制是1.5倍&lt;/strong</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="List" scheme="http://example.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://example.com/2022/07/24/CAS/"/>
    <id>http://example.com/2022/07/24/CAS/</id>
    <published>2022-07-24T08:14:24.000Z</published>
    <updated>2022-07-24T08:17:27.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>比较并交换</p><p>  比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比直到主内存和工作内存中的值一致</p><p>  多个线程使用CAS操作一个变量，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试（自旋）或挂起</p><p>  <em><strong>是一条CPU并发原语，原子指令</strong></em>，不会造成数据不一致的问题</p><p>  乐观锁</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>先从地址V地区值A：2；根据A计算目标值B：3；通过CAS以原子的方式将地址V的值从A修改为B</p><p>1：调用unsafe类，分别专递主物理内存的值，原子类对象本身的值，当前对象内存地址的值，需要加上的值</p><p>2：拷贝主物理内存的值到当前线程内存</p><p>3：while循环，一直修改</p><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p>  Unsafe类：CAS的核心类，来自JVM的rt.jar下。因为java不能直接访问底层系统，需要本地（native）方法访问，基于该类可以直接操作特定内存的数据，类似于c语言的指针直接操作内存。Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务</p><p>  变量valueOffset，表示变量值在内存中的偏移地址</p><p>  变量value被volatile修饰，保证多线程之间的可见性</p><p> unsafe类：compareAndSwapObject(Object var1, long var2, Object var4, Object var5)</p><p>​第一个：要修改的对象</p><p>​第二个：对象中要修改变量的偏移量</p><p>​   第三个：修改之前的值</p><p>​   第四个：预想修改之后的值</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>循环时间开销很大：因为通常配合着循环使用，若失败则会一直尝试</p><p>只能保证一个共享变量的原子操作（多个共享变量，循环CAS就不能保证原子性，要用锁）</p><p><em><strong>引来ABA问题</strong></em></p><h2 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h2><p>线程1从内存位置V读取数据A，线程2也从地址V出读取A，线程2经过了一些操作将值别成了B，然后线程2又将V位置的数据变成A，此时，线程2进行CAS操作发现内存中仍然是A，进程1操作成功。但是整个过程中，地址V其实是已经被修改过的</p><p><em><strong>带有标记的原子引用类</strong></em>可以<em><strong>控制变量值的版本</strong></em>来保证CAS正确性。所以，解决ABA的话改用传统的互斥同步</p><p>原子类：某个线程进入方法，执行其中的指令时，不会被其他线程打断，别的线程一直等到该方法执行完成才由JVM从等待队列中选择一个另一个线程进入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;比较并交换&lt;/p&gt;
&lt;p&gt;  比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比直到主内存和工作内存中的值一致&lt;/p&gt;</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL简单优化</title>
    <link href="http://example.com/2022/07/21/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/07/21/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/</id>
    <published>2022-07-21T15:55:56.000Z</published>
    <updated>2022-07-21T15:59:42.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><p>对于所执行的SQL语句，通过“explain”查看相关信息进行调节</p><p>可以获取表的读取顺序，数据读取操作的操作类型，哪些索引可用，哪些索引实际被使用，表之间的引用，每张表有多少行被优化器查询</p><p>使用方法： EXPLCAIN + SQL语句</p><p>Id：id相同：执行顺序由上至下</p><p>​    Id不同：若是子查询，id的序号会递增，id的值越大优先级越高，越先执行</p><p>​    id不同，同时存在，可以认为从上往下顺序执行。</p><p>Select_type：</p><p>​    SIMPLE：简单的select查询，查询中不包含子查询或UNION</p><p>​    PRIMARY：若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</p><p>​    SUBQUERY：在select或where列表中包含子查询</p><p>​    DERIVEN：在from列表中包含的子查询被标记为DERIVER（衍生），mysql会递归执行这些子查询，把结果放在临时表中</p><p>​    UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在from子句的子查询中，外层select将被标记为：DERIVED</p><p>​    UNION RESULT：从UNION表获取结果的SELECT</p><p>Table：就是执行的表</p><p><em><strong>Type</strong></em>:显示查询使用了哪些类型</p><p>​    包含：ALL、index、range、ref、eq_ref、const&#x2F;system、NULL</p><p>从好到差：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</p><p>​    System:表里只有一行记录，const的特例</p><p>​    Const：通过索引，一次就找到，用于比较primary key或者union索引</p><p>​    Eq_ref：唯一索引扫描，对每个索引键，表中只有一条记录匹配。主键或唯一索引扫描</p><p>​    Ref：非唯一性索引扫描，返回某个单独值的所有行</p><p>​    Reange：值检索给定范围的行</p><p>​    Index：与all的区别是index只遍历索引树。通常比all块</p><p>​    All：将遍历全表以找到匹配的行</p><p>Possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定被查询实际使用</p><p>Key_len：表示索引中使用的字节数，通过该列计算查询中使用的索引长度</p><p>Ref：显示索引的那一列被使用了</p><p>row： 根据表统计信息及索引选用情况，大致估算出找到所需要读取的行数</p><p>Extra：包含不适合在其他列中显示但很重要的额外信息</p><h1 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h1><p>查询尽量不用select * ，而是具体字段：只取需要的，节省资源、减少开销；select * 时很可能不会用到索引，就会造成全表扫描 </p><p>​    避免在where子句中用or连接条件（用union all，或两条sql）：or可能让索引失效，而全局扫描；</p><p>​         Select * from student where id&#x3D;1 or salary&#x3D;3000</p><p>​         Select * from student where id&#x3D;1 union all select * from student where salary</p><p>​    Varchar代替char：因为是根据实际长度存储，存储空间小，节省空间；char按声明大小存储，不足补空格；在一个相对小的字段内搜索，效率更高</p><p>​    尽量使用数值代替字符串</p><p>​    查询时尽量避免返回大量数据：若返回的数据量大，就查询时间过长，网络传输时间过长。太多了也没意义，用户不好看。通常采用分页的形式</p><p>​    创建name字段的索引：提高查询速度的最简单最佳方式</p><p>​         Alter table student add index index_name(NAME)</p><p>​    优化like语句：like可能让索引失效</p><p>​    Where限定查询的数据</p><p>尽量避免全表的扫描，在where、order by等列上建立索引。在字句中尽量避免使用 !&#x3D; &gt; &lt; 等操作符，否则引擎会放弃使用索引去全表扫描了</p><p>尽量使用数字型的字段，不然会降低连接的性能，也会增加存储开销（因为引擎在处理查询和连接的时候会逐个去比较字符串中的每个字符），数字就只需要比较一次</p><h2 id="大表"><a href="#大表" class="headerlink" title="大表"></a>大表</h2><p>限定数据范围：比如将查看订单历史记录，控制在一定的时间范围</p><p>读写分离：数据库拆分，主库负责写，从库负责读</p><p>垂直分区：根据数据库里面数据表的相关性拆分。简单说，就是把一张列较多的表拆分成多个表</p><p>水平分区：将一片数据分散到不同表或者库中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Explain&quot;&gt;&lt;a href=&quot;#Explain&quot; class=&quot;headerlink&quot; title=&quot;Explain&quot;&gt;&lt;/a&gt;Explain&lt;/h1&gt;&lt;p&gt;对于所执行的SQL语句，通过“explain”查看相关信息进行调节&lt;/p&gt;
&lt;p&gt;可以获取表的读取顺</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Http1.0-3.0</title>
    <link href="http://example.com/2022/07/17/Http1-0-3-0/"/>
    <id>http://example.com/2022/07/17/Http1-0-3-0/</id>
    <published>2022-07-17T06:35:00.000Z</published>
    <updated>2022-07-17T06:38:46.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="HTTP1-0和1-1"><a href="#HTTP1-0和1-1" class="headerlink" title="HTTP1.0和1.1"></a>HTTP1.0和1.1</h4><p>HTTP&#x2F;1.0性能上，每发起一个请求都要新建一次TCP连接（三次握手），而且是串行，做了没有用TCP连接和断开</p><p>长连接：HTTP&#x2F;1.1采取的，只要任意一端没有明确的提出断开连接，则保持TCP连接状态</p><p>错误状态响应码：1.1中新增加了24个错误状态响应码</p><p>缓存处理：1.1引用了更多缓存控制策略</p><p> 1.1的性能：<em><strong>长连接、管道网络传输、队头阻塞</strong></em></p><p>管道网络传输：在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不用等其回来，就可以发第二个请求出去</p><p>队头阻塞：顺序发送的请求序列中，一个请求因为某种原因被阻塞时，后面排队的所有请求都阻塞了</p><p><img src="/http1-0-3-0/1.0-1.1.png" alt="image-20220709114337819"></p><p>HTTP1.1的瓶颈：</p><p>最大的问题就是高延迟：因为延迟难以下降；并发连接优先；队头阻塞；HTTP头部巨大且重复；不支持服务器推送消息</p><ul><li>请求&#x2F;响应头部未经压缩就发送，首部信息越多，延迟越大。只能压缩body部分</li><li>发送冗长的首部。每次都发送相同的首部浪费较多</li><li>没有请求优先级</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h5 id="HTTP1-1-优化"><a href="#HTTP1-1-优化" class="headerlink" title="HTTP1.1 优化"></a>HTTP1.1 优化</h5><p>尽量避免HTTP请求（缓存技术）</p><p>在需要发HTTP请求，减少次数（减少重定向，合并请求，延迟发送）</p><p>​收到合并请求就是合并资源，以一个大资源的请求替换多个小资源的请求；当大资源中的小资源发生变化，客户端就要重新下载整个完整的大资源</p><p>​     延迟发送：只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源</p><p>减少服务器的HTTP响应大小</p><h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h4><p>通过<em><strong>静态表和哈夫曼编码</strong></em>的方式，将体积压缩了近一半，针对后续的请求头部也可建立动态表（会占用内存而影响并发能力）</p><p>  <em><strong>实现了Stream并发，多个Stream只需复用一个TCP连接，节约了TCP和TLS握手时间，以及减少了TCP慢启动阶段对流量的影响。</strong></em></p><p>  服务器支持主动推送资源，大大提升了消息的传输信息</p><p>  HTTP&#x2F;2是基于TCP协议来传输数据，TCP层必须保证收到的字节数据是完成且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用。有队头阻塞问题，TCP和TLS的握手时延迟，网络迁移需要重新连接</p><h5 id="相比于HTTP-x2F-1-1的改进"><a href="#相比于HTTP-x2F-1-1的改进" class="headerlink" title="相比于HTTP&#x2F;1.1的改进"></a>相比于HTTP&#x2F;1.1的改进</h5><p>&#x3D;&#x3D;头部压缩&#x3D;&#x3D;：会压缩头，若头一样，会消除重复的部分</p><p>&#x3D;&#x3D;二进制格式&#x3D;&#x3D;：全面采用二进制格式并同城为帧（头信息帧，数据帧）。对计算机友好，提高传输效率</p><p><img src="/http1-0-3-0/1.0-1.1-2.png" alt="image-20220709152032970"></p><p>&#x3D;&#x3D;数据流&#x3D;&#x3D;：数据包不是按顺序发送，每个请求或回应的所有数据包称为数据流。每个数据流里面有独一无二的编号，客户端发送的编号为奇数，服务器端发送的为偶数。多个stream复用一个TCP达到并发效果</p><p>&#x3D;&#x3D;多路复用&#x3D;&#x3D;：2.0是可以在一个连接中并发多个请求或回应，而不用按顺序对应</p><p>&#x3D;&#x3D;服务器推送&#x3D;&#x3D;：服务器也可以主动向客户端发</p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>因为多个HTTP都在复用一个TCP链接，所以一旦发生丢包，都会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求就必须这个丢的包被传回来</p><h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><p>传输层的TCP换成UDP，并在UDP协议开发了QUIC协议保证了数据的可靠传输。</p><p>QUIC</p><p>  无队头阻塞</p><p>  建立连接速度块</p><p>  连接迁移</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;发展&quot;&gt;&lt;a href=&quot;#发展&quot; class=&quot;headerlink&quot; title=&quot;发展&quot;&gt;&lt;/a&gt;发展&lt;/h3&gt;&lt;h4 id=&quot;HTTP1-0和1-1&quot;&gt;&lt;a href=&quot;#HTTP1-0和1-1&quot; class=&quot;headerlink&quot; title=&quot;HTT</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://example.com/2022/07/16/IP/"/>
    <id>http://example.com/2022/07/16/IP/</id>
    <published>2022-07-15T17:45:22.000Z</published>
    <updated>2022-07-16T06:41:24.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><p>网络层，<em><strong>实现主机与主机之间的通信，点对点通信</strong></em></p><p>MAC（数据链路层）是实现 直连 两个设备之间通信，IP是在没有直连的两个网络之间进行通信传输。个人理解：计划和实施的区别。IP是整个旅游行程表，MAC是行程表里的交通工具。</p><p>&#x3D;&#x3D;源IP地址和目标IP地址不会变化，只有源MAC地址和目标MAC一直在变化&#x3D;&#x3D;</p><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><p>IP地址（IPv4地址）32位，在计算机中二进制方式处理。点分十进制的标记方式处理</p><p>分类：A,B,C,D,E类</p><p>A（0<del>127.255.255.255）,B（128</del>191.255.255.255）,C（192~223）主要两部分，网络号和主机号（比如：A小区1栋101号和B小区1栋101号）</p><p>A,B,C类中有私有IP和公有IP区分</p><p>解析IP地址，看第一个0出现在哪一位。在第一位是A类，第二为是B类，依次类推</p><p>广播地址</p><p>用于在同一个链路中互相连接的主机之间发送的数据包</p><p>​    分为：本地广播（本网络内广播）和直接广播（不同网络间的广播）</p><p>D类和E类地址没有主机号，不可用于主机IP。</p><p>D类常用于多播，E类是预留的分类，暂未使用</p><p>多播地址</p><p>​    用于将包发送给特定组内的所有主机</p><h3 id="IPV4分类的优缺点"><a href="#IPV4分类的优缺点" class="headerlink" title="IPV4分类的优缺点"></a>IPV4分类的优缺点</h3><p>优点：简单明了、选路（基于网络地址）简单</p><p>缺点：同一网络下没有地址层次，就缺少地址的灵活性；不能很好与现实网路匹配</p><p>两个缺点都可在CIDR无分类地址解决：前面是网络号，后面是主机号</p><p>​    以a.b.c.d&#x2F;x形式表示，比如10.100.122.2&#x2F;24: &#x2F;24表示前24位是网络号，剩余是主机号。</p><h2 id="问点"><a href="#问点" class="headerlink" title="问点"></a>问点</h2><p>为什么要分离网络号和主机号：两台计算机要通讯，首先判断是否处于同一个广播域内，即网络地址是否相同。若相同，表名接收方在本网络上，数据包就可以发送到目标主机</p><p>怎么划分子网：子网掩码的作用之一就是划分子网，将主机地址分为 子网网络地址和子网主机地址</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>是128位，与v4比，可分配的地址变多；可自动装配；包头包首部长度固定的40字节，去掉包头检验和，简化了首部结构，减轻了路由器符合，提高传输的性能；可伪造IP地址的网络安全，防止窃听，提升了安全性</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>单播地址：一对一通信；</p><p>组播地址：一对多通信；</p><p>任播地址：通信最近的节点，最近的节点由路由协议决定</p><p>没有广播地址</p><h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS：可将域名网址自动转换成具体的IP地址。越靠右，层级越高</p><p>层级关系：根DNS服务器，顶级域DNS服务器，权威DNS服务器</p><p>解析流程：</p><p>客户端发送DNS请求，并发给本地DNS解析器；本地域名解析器收到请求后，若缓存中能找到就直接返回IP地址，反之本地DNS会去问它的根域名服务器；根DNS收到请求后，发现后置是.com，就给本地DNS关于顶级域名服务器的地址；本地DNS收到后再发请求给顶级域名服务器，顶级域名服务器就返回权威域名服务器的地址；本地收到后，发送权威域名服务器请求，权威域名查询后将IP地址告诉给本地DNS。本地DNS将得到的IP地址返回给客户端，客户端建立连接</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在传输IP数据包的时候，确定了源IP和目标IP后，就通过路由表确定IP数据包下一跳、因为网络层下面是数据链路层，所以要知道下一跳的MAC地址。</p><p>因为主机路由表可找到下一跳的IP地址，所以可通过ARP协议，求下一跳MAC地址</p><p>即已知IP地址求MAC地址</p><p>ARP就是借助ARP请求域ARP响应两种类型确定MAC地址</p><p>主机通过广播发送ARP请求（里面有想知道的MAC地址的主机IP地址）；同个链路中所有设备收到ARP请求时，会自动拆开ARP里的内容，若里面的IP地址与自己的一致就将自己MAC地址放入ARP响应包返回给主机</p><p>操作系统会把第一次获取的MAC地址缓存起来（有期限）。</p><p>RARP：已知MAC地址求IP地址。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态获取IP地址，省去了配IP信息繁琐过程</p><p>步骤：</p><p>​    客户端发起DHCP发现报文的IP数据报（用的UDP广播通信，因IP地址、DHCP服务器地址都不知道），并用0.0.0.0作为源IP地址，255.255.255.255为广播目的地址。DHCP客户端将该IP数据包传给MAC，MAC再将帧广播到所有网络设备中</p><p>​    DHCP服务器收到DHCP报文时向客户端响应，里面包含IP地址、子网掩码等信息。客户端收到一个或多个服务器的DHCP提供报文后，选择一个服务器，并对其发送DHCP请求报文进行响应，回显配置的参数。服务端用DHCP ACK报文进行响应，回应其要求的参数</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>网络地址转换NAT，缓解IPV4地址耗尽的问题</p><p>简单说就是在主机对外通信时，把私有IP地址转换成公有IP地址</p><p>缺点：外部无法主动与NAT内部服务器建立连接，因NAPT转换表没有转换记录；转换表的生成与转换操作会产生性能开销；通信过程中，若NAT路由器重启了，所有TCP链接将重置</p><p>解决：改用IPV6；NAT穿透技术</p><h3 id="ICMP（互联网控制报文协议）"><a href="#ICMP（互联网控制报文协议）" class="headerlink" title="ICMP（互联网控制报文协议）"></a>ICMP（互联网控制报文协议）</h3><p>主要功能：确认IP包是否到达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置</p><p>分类</p><p>​    查询报文类型：诊断查询信息</p><p>​    差错报文类型：通知出错原因的错误信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h1&gt;&lt;p&gt;网络层，&lt;em&gt;&lt;strong&gt;实现主机与主机之间的通信，点对点通信&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;MAC（数据</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="IP" scheme="http://example.com/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>四次挥手</title>
    <link href="http://example.com/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://example.com/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2022-07-14T15:54:24.000Z</published>
    <updated>2022-07-14T15:57:43.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；</p><p>当服务器端收到FIN后，发送ACK应答报文，服务端就进入close_wait状态，</p><p>客户端收到ACK应答报文后，进入FIN_WAIT_2状态</p><p>服务端做最后的数据处理（读到结束符EOF）已发送完成，则向客户端发FIN报文，服务端就进入LAST_ACK状态 ；</p><p>客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传），就进入TIME_WAIT状态；</p><p>服务器端收到ACK就关闭（CLOASE状态），客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/guocheng.png"></p><h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><p>关闭连接时，客户端向服务端发送FIN后，表示客户端不再发数据，但是能接收数据</p><p>服务端收到FIN后，先回ACK应答，但可能还有数据处理和发送不能立马关闭socket，等不再发数据后，才发FIN表示同意现在关闭连接。</p><p>所以，服务端需要等待完成数据的发送和处理，ACK和FIN一般都会分开发送，所以多一次</p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么TIME_WAIT等待时间是2MSL：是报文最大生存时间，超过这个时间报文将被丢弃。因为TCP报文基于IP协议的，IP头部中有一个TTL字段，是IP数据报可以经过最大路由数，<em><strong>MSL要  &amp;ge; TTL消耗为0的时间</strong></em>。2MSL是从<em><strong>客户端收到FIN后发送ACK开始计时的</strong></em>，若客户端的ACK没有传到服务端，客户端就又会收到来自服务端的FIN报文，那么2MSL将重新计时</p><p>为什么需要TIME_WAIT：主动发起关闭连接的一方才会有TIME-WAIT状态。需要TIME-WAIT状态，是<em><strong>防止接收到具有相同的四元组出现的旧数据包</strong></em>，2MSL足以上两个方向上数据包都被丢掉，保证出现的数据包一定是建立连接时所产生的；保证连接能正确关闭：给出足够的时间确保最后的ACK能让被动关闭方接收</p><p>TIME_WAIT过多的危害：内存资源占用；端口资源的占用，一个TCP连接至少消耗一个本地端口，若沾满了所有端口，就不能创建新链接</p><p>若已建立了链接，但客户端突然故障：</p><p>​TCP的&#x3D;&#x3D;保活机制&#x3D;&#x3D;：定义一个时间段，该时间段内，若没有任何连接相关的活动，TCP保活机制就会开始作用，每隔一个时间段就发探测报文（数据很少），若连续几个探测报文没有回应，则认为当前TCP连接已死亡，系统内核就将错误信息通知给上层应用</p><p>​对端程序工作正常：TCP保活的探测报文，对端会正常响应，TCP保活时间会被重置</p><p>​对端程序崩溃并重启：发探测报文，对端可响应，但是没有该连接的有效信息，会产生一个RST报文，就很块发现TCP连接已被重置</p><p>​对端程序崩溃或其他原因让报文能不到达：探测报文不能得到响应，TCP会报告该TCP连接已死亡</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>四次挥手优化</p><p>​    主动方优化：发FIN报文的方式有close和shutdown，所以发送更改方式。调整FIN重传次数。调整状态时间和孤儿连接的上限个数。</p><p>   被动方优化：复用time_wait状态的连接（只使用于客户端）</p><p>Close：断开后，不能传输数据也不能发数据。</p><p>Shutdown：控制只关闭一个方向的连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要流程&quot;&gt;&lt;a href=&quot;#主要流程&quot; class=&quot;headerlink&quot; title=&quot;主要流程&quot;&gt;&lt;/a&gt;主要流程&lt;/h1&gt;&lt;p&gt;客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP怎么保证可靠传输</title>
    <link href="http://example.com/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <id>http://example.com/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</id>
    <published>2022-07-13T12:17:56.000Z</published>
    <updated>2022-07-13T12:30:36.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="普通处理"><a href="#普通处理" class="headerlink" title="普通处理"></a>普通处理</h1><p>应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传送</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；</p><p>TCP会在<strong>数据包丢失和确认应答丢失后发生超时重传</strong></p><p>设置的时间RTO：RTO太大，重发慢，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时。所以，设置的RTO应该略大于报文忘返RTT的值</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>以<em><strong>数据驱动重传</strong></em>。收到三个相同ACK报文时，会在定时器过期之前，重传文段。</p><p>只解决了超时时间的问题，有另一个问题：重传的时候，是重传一个，还是重传之前的所有，所以就有了SACK方法</p><h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p>在TCP头部的“选项”字段中添加一个SACK，<em><strong>将缓存的地图发送给发送方</strong></em>，发送方就知道哪些数据收到了，哪些没有，就可以<em><strong>只传丢失的数据</strong></em>、</p><h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p>使用了SACK告诉 发送方，有哪些数据被重复接收了。</p><p>可以让发送方知道，是发出去的包丢了；可以知道是不是发送方的数据包被网略延时了；可以知道网络中是不是把发送方的数据包给复制了</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>TCP是每发一个数据，收到回应后再发下一个，数据包忘返时间长，通信效率低。</p><p>发送方会定时发送窗口大小探测报文，及时知道接收方窗口大小辩护</p><p>窗口大小就是指<em><strong>无需等待确认应答，可以继续发送数据的最大值</strong></em></p><p>大小在TCP头部，该字段是接收端告诉发送端自己有多少缓冲区可接收数据，发送端根据这个发送数据</p><p>接收窗口和发送窗口大小不完全相等：接收窗口大小约等于发送窗口大小。因为滑动窗口大小不是一成不变，若接收方的程序读取数据很快，接收的滑动窗口就会空出来。那么新的接收窗口大小，是通过TCP头部的窗口大小字段告诉发送方，传输存在时延，所以两者是约等于的关系</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率，根据接收方的实际接收能力变化</p><p>窗口关闭：窗口大小为0，就会阻止发送方传递数据，直到窗口非0。当窗口关闭时，接收方处理完数据后会发送一个窗口非0的ACK报文，若该报文丢失，那会出现问题</p><p>​解决窗口关闭时潜在的死锁现象：TCP为每一个连接设置定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器。该计时器若超时，就发送窗口探测报文，对方在确认该探测报文时会给出自己的窗口大小</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>目的是<em><strong>避免发送方的数据填满整个网络</strong></em></p><p>拥塞窗口是发送方维护的一个状态变量，根据网络的拥塞程度动画变化。</p><p>发送了超时重传，就认为网络出现拥塞</p><h2 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h2><p>慢启动：当发送方每收到一个ACK，拥塞窗口CWND的大小就加1。当没启动到ssthresh就使用拥塞避免算法</p><p>拥塞避免：每收到一个ACK时，CWND增加1&#x2F;CWND</p><p>拥塞发生：就出现数据包重传</p><p>​超时重传：ssthresh设为CWND&#x2F;2，CWND重置为1</p><p>​快速重传：CWND为原来的一半，ssthresh&#x3D;CWND，进入快速恢复算法</p><p>快速恢复：拥塞窗口CWND&#x3D;ssthresh+1；重传丢失的数据包；若重复收到ACK，CWND+1；收到新的ACK后，CWND就设置为第一步中的ssthresh的值，恢复到之前的状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;普通处理&quot;&gt;&lt;a href=&quot;#普通处理&quot; class=&quot;headerlink&quot; title=&quot;普通处理&quot;&gt;&lt;/a&gt;普通处理&lt;/h1&gt;&lt;p&gt;应用数据都被分割成TCP认为最适合发送的数据包&lt;/p&gt;
&lt;p&gt;  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
