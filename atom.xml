<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小二小二不停步</title>
  
  <subtitle>学生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-05T02:53:42.742Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小二小二不停步</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis内存淘汰</title>
    <link href="http://example.com/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
    <id>http://example.com/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</id>
    <published>2022-05-05T02:52:26.015Z</published>
    <updated>2022-05-05T02:53:42.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内存淘汰： 当内存的使用率到达了maxMemory的上限的时候，进行内存的释放。</p><p>redis提供了许多内存淘汰算法，主要分为4种：</p><p>​随机：随机移除某个key</p><p>​TTL算法：，在设置了过期时间的键里面去找更早过期时间的key进行有限的移除</p><p>​LRU算法：去移除最近很少使用的key。</p><p>​LFU算法：与LRU算法类似                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h1 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h1><p>​LRU算法会维护一个大小为16的侯选池，里面的数据会随着时间排序，每一次随机抽取5个key放入侯选池，当侯选池满了后，访问的时间间隔最大的key就从侯选池里面取出来并淘汰。这样就可以把真实的最少访问的key从内存里面淘汰。</p><p>​存在问题：若一个key很长时间没有访问，突然偶尔被访问，那LRU就会认为这是一个热点key就不会被淘汰。</p><h1 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h1><p>​相比于LRU算法，LFU增加了访问频率来统计数据的热点情况。</p><p>​主要设置是使用了两个双向链表形成了一个二维的双向链表，一个链表来保存访问频率，另一个保存访问频率相同的所有元素。当添加元素的时候，访问频次默认为1，找到相同频次的节点，然后添加到相同的频率节点对应的双向链表的头部，当元素被访问的时候，就增加对应key的访问频率，并把当前访问的节点移动到下一个频次的节点。</p><p>​可能出现某个数据前期的访问次数很多，但后续不再使用。若单纯按照这样的一个访问频次来进行淘汰的话，那这个key就很难被淘汰掉。该算法通过使用频率和上次访问的时间来标记数据的热度。若某个数据有读和写，那增加访问的频率；若一段时间内该数据没有读写，那就减少访问频率。</p><p>​经过LFU算法改进后就可以实现真正达到非热点数据的淘汰</p><p>​缺点：与LRU相比，增加了访问频次的维护以及实现的复杂度要比LRU更高</p><h1 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h1><p>定时策略：创建一个定时器，过期时间到，逻辑对键的删除</p><p>​对内存友好而CPU时间不好，redis还没有使用</p><p>惰性删除：过期键不管，每次从键空间获取键的时候，该键过期了删了，没过期就返回该键</p><p>​对内存不友好而CPU时间友好</p><p>定期删除：每隔一段时间就检查，删除过期键，由算法决定</p><p>​较为折中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;内存淘汰： 当内存的使用率到达了maxMemory的上限的时候，进行内存的释放。&lt;/p&gt;
&lt;p&gt;redis提供了许多内存淘汰算法，主要分为4</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis和数据库的数据一致性</title>
    <link href="http://example.com/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%8F%8Aredis%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%8F%8Aredis%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2022-05-03T17:15:38.054Z</published>
    <updated>2022-05-06T03:37:33.914Z</updated>
    
    <content type="html"><![CDATA[<p>redis用来实现应用和数据库之间读操作的缓存层，主要目的是去减少数据库的IO，并提升数据库的IO性能。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>当应用程序需要读取某个数据的时候，首先会尝试去redis里面加载，若命中就直接返回，反之就去数据库里面查询，查询到数据后再把数据缓存到redis里面。</p><h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>即一份数据同时保存在redis和数据库里面，当数据发生变化的时候需要同时更新数据库和redis，由于更新操作具有先后顺序且redis不像数据库中的多表事务操作（满足ACID的特性），所以会出现数据一致性的问题</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h2><p>此情况下，若缓存更新失败，就会导致数据库和redis的数据不一样。</p><p>线程1连接到数据库，读取到了数据A，此时线程1停顿，线程2连接到数据库将数据A更改为数据B，并将B写入了redis完成了线程2的操作，然后线程1将读取到的数据A写入redis即把B覆盖。此时，数据库里面的数据为B，而redis里的数据为A</p><h2 id="先删除缓存后更新数据库"><a href="#先删除缓存后更新数据库" class="headerlink" title="先删除缓存后更新数据库"></a>先删除缓存后更新数据库</h2><p>理想情况下是应用下次访问redis的时候，发现redis里面是空值，就会从数据库里加载并保存至数据库，理论上可行。但在极端情况下，由于删除redis和更新数据库的两个操作均不是原子操作，所以还是会出现数据不一致</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>基于RocketMQ的可靠性消息通信实现数据的最终一致性</p><p>通过Canal组件监控数据库里面的binlog的日志，把更新后的数据同步到redis里面</p><p>采用延时双删的原则：先淘汰缓存，再写数据库，休眠一会儿后再淘汰缓存。因为存在了延时时间，目的就是为了先把查到的数据写入redis再删redis</p><h1 id="redis的线程安全问题"><a href="#redis的线程安全问题" class="headerlink" title="redis的线程安全问题"></a>redis的线程安全问题</h1><h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h2><p>是一个线程安全的K-V数据库，即在redis-server端去执行指令的时候不要任何的同步机制，不存在任何线程安全的问题，虽然6.0之后增加了多线程的模型，但该模型只是去处理网络的IO事件，对于指令的执行还是采用主线程来处理的，所以并不会存在多个线程同时去执行操作指令的情况。</p><p>没有采用多线程执行指令：</p><p>​本身可能出现的性能瓶颈点无非是网络IO、CPU、内存，但是CPU不是redis的瓶颈，所以就没必要采用多线程执行指令</p><p>​若采用多线程，那么所有指令就必须要考虑线程安全的问题，也就需要加锁来解决，这种方式反而会对性能造成更大的影响</p><h2 id="redis-client"><a href="#redis-client" class="headerlink" title="redis-client"></a>redis-client</h2><p>里面的指令操作都是原子性，但若有多个redis客户端同时执行多个指令就无法保证原子性。</p><p>比如：两个client同时去获取server上的key1，同时去修改和写入，因为多线程下原子性不能保证以及多进程的情况下共享资源访问的竞争问题也不能保证数据安全性</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>尽可能使用redis里面的原子指令</p><p>对个客户端的资源访问加锁</p><p>通过lua脚本实现多个指令的操作，去满足原子性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;redis用来实现应用和数据库之间读操作的缓存层，主要目的是去减少数据库的IO，并提升数据库的IO性能。&lt;/p&gt;
&lt;h1 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h1&gt;&lt;p&gt;当应</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis理解和分布式锁</title>
    <link href="http://example.com/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-05-03T04:15:52.889Z</published>
    <updated>2022-05-03T04:15:53.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对redis的理解"><a href="#对redis的理解" class="headerlink" title="对redis的理解"></a>对redis的理解</h1><p>redis是一个高性能的基于Key-Value结构存储的NoSQL开源数据库，绝大部分都采用redis实现分布式缓存，从而去提高数据的的检索效率。</p><p>redis流行的原因：</p><p>​1 基于内存存储，在进行数据IO操作的时候能达到很高的QPS（官方给的10w）</p><p>​2 提供了非常丰富的数据存储结构，比如String、list、hash、set、zset</p><p>​3 底层采用单线程实现数据的IO，所以在数据算法层面不需要考虑并发安全性，从而让底层算法的时间复杂度基本都是常量复杂度</p><p>​4 虽然是内存存储，但却可以支持持久化，避免因服务器故障而导致的数据丢失问题</p><p>综上，redis一般是用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响，redis还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供了解决方案</p><h1 id="实现分布式锁中-zookeeper和redis的比较"><a href="#实现分布式锁中-zookeeper和redis的比较" class="headerlink" title="实现分布式锁中 zookeeper和redis的比较"></a>实现分布式锁中 zookeeper和redis的比较</h1><p>分布式锁：核心目的是为了解决在同一个时刻有多个进程或线程来访问共享资源所带来的安全性问题。锁又分为共享锁（在同一个时刻允许多个线程或进程访问共享资源，适用于幂等性场景，从而避免重复加锁的性能开销）和排它锁（同一个时刻只允许一个线程或进程访问该共享资源，适用于非幂等性场景）</p><p>实现分布式锁的最常用中间件就是zookeeper和redis</p><p>redis实现分布式锁方式：</p><p>​1 基于redis本身提供的指令：SET key value NX PX millisecounds。设置key的时候，若key已经存在与服务器上了会返回一个0，表示无法设置，否则就返回1表示设置成功。程序就根据0和1判断状态，从而表示去获得锁</p><p>​2 基于redission客户端实现，redission提供了分布式锁的封装方法，只需要调用封装好的api，<em><strong>lock()</strong></em> 和 ***unlock()***方法，就可以实现锁的抢占和释放。redission的所有指令都是通过lua脚本去实现，该脚本可以保证所有执行指令的原则性。另外，redission提供了一个watchdog，它会在我们获取锁后每隔10s去把key的时间延长，就避免锁的过期。</p><p>redis的缺点：</p><p>​在获得锁的时候，很简单，若获取不到锁就一直去尝试获取，会影响程序性能</p><p>​是一个&#x3D;&#x3D;AP模型&#x3D;&#x3D;，也就是可用性模型，集群模式中，存在数据一致性，会导致锁出现问题。即使使用了redlock算法实现分布式锁，但在某些复杂的场景下也不能保证锁的一定可用</p><p>zookeeper实现分布式锁：</p><p>​1 有序节点实现：每个线程或进程都到zookeeper上的<em><strong>lock</strong></em>目录下去创建一个临时有序节点，去表示抢占锁，所有创建的节点都会按照先后顺序生成带有有序编号的节点，线程创建节点后获取<em><strong>lock</strong></em>节点下的所有子节点，判断当前线程创建的节点是否是所有子节点里序号最小的，若是就获取锁成功。反之就需要对当前线程的前一个节点建立事件监听，当被监听的节点释放后，则触发回调告诉当前线程从而再次去尝试抢占锁</p><p> 使用redis还是比较常见，因为实际开发中极端情况少，redis本身的性能又高，在高并发中比较合适。</p><p>zookeeper是一个分布的协调组件，是&#x3D;&#x3D;一个CP模型&#x3D;&#x3D;所以更适合实现分布式锁。当获取不到锁就添加监听器，不用一直获取，就减少了性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对redis的理解&quot;&gt;&lt;a href=&quot;#对redis的理解&quot; class=&quot;headerlink&quot; title=&quot;对redis的理解&quot;&gt;&lt;/a&gt;对redis的理解&lt;/h1&gt;&lt;p&gt;redis是一个高性能的基于Key-Value结构存储的NoSQL开源数据库，绝大部</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java不可变类</title>
    <link href="http://example.com/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/"/>
    <id>http://example.com/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/</id>
    <published>2022-05-02T07:06:02.159Z</published>
    <updated>2022-05-02T12:20:44.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p><strong>不可变类</strong>：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p><p><strong>可变类</strong>：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><h1 id="不可变类优点"><a href="#不可变类优点" class="headerlink" title="不可变类优点"></a>不可变类优点</h1><p>主要有两点，效率和安全</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>当一个对象是不可变的，那么需要拷贝这个对象的内容时，就不用复制它的本身而只是复制它的地址，复制地址（通常一个指针的大小）只需要很小的内存空间，具有非常高的效率。同时，对于引用该对象的其他变量也不会造成影响。而且保证了hashCode 的唯一性，因此可以放心地进行缓存而不必每次重新计算新的哈希码。而哈希码被频繁地使用, 比如在hashMap 等容器中。将hashCode 缓存可以提高以不变类实例为key的容器的性能。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>是指线程安全</p><p>在多线程情况下，一个可变对象的值很可能被其他进程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况同时省去了同步加锁等过程，因此不可变类是线程安全的。</p><p>当然，不可变类也有缺点：不可变类的&#x3D;&#x3D;每一次“改变”都会产生新的对象，因此在使用中不可避免的会产生很多垃圾&#x3D;&#x3D;</p><h1 id="不可变类的设计"><a href="#不可变类的设计" class="headerlink" title="不可变类的设计"></a>不可变类的设计</h1><p>类使用final修饰，保证类不被继承</p><p>所有成员变量都被private和final修饰</p><p>不提供成员变量的setter方法</p><p>通过构造器初始化所有成员，进行深拷贝</p><p>在getter方法中，不直接返回对象本身，而是克隆对象并返回对象的拷贝内容</p><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>String源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="type">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="type">char</span> result[] = <span class="keyword">new</span> <span class="title class_">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可观察到</p><p>​String类被final修饰，就不能被继承</p><p>​内部变量所有成员都设置为私有变量</p><p>​没有setter方法</p><p>​&#x3D;&#x3D;传入可变数组时，进行copy而不是直接将数组赋值给内部变量&#x3D;&#x3D;</p><p>​获取value时不是直接返回对象引用，而是返回对象的copy</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​String不能被修改，让JVM可实现字符串常量池，该常量池可在运行时节约内存空间，不同字符串指向相同自变量时都指向字符串常量池中的同一对象，&#x3D;&#x3D;即提升了性能，节约了资源&#x3D;&#x3D;，更因为不可变性保证了线程安全</p><h2 id="String是否真的不可变"><a href="#String是否真的不可变" class="headerlink" title="String是否真的不可变"></a>String是否真的不可变</h2><p>虽然String对象将value设置为final,并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">char</span>[] valueCharArr = (<span class="type">char</span>[]) valueField.get(str);</span><br><span class="line">            valueCharArr[<span class="number">0</span>] = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">            valueField.set(str, <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = ABCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = GBCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = 12</span><br><span class="line">hashCode = 2001986</span><br></pre></td></tr></table></figure><p>由打印结果可知，字符串str的值发生了改变，哈希值没有发生变化。即通过反射可以修改“不可变”对象</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不可变类是实例创建后就不可以改变成员遍历的值。这种特性使得不可变类提供了线程安全的特性但同时也带来了对象创建的开销，每更改一个属性都是重新创建一个新的对象。JDK内部也提供了很多不可变类如Integer、Double、String等。</p><p>String的不可变特性主要为了满足&#x3D;&#x3D;常量池的使用&#x3D;&#x3D;、&#x3D;&#x3D;线程安全&#x3D;&#x3D;、&#x3D;&#x3D;类加载&#x3D;&#x3D;、&#x3D;&#x3D;提高运行速度&#x3D;&#x3D;、&#x3D;&#x3D;避免网络问题&#x3D;&#x3D;。合理使用不可变类可以带来极大的好处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;不可变类&quot;&gt;&lt;a href=&quot;#不可变类&quot; class=&quot;headerlink&quot; title=&quot;不可变类&quot;&gt;&lt;/a&gt;不可变类&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;不可变类&lt;/strong&gt;：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内</summary>
      
    
    
    
    
  </entry>
  
</feed>
