<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小二小二不停步</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-16T17:44:30.951Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小二小二不停步</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis核心类</title>
    <link href="http://example.com/2022/08/17/Mybatis%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
    <id>http://example.com/2022/08/17/Mybatis%E6%A0%B8%E5%BF%83%E7%B1%BB/</id>
    <published>2022-08-16T17:38:46.000Z</published>
    <updated>2022-08-16T17:44:30.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h1><p>是利用XML或Java编码编码获得资源来构建SqlSessionFactory（可以构建多个），一旦构建完，作用就没了，就可以回收。它的生命周期只存在与方法的局部，<em><strong>作用就是生产SqlSessionFactory</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;</span><br><span class="line">    <span class="comment">//各种构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSessionFactoryBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, (String)<span class="literal">null</span>, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, environment, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, (String)<span class="literal">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得XMLConfigBuilder，new出一个成员变量configuration</span></span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">            var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, (String)<span class="literal">null</span>, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, environment, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, (String)<span class="literal">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">            var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h1><p>每个基于MyBatis的应用都是一个SqlSessionFactory的实例为中心的，该实例通过SqlSessionFactoryBuilder获得。而Builder可以从XML配置文件或通过java的方式构建SqlSessionFactory实例。</p><p><em><strong>作用就是去创建SqlSession</strong></em>。每次应用需要访问数据库，就要通过SqlSessionFactory创建SqlSession。若多次创建同一个数据库的SqlSessionFactory，则每次创建的都会打开更多数据库连接资源，所以连接资源会被消耗。所以<em><strong>SqlSessionFactory是唯一的</strong></em>，于是采用单例模式，若采用多例就对数据库连接消耗大且不利于管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSessionFactory</span> &#123;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">()</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(Connection var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, <span class="type">boolean</span> var2)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, TransactionIsolationLevel var2)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, Connection var2)</span>;</span><br><span class="line">    Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个工厂，创建SqlSession对象，SqlSession是MyBatis面向数据库的高级接口，提供了执行查询sql、更新sql等</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>首先需要提供配置文件和相关的参数。采用<em><strong>构造模式</strong></em>去创建SqlSessionFactory，通过SqlSessionFactoryBuilder构建</p><p>分两步：</p><p>​解析XML文件，读出配置参数，将读取的数据存入Configuration（MyBatis基本所有的配置都是在这）</p><p>​使用Configurattion对象去创建SqlSessionFactory。因SqlSessionFactory本身是一个接口，一般情况使用其实现类之中的DefaultSqlSessionFactory。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>作用：读入配置文件，包括基础配置XML文件和映射器XML文件；初始化基础配置（别名啊、类的对象啊）；提供单例，为后续创建SessionFactory服务并提供配置的参数；执行一些重要的对象的方法，初始化配置信息；</p><p>configuration做的初始化信息：全局参数、设置、别名、插件、类型处理器等等</p><h1 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h1><p>MyBatis的顶层API接口，作为会话访问，完成CRUD，有两个实现类，通过内部存放的执行器来对数据进行CRUD操作，<em><strong>非线程安全</strong></em>，所以每次都要close关闭。</p><p>一个会话，相当于JDBC的一个Connection对象，长期的存在会让数据库连接池的活动资源减少</p><h2 id="四大对象"><a href="#四大对象" class="headerlink" title="四大对象"></a>四大对象</h2><p>映射器就是一个动态代理对象，进入到MapperMethod的executte方法。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>真正执行Java和数据库交互的东西。</p><p>有三种：</p><p>​SIMPLE：简易执行器，默认的</p><p>​REUSE：执行器重用预处理语句</p><p>​BATCH：执行器重用语句和批量更新，针对批量专用的执行器</p><p>三种都提供了查询和更新方法，以及相关的事务方法</p><h3 id="数据库会话器"><a href="#数据库会话器" class="headerlink" title="数据库会话器"></a>数据库会话器</h3><p>专门处理数据库会话的。</p><p>定义了一个对象的适配器delegate，根据配置来适配对应的StatementHandler对象。作用就是给实现类对象的使用提供一个同一、简易的使用适配器。可以使用现有的类和方法对外提供服务、可以根据实际的需求对外屏蔽一些方法甚至加入新服务。</p><h3 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h3><p>参数处理器对预编译语句进行参数设置</p><h3 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h3><p>组装结果集的返回。</p><p>MyBatis提供了DefaultResultSetHandler类，默认状况都是这个类进行处理</p><h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>SqlSession是通过Executor创建StatementHandler运行，statement需要经过：</p><ul><li>prepared预编译SQL</li><li>parameterize设置参数：调用paremeterHandler方法设置，参数类型根据类型处理器typeHandler处理</li><li>query&#x2F;update执行SQL：通过resultHandler进行处理结果的封装，若是update就返回整数，反之通过typeHandler处理结果类型，再用ObjectFactory提供的规则组装对象，返回调用者</li></ul><h1 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h1><p>一个接口，没有任何实现类，作用就是发送SQL，在一个SqlSession事务方法之内，是一个方法级别的东西。如果JDBC的一条SQL语句执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SqlSessionFactoryBuilder&quot;&gt;&lt;a href=&quot;#SqlSessionFactoryBuilder&quot; class=&quot;headerlink&quot; title=&quot;SqlSessionFactoryBuilder&quot;&gt;&lt;/a&gt;SqlSessionFact</summary>
      
    
    
    
    <category term="Mybatis" scheme="http://example.com/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="http://example.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://example.com/2022/08/13/MAC/"/>
    <id>http://example.com/2022/08/13/MAC/</id>
    <published>2022-08-12T20:15:17.000Z</published>
    <updated>2022-08-12T20:24:46.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>MAC（数据链路层）是实现 直连 两个设备之间通信</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>该层是负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报</p><p>该层是在物理层提供服务的基础上向网络层提供服务，最基本的就是将原子网络层的数据可靠的传输到相邻节点的目标机网络层。作用是<em><strong>加强物理层传输原始比特流的功能</strong></em>，将物理层提供的可能出错的物理连续改造为***逻辑上无差错的数据</p><p>使用的信道有两种：点对点信道和广播信道</p><h1 id="三大特定"><a href="#三大特定" class="headerlink" title="三大特定"></a>三大特定</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>帧：链路层的协议数据单元，封装网络层数据报。<em><strong>只有数据链路层才能识别帧，物理层只是传输比特流</strong></em></p><p>因为物理层只是负责传输，无法控制和判断是否出错，且在传输过程中容易受到环境干扰，进行产生错误。于是数据链路层需要负责<em><strong>差错检测</strong></em>的工作</p><h3 id="帧的结构"><a href="#帧的结构" class="headerlink" title="帧的结构"></a>帧的结构</h3><p>网络层将IP数据报传送到数据链路层作为帧的数据部分，数据链表路层分别在前后增加了一个标记（SOH和EOT），作为数据开始和结束。帧在物理层就是一串01比特流。<em><strong>帧首部和尾部是特定的控制字符</strong></em></p><p>​||帧首部||帧数据部分||帧尾部||</p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>无论什么样的比特组合的数据能通过数据链路层。数据看不见链路层有什么阻碍数据传输的东西，所以对这些数据来说就是透明的。</p><p>解决：发送端的数据链路层在数据中出现控制字符（EOT或SOH）的前面插入一个转义字符（ESC）。字节填充或字符填充</p><p>方法有比特填充法和字符填充</p><p>&#x3D;&#x3D;帧采用零比特填充&#x3D;&#x3D;：发送端发现有连续的5个1，就填入1个0；接收端发现有5个连续的1就删除其后的0。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>在传输过程中可能出现比特差错：1和0可能变化。为了保证数据传输的可靠性，在计网传输数据时，必须采用各种差错检测措施。</p><p>奇偶校验码和循环冗余检验码CRC。</p><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><img src="/2022/08/13/MAC/data.png"></p><p>根据IP地址寻找MAC地址</p><p>源MAC地址就是发送数据的计算机的MAC地址，很轻易获取</p><h2 id="公理"><a href="#公理" class="headerlink" title="公理"></a>公理</h2><p>每一个计算机或路由器都有一个<em><strong>ARP高速缓存表</strong></em>，也就是IP地址与MAC地址的映射表</p><p>ARP高速缓存表中只会存储<em><strong>当前局域网</strong></em>内的设备信息，包括不限于连接此局域网接口所对应的<em><strong>IP与MAC映射信息</strong></em></p><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p>首先计算机判断目的IP地址是否是同网段的IP</p><h3 id="源主机和目标主机在同一局域网"><a href="#源主机和目标主机在同一局域网" class="headerlink" title="源主机和目标主机在同一局域网"></a>源主机和目标主机在同一局域网</h3><p>计算机在ARP地址表中查询目的IP地址</p><p>若ARP地址表能查到，就会获取IP地址对应的MAC地址，将信息发送到这个MAC地址对应的计算机中。</p><p>若ARP地址表查不到，就以<em><strong>单播</strong></em>的方式，将自己的IP地址和MAC地址根据请求中的源IP地址响应给计算机；计算机将接收到到IP地址和MAC地址添加到自己的ARP地址表中，再根据MAC地址将数据发送给对方</p><h4 id="源主机和目标主机在不同局域网"><a href="#源主机和目标主机在不同局域网" class="headerlink" title="源主机和目标主机在不同局域网"></a>源主机和目标主机在不同局域网</h4><p>计算机通过路由器与局域网的连接口，先将数据发送给路由器（路由器的每个接口都有对应的IP地址和MAC地址），路由器通过算法选择最优路线将信息发给<em><strong>目标主机所在局域网的路由器上</strong></em></p><p>目标主机的路由器收到信息后，先检查自己的ARP地址表：若有目标IP地址，就直接发；若没有，在局域网内&#x3D;&#x3D;广播&#x3D;&#x3D;，目标主机收到广播后会返回自己的IP和MAC地址，路由器将收到IP地址和MAC地址并存储到自己的ARP地址表中，然后发主机过去</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2022/08/13/MAC/liucheng.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;p&gt;MAC（数据链路层）是实现 直连 两个设备之间通信&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; cl</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构</title>
    <link href="http://example.com/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-08-10T17:30:38.000Z</published>
    <updated>2022-08-10T17:36:33.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>最基本的，动态可修改字符串，二进制安全，存数字时底层是int编码；长字符串（长度&gt;39字节）raw编码；短字符串（长度&lt;39字节）embstr编码。长度不能超过512MB。整体类似于ArrayList</p><p>​存储double类型的浮点数是先转换为字符串再存储。raw和embstr编码效果相同，不同于内存分配释放，raw一次，embstr两次；embstr内存快连续，能更好的利用缓存带来的优势；</p><p>利用key的生命周期做投票系统；String特点数据刷新；利用数值操作特征为分布式数据库自增。访问次数、点赞、转发量；计数器、限流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line">struct sdshdr&#123;</span><br><span class="line">    <span class="comment">//记录SDS所保存的字符串长度</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组未使用的空间数量</span></span><br><span class="line"><span class="type">int</span> free;</span><br><span class="line">    <span class="comment">//字符串数组，保存字符串</span></span><br><span class="line"><span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//综上：常数获取字符串长度；避免缓冲区移除；减少重分配次数：内存不足时，会触发自动扩容；SDS API会以处理二进制的方式处理存放的buf数组里的数据，程序不会对其中做任何限制、过滤、假设，二进制安全；</span></span><br></pre></td></tr></table></figure><p>del key,get key,set key value</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>简单的字符串列表，<em><strong>底层是linkedlist和ziplist</strong></em>（元素数量&lt;512，所有对象元素长度小于64字节就使用ziplist反之就linkedlist）。</p><p>​ziplist：将所有元素紧挨着一起存储，分配的是一块连续的内存</p><p>​linkedlist:会有前驱后驱指针</p><p>可用于消息队列；顺序特性实现朋友圈点赞；顺序特性进行分布式日志顺序性展示；发布和订阅；慢查询</p><p>  Lpush,lpop,rpop,rush,</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>是一个键值对集合，是一个String类型的key和value的映射表。相当于hashmap。存放对象类型的数据，可避免键名冲突。 用户的购物车；hash作为商品秒杀技术对象完成商品秒杀系统</p><p>底层：ziplist（元素数量&lt;512个，所有值&lt;64字节）和hashtable</p><p>redis为了提高性能，不能阻塞服务，采用了渐进式策略</p><p>hset,hgetall,hlen,hget</p><p>用来缓存作为用户信息</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>String类型的无序集合，底层哈希表和intset（所有元素是整数，元素数量小于512）</p><p>​intset：有序不重复的连续空间；</p><p>sadd key element[ ]</p><p>比如标签；黑白名单；获取所有业务的权限、用户标签</p><h1 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h1><p>组成：ziplist（元素数量小于128，所有元素长度&lt;64）和跳跃表+哈希结合，value保证唯一性，又可为每个value代表权重的值。</p><p>跳表：每一层都是一个有序链表，默认升序。跳表中有表头节点和表尾节点。zskiplistNode中包含层、后退指针、分值、成员对象。底层拥有所有元素，插入元素的时候会随机生成一个“层次数字”，然后元素插入达到这个层次的所有底层，直到原始链表层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;<span class="comment">//跳表，目的就是为了高效支持范围查找</span></span><br><span class="line">&#125; zset;</span><br><span class="line"><span class="comment">//跳表节点</span></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    <span class="comment">//保存数据</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//权重</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    level数组</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        <span class="comment">//前向指针</span></span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        <span class="comment">//跨度，记录跨越了level0上的几个结点</span></span><br><span class="line">        unsigned <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"><span class="comment">//跳表</span></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">   <span class="comment">//跳表的头结点和尾结点 </span></span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">   <span class="comment">//最大长度 </span></span><br><span class="line">    unsigned <span class="type">long</span> length;</span><br><span class="line">   <span class="comment">//最大层数 </span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳表会从头节点的最高层开始查找下一个节点，因为节点中有元素和权值，所以两者都要比较</span></span><br><span class="line"><span class="comment">//若当前定位的元素权值更小，就访问该层下一个节点</span></span><br><span class="line"><span class="comment">//若当前定位的元素权值与需要查询的权值相同，就比较元素值，若定位的元素值数据更小，还是访问该层下一个节点</span></span><br><span class="line"><span class="comment">//以上两个条件都不满足就会访问level数组的下一层指针，沿着下一层指针找</span></span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">           ...</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>跳表在创建节点的时候，采用了随机生成节点层数的方法。&lt;&#x3D;25%</p><p>排行榜系统；带权重任务队列；根据权重进行排序</p><p>zadd  key score member[]</p><p>搜索路径如图：要检索19</p><p><img src="/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/19.png"></p><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>Bitmaps:String类型上的一组面向bit操作的集合，不是真的数据结构，优点就是存储信息可节省大量空间。一般用于实时分析，存储对象ID关联的节省空间且高性能的布尔信息。底层是String</p><p>HyperLogLogs：用于计算唯一事物的概率数据结构。可用于计算用户每天在搜索框中执行唯一的搜索。底层是String</p><p>  GEO：存储用户给定的地理位置信息，并对这些信息操作。底层是zset</p><p>  Streams：内存版的kafka</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt;最基本的，动态可修改字符串，二进制安全，存数字时底层是int编码；长字符串（长度&amp;gt;39字节）raw编码</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>基础题1</title>
    <link href="http://example.com/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/"/>
    <id>http://example.com/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/</id>
    <published>2022-08-08T16:11:35.000Z</published>
    <updated>2022-08-08T16:28:37.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h1><p>Java9之后就是通过byte[] value 实现</p><p><img src="/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/String.png"></p><h1 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h1><p>主要用在 变量、方法、类</p><p>修饰类对象的时候，属性值还是可以变化。</p><p>使用原因：把方法锁定，防止任何类修改它的含义；提升效率性能；多线程下保持了线程安全。</p><p>修饰基本类型值不变，<em><strong>修饰引用类型只是引用不可变，但是引用所指向的地址的内容可以改变</strong></em></p><p><strong>只被final修饰但是没给初始值的情况下的基本数据类型是可以通过反射改变值</strong></p><p>final修饰的属性的初始化可以在编译器、运行期，初始化后不能被改变</p><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><p>当变量被static final修饰时，该变量的值是不能被改变且必须给初始值；</p><p>只被final修饰的变量在定义时没给初始值是能通过反射改变代码运行期间所赋予的值，而在定义时就给了初始值的通过反射也不能改变值</p><h1 id="为什么重写equals要重写hashcode"><a href="#为什么重写equals要重写hashcode" class="headerlink" title="为什么重写equals要重写hashcode"></a>为什么重写equals要重写hashcode</h1><p><img src="/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/hashcode.png"></p><p>首先hashCode是一个本地方法，不同虚拟机有不同实现，主要是为了给HashMap这样的哈希表的使用。</p><p>设计该方法的重要因素：对同一个对象调用该方法应该产生相同的值，所以需要快、不需要唯一性。</p><p>equals相等，hashcode一定相等：</p><p>equals不等，hashcode不一定不等：这是为了尽量减少哈希冲突，因为hashcode是int类型，有范围，难免冲突，此时hashmap通过拉链法解决冲突</p><p>hashcode不等，equals一定不等</p><p>hashcode相等，equals不一定相等</p><p>综上：</p><p>若重写equals，就一定要重写hashCode</p><p>提高效率：先进行hashcode比较，若不同就不用再比较，就提高了效率</p><h1 id="抽象类（JDK8）"><a href="#抽象类（JDK8）" class="headerlink" title="抽象类（JDK8）"></a>抽象类（JDK8）</h1><p>不一定要有抽象方法</p><p>不能用final修饰，因为final修饰了就不能被修改和继承了</p><h2 id="与接口的区别"><a href="#与接口的区别" class="headerlink" title="与接口的区别"></a>与接口的区别</h2><ul><li>抽象类可以提供成员方法的实现细节，而接口只能包含抽象方法、普通方法。</li><li>抽象类的成员变量可以是各种类型，接口中的成员变量只能是public static final</li><li>抽象类可有静态代码和静态静态方法，接口不能含有静态代码块和静态方法</li><li>抽象类可有构造器，接口不能有有构造器</li><li>一个子类只存在一个父类，一个子类可以存在多个接口</li></ul><h2 id="与普通类"><a href="#与普通类" class="headerlink" title="与普通类"></a>与普通类</h2><p>普通类：不能含有抽象方法，可以直接实例化</p><p>抽象类：可以有抽象方法，不能直接实例化</p><h1 id="x3D-x3D-和equals"><a href="#x3D-x3D-和equals" class="headerlink" title="&#x3D;&#x3D;和equals"></a>&#x3D;&#x3D;和equals</h1><table><thead><tr><th align="center">&#x3D;&#x3D;</th><th align="center">Equals</th></tr></thead><tbody><tr><td align="center">运算符</td><td align="center">方法</td></tr><tr><td align="center">若比较基本类型，则比较数值（即使数据类型不同，比如 int  i&#x3D;1,double k &#x3D;1.0）；若是引用数据类型，则比较内存地址值</td><td align="center">比较方法的两个对象内容是否相等  不能比较基本数据类型的变量；  若没有重写（也是默认情况），则比较的是引用数据类型的变量所指向的对象的地址</td></tr><tr><td align="center">比较浮点型数据时导致数据精度丢失</td><td align="center"></td></tr></tbody></table><h1 id="解决Hash冲突"><a href="#解决Hash冲突" class="headerlink" title="解决Hash冲突"></a>解决Hash冲突</h1><p>开放地址法：一旦发生了冲突，就寻找下一个空的散列地址。 H<del>i</del>&#x3D; (H(key) + d<del>i</del>)%m;  m为哈希表长，d<del>i</del>为增量序列</p><p>再哈希算法：一直调用哈希函数，计算地址，直到没有冲突。不易发生聚集，但增加了计算时间</p><p>链地址（HashMap所用）：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接。</p><p>建立公共溢出区：将哈希表分为基本表和溢出表两个部分，凡是和基本表发生冲突的元素都填入溢出表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;StringBuilder和StringBuffer&quot;&gt;&lt;a href=&quot;#StringBuilder和StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;StringBuilder和StringBuffer&quot;&gt;&lt;/a&gt;StringBu</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="题" scheme="http://example.com/tags/%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集系统</title>
    <link href="http://example.com/2022/08/04/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2022/08/04/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-08-04T08:01:59.000Z</published>
    <updated>2022-08-04T08:13:42.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>运行过程中，会产生大量内存垃圾，为确保程序运行时的性能，虚拟机在程序执行过程中药不断进行自动的垃圾回收</p><p> 收集 三个内存区域</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>历史最悠久的，单线程工作，垃圾收集时会暂停其他所有工程线程，直到收集结束（用户不可知）</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial收集器的多线程并发版本</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>一款以<em><strong>最短回收停顿时间为目标</strong></em>的收集器。</p><p>基于标记-清除算法实现。四个步骤：初始标记、并发标记、重新标记、并发清除</p><p>优点：并发收集、低停顿</p><p>缺点：对处理器资源敏感、无法处理“浮动垃圾”、大量空间碎片</p><h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>低延迟的，<em><strong>染色指针技术</strong></em>：将少量额外的信息存储在指针上的技术。</p><p>步骤：并发标记、并发预备重分配、并发重分配、并发重映射</p><h1 id="判断是否可以回收"><a href="#判断是否可以回收" class="headerlink" title="判断是否可以回收"></a>判断是否可以回收</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p> 引用计数法：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。原理简单，效率也很高。已被淘汰，它不能解决循环引用。</p><p>  可达性分析算法：从GC Roots作为根对象开始向下搜索，搜索所走过的路径被称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收</p><p>可作为GC roots：栈帧中的本地变量表中引用的对象（比如：堆栈中用到的参数、局部变量、临时变量）；方法区中静态属性引用的对象（java类的引用类型静态变量）；方法区中常量引用的对象（字符串常量池的引用）；本地方法栈中native方法引用的对象；所有同步锁（synchronized）持有的对象</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>当经过可达性分析算法判定为可以删除后，就只是对其进行一次标记，之后还要筛选，看该对象是否有必要执行finalize方法，如果没有覆盖finalize方法或者已经被虚拟机调用那就视为“没有必要执行”。</p><p>如果该对象判定为有必要执行方法，那该对象就被放置一个名为F-Queue的队列之中，之后在由虚拟机自动建立的、低调度优先级的Finalizer线程执行finalize方法（但虚拟机不一定会等待它运行结束），稍后收集器对F-Queue中的对象进行第二次标记，第二次标记成功就代表要被回收了。</p><p>如果对象要从F-Queue中逃脱，就要重新与引用链上的任一对象关联。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记无用对象，然后进行清除回收。效率不高，无法清理出垃圾碎片；执行效率不稳定。因为标记和清除的效率随着需清理对象的增长而降低</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>按容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，再把已使用的内存空间一次清理。适合对象较少的时候，即使用年轻代；会产生大量的内存间复制的开销</p><p>但对于多数对象要回收的情况，需要复制的对象就较少，也不用考虑空间碎片，只要移动堆顶的指针，按顺序分配即可。但因为内存对半分开，空间浪费</p><h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><p>标记无用对象，让所有存活的对象向一端移动，然后直接清除掉边界外的内存</p><p>分代收集算法：根据对象存活周期的不同将内存划分几块，一般是新生代（复制算法清除）和老年代（标记整理算法清除）</p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>Minor GC(Young GC):只是新生代的垃圾收集</p><p>​年轻代空间不足时，就触发，即Eden代满了，survivor满不会引发gc</p><p>​非常频繁，回收速度也快</p><p>Major GC(old gc)：只是老年代的垃圾收集，执行速度比Minor GC慢10倍以上</p><p>​只有CMS GC会有单独收集老年代的行为</p><p>Mixed GC：收集整个新生代以及部分老年代的垃圾收集</p><p>Full gc：回收这个堆和方法区的垃圾收集</p><h1 id="频繁发生Full-GC"><a href="#频繁发生Full-GC" class="headerlink" title="频繁发生Full GC"></a>频繁发生Full GC</h1><p>发生在system.gc()调用，老年代空间不足，永生区空间不足，堆分配了大对象</p><p>注意两种数据结构：linkedBlockingQueue：当数据量很大，就会无限放数据，就导致full gc；所以要使用有参构造函数并合理设置节点数量</p><p>线程池：消息量大造成内存消耗过快，是因为队列无限存放数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;运行过程中，会产生大量内存垃圾，为确保程序运行时的性能，虚拟机在程序执行过程中药不断进行自动的垃圾回收&lt;/p&gt;
&lt;p&gt; 收集 三个内存区域&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="http://example.com/2022/08/01/LinkedList/"/>
    <id>http://example.com/2022/08/01/LinkedList/</id>
    <published>2022-08-01T10:02:48.000Z</published>
    <updated>2022-08-01T10:04:58.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>基于双向链表实现，可作为双向队列，随机访问集合元素较能较差，因为需要在双向链表中招待index位置再返回。底层是Node数据结构，有两个指针first和last分贝指向头和尾。</p><p>更适合删除添加</p><p>但查询最链表的第一个和最后一个元素也很快，不用遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br><span class="line">    <span class="comment">// LinkedList的大小，其实就是其内部维护的双向链表存储元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 头结点，指向第一个节点的指针或引用，默认为 null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">// 尾节点，指向最后一个节点的指针或引用，默认为 null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 因为LinkedList是双向链表，所以node需要前驱和后驱指针</span></span><br><span class="line"><span class="comment">    * 一定要是static的：若不用static修饰，那node就是一个普通的内部类，java中一个普通的内部类在实例化后，默认会有外部类的引用，所以就有可能会内存泄露</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">            <span class="comment">// 存储的元素</span></span><br><span class="line">            E item;</span><br><span class="line">            <span class="comment">// 指向下一个节点</span></span><br><span class="line">            Node&lt;E&gt; next;</span><br><span class="line">            <span class="comment">// 指向上一个节点</span></span><br><span class="line">            Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">                <span class="built_in">this</span>.item = element;</span><br><span class="line">                <span class="built_in">this</span>.next = next;</span><br><span class="line">                <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     * 构造包含指定元素的列表集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 如果 c 为 null，则会抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">// 指向无参的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素添加到指定的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引角标不合法，则抛出索引越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 index 是否合法，不合法则抛出索引越界异常</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 判断要添加的是否是最后一个索引位置</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素 e 添加到链表最后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果当前链表还没有元素，则将当前元素赋值为 first</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 用来记录 LinkedList 结构性变化的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素 e 插入到指定的 index 索引位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取原本 index 索引位置的元素的前节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 用来记录 LinkedList 结构性变化的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素索引处的(非空)节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 它对 index 与集合长度的一半做比较，来确定是在集合的前半段还是后半段进行查找，</span></span><br><span class="line">    <span class="comment">// 从而达到节省一半的时间。</span></span><br><span class="line">    <span class="comment">// size&gt;&gt;1 相当于 size/2，这里的意思就是判断 index 的位置在前半段还是后半段</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h1&gt;&lt;p&gt;基于双向链表实现，可作为双向队列，随机访问集合元素较能较差，因为需要在双向链表中招待index位置再返回。底层是Node数据结构，有两个指针</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="List" scheme="http://example.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>AQS-ReentrantLock</title>
    <link href="http://example.com/2022/07/29/AQS-ReentrantLock/"/>
    <id>http://example.com/2022/07/29/AQS-ReentrantLock/</id>
    <published>2022-07-28T19:21:09.000Z</published>
    <updated>2022-07-28T19:47:57.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>用来构建锁和同步器的框架，AQS能简单且高效的构造出应用广泛的大量的同步器</p><p>是JDK提供的一个同步框架，内部维护着FIFO双向队列，即CLH同步队列</p><p><img src="/2022/07/29/AQS-ReentrantLock/FIFO.png"></p><p>AQS依赖它来完成同步状态管理（Volaile修饰的static，用于标志是否持有锁）。如果获取<em><strong>同步状态state</strong></em>失败时，会将当前线程及等待信息封装成一个Node，将Node放到FIFO队列里，同步阻塞当前线程，当线程将同步状态state释放时，会把FIFO队列中的首节唤醒，</p><p>队列中的头部有一个为空的线程，占位的，称呼为傀儡节点或哨兵节点。一开始没有，往队列中插入第一次线程（Node）时插入</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>CountDownLatch(计时器)：允许count个线程阻塞在一个地方，直至所有线程的任务都执行完</p><p>Semaphore(信号量)、CyclicBarrier（循环栅栏）、ReentrantLock、ReetrantReadWriteLock（读写锁）</p><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>抢到资源的线程直接使用处理业务逻辑，若请求的共享资源被占用即没抢到资源，那就需要一套线程阻塞等待以及被唤醒时锁分配的机制（AQS是用CLH队列锁实现），将暂时获取不到的锁的线程加入队列。队列就是AQS的抽象表现。将请求共享资源的线程封装成队列的结点node，通过CAS、自旋以及LockSupport.park()维护state变量的状态，使并发达到同步效果</p><p><img src="/2022/07/29/AQS-ReentrantLock/zhuangtai.png"></p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>里面会有一个volatile修饰的int同步状态变量state，通过CAS去修改这个变量值，若修改成功，线程就会表示获取到了锁，没有成功或state已经是一个加锁的状态了，就通过一个waiter这个对象封装线程添加到FIFO等待队列里面，再把它挂起等待被唤醒。</p><h1 id="AQS部分源码"><a href="#AQS部分源码" class="headerlink" title="AQS部分源码"></a>AQS部分源码</h1><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractQueuedSynchronizer</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//同步器指向队列的头节点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">//同步器指向队列的尾巴节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">//当前锁的状态</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock部分源码"><a href="#ReentrantLock部分源码" class="headerlink" title="ReentrantLock部分源码"></a>ReentrantLock部分源码</h1><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node队列"><a href="#Node队列" class="headerlink" title="Node队列"></a>Node队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//指示节点在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">//指示节点以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//各种状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//node处于上述状态的标志位</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">//前驱、后驱指针</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//封装到node的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//连接到等待条件的下一个节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，默认创造非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// true和false创造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//看state是否是0，即判断是否有人占用</span></span><br><span class="line">            <span class="comment">//若没有人占用锁，就让当前线程持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//非公平锁相比与公平锁相比，少了一个判断!hasQueuePredecessors()</span></span><br><span class="line"><span class="comment">//后面没有抢到锁的线程   此时的arg=1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">//将该节点放入队列</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//模板方法设计模式，必须有这个实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用非公平锁的尝试获取</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">     <span class="comment">//获取state状态变量</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">     <span class="comment">//=0,锁就没有线程获取</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//该线程是否抢到了锁</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//把当前线程放入持有者</span></span><br><span class="line">             setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//当前线程是否是持有锁的线程.可重入锁</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//enq：准备进入队列。让该线程的头结点就指向队列中的最后一个线程（若队列没线程，就加一个傀儡节点），最后一个线程的next指针指向该线程，同步器的尾指针指向该线程。</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;用来构建锁和同步器的框架，AQS能简单且高效的构造出应用广泛的大量的同步器&lt;/p&gt;
&lt;p&gt;是JDK提供的一个同步框架，内部维护着FIFO双向</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ReentrantLock" scheme="http://example.com/tags/ReentrantLock/"/>
    
    <category term="AQS" scheme="http://example.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList部分解析</title>
    <link href="http://example.com/2022/07/26/ArrayList/"/>
    <id>http://example.com/2022/07/26/ArrayList/</id>
    <published>2022-07-25T21:35:26.000Z</published>
    <updated>2022-07-25T21:44:23.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>基于数组实现容量大小动态变化，基于索引的数据结构，随机访问集合元素上有较好的性能，<em><strong>扩容机制是1.5倍</strong></em>。底层是Object数组实现，地址连续，动态扩容，允许包括null在内的任何元素插入；非线程安全，异步；</p><p>创建对象时，若用的无参构造器，初始elementData容量为0，第一次添加则扩容到10，再扩容就是1.5倍；构造器也可以指定大小</p><p>更适合随机查找，查询块，也可以根据下标查询</p><p>扩容有两个部分：确定最小容量的值，调用grow方法。Arrays.copyOf完成扩容</p><p>把传入集合转换为数组，再通过Arrays.copyOf()拷贝到elementData</p><p>add方法需要先确定是否要扩容再进行赋值操作</p><h1 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">//初始化的容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空数组（用于空实例）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认大小空实例的共享空数组实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//保存ArrayList数据的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">//所含有的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）      </span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="add"><a href="#add" class="headerlink" title="add"></a>add</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">// 扩容</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">       <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">       <span class="comment">//是否越界</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       <span class="comment">//保证此时的容量大小</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//arraycopy()实现数组之间复制的方法，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以最小容量进行扩容</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组. 若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间（newCapacity的连续空间）</span></span><br><span class="line">        <span class="comment">// 并将elementData的数据复制到新的内存空间</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比较 minCapacity 和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;基于数组实现容量大小动态变化，基于索引的数据结构，随机访问集合元素上有较好的性能，&lt;em&gt;&lt;strong&gt;扩容机制是1.5倍&lt;/strong</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="List" scheme="http://example.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://example.com/2022/07/24/CAS/"/>
    <id>http://example.com/2022/07/24/CAS/</id>
    <published>2022-07-24T08:14:24.000Z</published>
    <updated>2022-07-24T08:17:27.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>比较并交换</p><p>  比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比直到主内存和工作内存中的值一致</p><p>  多个线程使用CAS操作一个变量，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试（自旋）或挂起</p><p>  <em><strong>是一条CPU并发原语，原子指令</strong></em>，不会造成数据不一致的问题</p><p>  乐观锁</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>先从地址V地区值A：2；根据A计算目标值B：3；通过CAS以原子的方式将地址V的值从A修改为B</p><p>1：调用unsafe类，分别专递主物理内存的值，原子类对象本身的值，当前对象内存地址的值，需要加上的值</p><p>2：拷贝主物理内存的值到当前线程内存</p><p>3：while循环，一直修改</p><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p>  Unsafe类：CAS的核心类，来自JVM的rt.jar下。因为java不能直接访问底层系统，需要本地（native）方法访问，基于该类可以直接操作特定内存的数据，类似于c语言的指针直接操作内存。Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务</p><p>  变量valueOffset，表示变量值在内存中的偏移地址</p><p>  变量value被volatile修饰，保证多线程之间的可见性</p><p> unsafe类：compareAndSwapObject(Object var1, long var2, Object var4, Object var5)</p><p>​第一个：要修改的对象</p><p>​第二个：对象中要修改变量的偏移量</p><p>​   第三个：修改之前的值</p><p>​   第四个：预想修改之后的值</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>循环时间开销很大：因为通常配合着循环使用，若失败则会一直尝试</p><p>只能保证一个共享变量的原子操作（多个共享变量，循环CAS就不能保证原子性，要用锁）</p><p><em><strong>引来ABA问题</strong></em></p><h2 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h2><p>线程1从内存位置V读取数据A，线程2也从地址V出读取A，线程2经过了一些操作将值别成了B，然后线程2又将V位置的数据变成A，此时，线程2进行CAS操作发现内存中仍然是A，进程1操作成功。但是整个过程中，地址V其实是已经被修改过的</p><p><em><strong>带有标记的原子引用类</strong></em>可以<em><strong>控制变量值的版本</strong></em>来保证CAS正确性。所以，解决ABA的话改用传统的互斥同步</p><p>原子类：某个线程进入方法，执行其中的指令时，不会被其他线程打断，别的线程一直等到该方法执行完成才由JVM从等待队列中选择一个另一个线程进入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;比较并交换&lt;/p&gt;
&lt;p&gt;  比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比直到主内存和工作内存中的值一致&lt;/p&gt;</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL简单优化</title>
    <link href="http://example.com/2022/07/21/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/07/21/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/</id>
    <published>2022-07-21T15:55:56.000Z</published>
    <updated>2022-07-21T15:59:42.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><p>对于所执行的SQL语句，通过“explain”查看相关信息进行调节</p><p>可以获取表的读取顺序，数据读取操作的操作类型，哪些索引可用，哪些索引实际被使用，表之间的引用，每张表有多少行被优化器查询</p><p>使用方法： EXPLCAIN + SQL语句</p><p>Id：id相同：执行顺序由上至下</p><p>​    Id不同：若是子查询，id的序号会递增，id的值越大优先级越高，越先执行</p><p>​    id不同，同时存在，可以认为从上往下顺序执行。</p><p>Select_type：</p><p>​    SIMPLE：简单的select查询，查询中不包含子查询或UNION</p><p>​    PRIMARY：若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</p><p>​    SUBQUERY：在select或where列表中包含子查询</p><p>​    DERIVEN：在from列表中包含的子查询被标记为DERIVER（衍生），mysql会递归执行这些子查询，把结果放在临时表中</p><p>​    UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在from子句的子查询中，外层select将被标记为：DERIVED</p><p>​    UNION RESULT：从UNION表获取结果的SELECT</p><p>Table：就是执行的表</p><p><em><strong>Type</strong></em>:显示查询使用了哪些类型</p><p>​    包含：ALL、index、range、ref、eq_ref、const&#x2F;system、NULL</p><p>从好到差：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</p><p>​    System:表里只有一行记录，const的特例</p><p>​    Const：通过索引，一次就找到，用于比较primary key或者union索引</p><p>​    Eq_ref：唯一索引扫描，对每个索引键，表中只有一条记录匹配。主键或唯一索引扫描</p><p>​    Ref：非唯一性索引扫描，返回某个单独值的所有行</p><p>​    Reange：值检索给定范围的行</p><p>​    Index：与all的区别是index只遍历索引树。通常比all块</p><p>​    All：将遍历全表以找到匹配的行</p><p>Possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定被查询实际使用</p><p>Key_len：表示索引中使用的字节数，通过该列计算查询中使用的索引长度</p><p>Ref：显示索引的那一列被使用了</p><p>row： 根据表统计信息及索引选用情况，大致估算出找到所需要读取的行数</p><p>Extra：包含不适合在其他列中显示但很重要的额外信息</p><h1 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h1><p>查询尽量不用select * ，而是具体字段：只取需要的，节省资源、减少开销；select * 时很可能不会用到索引，就会造成全表扫描 </p><p>​    避免在where子句中用or连接条件（用union all，或两条sql）：or可能让索引失效，而全局扫描；</p><p>​         Select * from student where id&#x3D;1 or salary&#x3D;3000</p><p>​         Select * from student where id&#x3D;1 union all select * from student where salary</p><p>​    Varchar代替char：因为是根据实际长度存储，存储空间小，节省空间；char按声明大小存储，不足补空格；在一个相对小的字段内搜索，效率更高</p><p>​    尽量使用数值代替字符串</p><p>​    查询时尽量避免返回大量数据：若返回的数据量大，就查询时间过长，网络传输时间过长。太多了也没意义，用户不好看。通常采用分页的形式</p><p>​    创建name字段的索引：提高查询速度的最简单最佳方式</p><p>​         Alter table student add index index_name(NAME)</p><p>​    优化like语句：like可能让索引失效</p><p>​    Where限定查询的数据</p><p>尽量避免全表的扫描，在where、order by等列上建立索引。在字句中尽量避免使用 !&#x3D; &gt; &lt; 等操作符，否则引擎会放弃使用索引去全表扫描了</p><p>尽量使用数字型的字段，不然会降低连接的性能，也会增加存储开销（因为引擎在处理查询和连接的时候会逐个去比较字符串中的每个字符），数字就只需要比较一次</p><h2 id="大表"><a href="#大表" class="headerlink" title="大表"></a>大表</h2><p>限定数据范围：比如将查看订单历史记录，控制在一定的时间范围</p><p>读写分离：数据库拆分，主库负责写，从库负责读</p><p>垂直分区：根据数据库里面数据表的相关性拆分。简单说，就是把一张列较多的表拆分成多个表</p><p>水平分区：将一片数据分散到不同表或者库中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Explain&quot;&gt;&lt;a href=&quot;#Explain&quot; class=&quot;headerlink&quot; title=&quot;Explain&quot;&gt;&lt;/a&gt;Explain&lt;/h1&gt;&lt;p&gt;对于所执行的SQL语句，通过“explain”查看相关信息进行调节&lt;/p&gt;
&lt;p&gt;可以获取表的读取顺</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Http1.0-3.0</title>
    <link href="http://example.com/2022/07/17/Http1-0-3-0/"/>
    <id>http://example.com/2022/07/17/Http1-0-3-0/</id>
    <published>2022-07-17T06:35:00.000Z</published>
    <updated>2022-07-17T06:38:46.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="HTTP1-0和1-1"><a href="#HTTP1-0和1-1" class="headerlink" title="HTTP1.0和1.1"></a>HTTP1.0和1.1</h4><p>HTTP&#x2F;1.0性能上，每发起一个请求都要新建一次TCP连接（三次握手），而且是串行，做了没有用TCP连接和断开</p><p>长连接：HTTP&#x2F;1.1采取的，只要任意一端没有明确的提出断开连接，则保持TCP连接状态</p><p>错误状态响应码：1.1中新增加了24个错误状态响应码</p><p>缓存处理：1.1引用了更多缓存控制策略</p><p> 1.1的性能：<em><strong>长连接、管道网络传输、队头阻塞</strong></em></p><p>管道网络传输：在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不用等其回来，就可以发第二个请求出去</p><p>队头阻塞：顺序发送的请求序列中，一个请求因为某种原因被阻塞时，后面排队的所有请求都阻塞了</p><p><img src="/http1-0-3-0/1.0-1.1.png" alt="image-20220709114337819"></p><p>HTTP1.1的瓶颈：</p><p>最大的问题就是高延迟：因为延迟难以下降；并发连接优先；队头阻塞；HTTP头部巨大且重复；不支持服务器推送消息</p><ul><li>请求&#x2F;响应头部未经压缩就发送，首部信息越多，延迟越大。只能压缩body部分</li><li>发送冗长的首部。每次都发送相同的首部浪费较多</li><li>没有请求优先级</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h5 id="HTTP1-1-优化"><a href="#HTTP1-1-优化" class="headerlink" title="HTTP1.1 优化"></a>HTTP1.1 优化</h5><p>尽量避免HTTP请求（缓存技术）</p><p>在需要发HTTP请求，减少次数（减少重定向，合并请求，延迟发送）</p><p>​收到合并请求就是合并资源，以一个大资源的请求替换多个小资源的请求；当大资源中的小资源发生变化，客户端就要重新下载整个完整的大资源</p><p>​     延迟发送：只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源</p><p>减少服务器的HTTP响应大小</p><h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h4><p>通过<em><strong>静态表和哈夫曼编码</strong></em>的方式，将体积压缩了近一半，针对后续的请求头部也可建立动态表（会占用内存而影响并发能力）</p><p>  <em><strong>实现了Stream并发，多个Stream只需复用一个TCP连接，节约了TCP和TLS握手时间，以及减少了TCP慢启动阶段对流量的影响。</strong></em></p><p>  服务器支持主动推送资源，大大提升了消息的传输信息</p><p>  HTTP&#x2F;2是基于TCP协议来传输数据，TCP层必须保证收到的字节数据是完成且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用。有队头阻塞问题，TCP和TLS的握手时延迟，网络迁移需要重新连接</p><h5 id="相比于HTTP-x2F-1-1的改进"><a href="#相比于HTTP-x2F-1-1的改进" class="headerlink" title="相比于HTTP&#x2F;1.1的改进"></a>相比于HTTP&#x2F;1.1的改进</h5><p>&#x3D;&#x3D;头部压缩&#x3D;&#x3D;：会压缩头，若头一样，会消除重复的部分</p><p>&#x3D;&#x3D;二进制格式&#x3D;&#x3D;：全面采用二进制格式并同城为帧（头信息帧，数据帧）。对计算机友好，提高传输效率</p><p><img src="/http1-0-3-0/1.0-1.1-2.png" alt="image-20220709152032970"></p><p>&#x3D;&#x3D;数据流&#x3D;&#x3D;：数据包不是按顺序发送，每个请求或回应的所有数据包称为数据流。每个数据流里面有独一无二的编号，客户端发送的编号为奇数，服务器端发送的为偶数。多个stream复用一个TCP达到并发效果</p><p>&#x3D;&#x3D;多路复用&#x3D;&#x3D;：2.0是可以在一个连接中并发多个请求或回应，而不用按顺序对应</p><p>&#x3D;&#x3D;服务器推送&#x3D;&#x3D;：服务器也可以主动向客户端发</p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>因为多个HTTP都在复用一个TCP链接，所以一旦发生丢包，都会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求就必须这个丢的包被传回来</p><h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><p>传输层的TCP换成UDP，并在UDP协议开发了QUIC协议保证了数据的可靠传输。</p><p>QUIC</p><p>  无队头阻塞</p><p>  建立连接速度块</p><p>  连接迁移</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;发展&quot;&gt;&lt;a href=&quot;#发展&quot; class=&quot;headerlink&quot; title=&quot;发展&quot;&gt;&lt;/a&gt;发展&lt;/h3&gt;&lt;h4 id=&quot;HTTP1-0和1-1&quot;&gt;&lt;a href=&quot;#HTTP1-0和1-1&quot; class=&quot;headerlink&quot; title=&quot;HTT</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://example.com/2022/07/16/IP/"/>
    <id>http://example.com/2022/07/16/IP/</id>
    <published>2022-07-15T17:45:22.000Z</published>
    <updated>2022-07-16T06:41:24.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><p>网络层，<em><strong>实现主机与主机之间的通信，点对点通信</strong></em></p><p>MAC（数据链路层）是实现 直连 两个设备之间通信，IP是在没有直连的两个网络之间进行通信传输。个人理解：计划和实施的区别。IP是整个旅游行程表，MAC是行程表里的交通工具。</p><p>&#x3D;&#x3D;源IP地址和目标IP地址不会变化，只有源MAC地址和目标MAC一直在变化&#x3D;&#x3D;</p><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><p>IP地址（IPv4地址）32位，在计算机中二进制方式处理。点分十进制的标记方式处理</p><p>分类：A,B,C,D,E类</p><p>A（0<del>127.255.255.255）,B（128</del>191.255.255.255）,C（192~223）主要两部分，网络号和主机号（比如：A小区1栋101号和B小区1栋101号）</p><p>A,B,C类中有私有IP和公有IP区分</p><p>解析IP地址，看第一个0出现在哪一位。在第一位是A类，第二为是B类，依次类推</p><p>广播地址</p><p>用于在同一个链路中互相连接的主机之间发送的数据包</p><p>​    分为：本地广播（本网络内广播）和直接广播（不同网络间的广播）</p><p>D类和E类地址没有主机号，不可用于主机IP。</p><p>D类常用于多播，E类是预留的分类，暂未使用</p><p>多播地址</p><p>​    用于将包发送给特定组内的所有主机</p><h3 id="IPV4分类的优缺点"><a href="#IPV4分类的优缺点" class="headerlink" title="IPV4分类的优缺点"></a>IPV4分类的优缺点</h3><p>优点：简单明了、选路（基于网络地址）简单</p><p>缺点：同一网络下没有地址层次，就缺少地址的灵活性；不能很好与现实网路匹配</p><p>两个缺点都可在CIDR无分类地址解决：前面是网络号，后面是主机号</p><p>​    以a.b.c.d&#x2F;x形式表示，比如10.100.122.2&#x2F;24: &#x2F;24表示前24位是网络号，剩余是主机号。</p><h2 id="问点"><a href="#问点" class="headerlink" title="问点"></a>问点</h2><p>为什么要分离网络号和主机号：两台计算机要通讯，首先判断是否处于同一个广播域内，即网络地址是否相同。若相同，表名接收方在本网络上，数据包就可以发送到目标主机</p><p>怎么划分子网：子网掩码的作用之一就是划分子网，将主机地址分为 子网网络地址和子网主机地址</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>是128位，与v4比，可分配的地址变多；可自动装配；包头包首部长度固定的40字节，去掉包头检验和，简化了首部结构，减轻了路由器符合，提高传输的性能；可伪造IP地址的网络安全，防止窃听，提升了安全性</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>单播地址：一对一通信；</p><p>组播地址：一对多通信；</p><p>任播地址：通信最近的节点，最近的节点由路由协议决定</p><p>没有广播地址</p><h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS：可将域名网址自动转换成具体的IP地址。越靠右，层级越高</p><p>层级关系：根DNS服务器，顶级域DNS服务器，权威DNS服务器</p><p>解析流程：</p><p>客户端发送DNS请求，并发给本地DNS解析器；本地域名解析器收到请求后，若缓存中能找到就直接返回IP地址，反之本地DNS会去问它的根域名服务器；根DNS收到请求后，发现后置是.com，就给本地DNS关于顶级域名服务器的地址；本地DNS收到后再发请求给顶级域名服务器，顶级域名服务器就返回权威域名服务器的地址；本地收到后，发送权威域名服务器请求，权威域名查询后将IP地址告诉给本地DNS。本地DNS将得到的IP地址返回给客户端，客户端建立连接</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在传输IP数据包的时候，确定了源IP和目标IP后，就通过路由表确定IP数据包下一跳、因为网络层下面是数据链路层，所以要知道下一跳的MAC地址。</p><p>因为主机路由表可找到下一跳的IP地址，所以可通过ARP协议，求下一跳MAC地址</p><p>即已知IP地址求MAC地址</p><p>ARP就是借助ARP请求域ARP响应两种类型确定MAC地址</p><p>主机通过广播发送ARP请求（里面有想知道的MAC地址的主机IP地址）；同个链路中所有设备收到ARP请求时，会自动拆开ARP里的内容，若里面的IP地址与自己的一致就将自己MAC地址放入ARP响应包返回给主机</p><p>操作系统会把第一次获取的MAC地址缓存起来（有期限）。</p><p>RARP：已知MAC地址求IP地址。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态获取IP地址，省去了配IP信息繁琐过程</p><p>步骤：</p><p>​    客户端发起DHCP发现报文的IP数据报（用的UDP广播通信，因IP地址、DHCP服务器地址都不知道），并用0.0.0.0作为源IP地址，255.255.255.255为广播目的地址。DHCP客户端将该IP数据包传给MAC，MAC再将帧广播到所有网络设备中</p><p>​    DHCP服务器收到DHCP报文时向客户端响应，里面包含IP地址、子网掩码等信息。客户端收到一个或多个服务器的DHCP提供报文后，选择一个服务器，并对其发送DHCP请求报文进行响应，回显配置的参数。服务端用DHCP ACK报文进行响应，回应其要求的参数</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>网络地址转换NAT，缓解IPV4地址耗尽的问题</p><p>简单说就是在主机对外通信时，把私有IP地址转换成公有IP地址</p><p>缺点：外部无法主动与NAT内部服务器建立连接，因NAPT转换表没有转换记录；转换表的生成与转换操作会产生性能开销；通信过程中，若NAT路由器重启了，所有TCP链接将重置</p><p>解决：改用IPV6；NAT穿透技术</p><h3 id="ICMP（互联网控制报文协议）"><a href="#ICMP（互联网控制报文协议）" class="headerlink" title="ICMP（互联网控制报文协议）"></a>ICMP（互联网控制报文协议）</h3><p>主要功能：确认IP包是否到达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置</p><p>分类</p><p>​    查询报文类型：诊断查询信息</p><p>​    差错报文类型：通知出错原因的错误信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h1&gt;&lt;p&gt;网络层，&lt;em&gt;&lt;strong&gt;实现主机与主机之间的通信，点对点通信&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;MAC（数据</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="IP" scheme="http://example.com/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>四次挥手</title>
    <link href="http://example.com/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://example.com/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2022-07-14T15:54:24.000Z</published>
    <updated>2022-07-14T15:57:43.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；</p><p>当服务器端收到FIN后，发送ACK应答报文，服务端就进入close_wait状态，</p><p>客户端收到ACK应答报文后，进入FIN_WAIT_2状态</p><p>服务端做最后的数据处理（读到结束符EOF）已发送完成，则向客户端发FIN报文，服务端就进入LAST_ACK状态 ；</p><p>客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传），就进入TIME_WAIT状态；</p><p>服务器端收到ACK就关闭（CLOASE状态），客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/guocheng.png"></p><h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><p>关闭连接时，客户端向服务端发送FIN后，表示客户端不再发数据，但是能接收数据</p><p>服务端收到FIN后，先回ACK应答，但可能还有数据处理和发送不能立马关闭socket，等不再发数据后，才发FIN表示同意现在关闭连接。</p><p>所以，服务端需要等待完成数据的发送和处理，ACK和FIN一般都会分开发送，所以多一次</p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么TIME_WAIT等待时间是2MSL：是报文最大生存时间，超过这个时间报文将被丢弃。因为TCP报文基于IP协议的，IP头部中有一个TTL字段，是IP数据报可以经过最大路由数，<em><strong>MSL要  &amp;ge; TTL消耗为0的时间</strong></em>。2MSL是从<em><strong>客户端收到FIN后发送ACK开始计时的</strong></em>，若客户端的ACK没有传到服务端，客户端就又会收到来自服务端的FIN报文，那么2MSL将重新计时</p><p>为什么需要TIME_WAIT：主动发起关闭连接的一方才会有TIME-WAIT状态。需要TIME-WAIT状态，是<em><strong>防止接收到具有相同的四元组出现的旧数据包</strong></em>，2MSL足以上两个方向上数据包都被丢掉，保证出现的数据包一定是建立连接时所产生的；保证连接能正确关闭：给出足够的时间确保最后的ACK能让被动关闭方接收</p><p>TIME_WAIT过多的危害：内存资源占用；端口资源的占用，一个TCP连接至少消耗一个本地端口，若沾满了所有端口，就不能创建新链接</p><p>若已建立了链接，但客户端突然故障：</p><p>​TCP的&#x3D;&#x3D;保活机制&#x3D;&#x3D;：定义一个时间段，该时间段内，若没有任何连接相关的活动，TCP保活机制就会开始作用，每隔一个时间段就发探测报文（数据很少），若连续几个探测报文没有回应，则认为当前TCP连接已死亡，系统内核就将错误信息通知给上层应用</p><p>​对端程序工作正常：TCP保活的探测报文，对端会正常响应，TCP保活时间会被重置</p><p>​对端程序崩溃并重启：发探测报文，对端可响应，但是没有该连接的有效信息，会产生一个RST报文，就很块发现TCP连接已被重置</p><p>​对端程序崩溃或其他原因让报文能不到达：探测报文不能得到响应，TCP会报告该TCP连接已死亡</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>四次挥手优化</p><p>​    主动方优化：发FIN报文的方式有close和shutdown，所以发送更改方式。调整FIN重传次数。调整状态时间和孤儿连接的上限个数。</p><p>   被动方优化：复用time_wait状态的连接（只使用于客户端）</p><p>Close：断开后，不能传输数据也不能发数据。</p><p>Shutdown：控制只关闭一个方向的连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要流程&quot;&gt;&lt;a href=&quot;#主要流程&quot; class=&quot;headerlink&quot; title=&quot;主要流程&quot;&gt;&lt;/a&gt;主要流程&lt;/h1&gt;&lt;p&gt;客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP怎么保证可靠传输</title>
    <link href="http://example.com/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <id>http://example.com/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</id>
    <published>2022-07-13T12:17:56.000Z</published>
    <updated>2022-07-13T12:30:36.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="普通处理"><a href="#普通处理" class="headerlink" title="普通处理"></a>普通处理</h1><p>应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传送</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；</p><p>TCP会在<strong>数据包丢失和确认应答丢失后发生超时重传</strong></p><p>设置的时间RTO：RTO太大，重发慢，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时。所以，设置的RTO应该略大于报文忘返RTT的值</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>以<em><strong>数据驱动重传</strong></em>。收到三个相同ACK报文时，会在定时器过期之前，重传文段。</p><p>只解决了超时时间的问题，有另一个问题：重传的时候，是重传一个，还是重传之前的所有，所以就有了SACK方法</p><h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p>在TCP头部的“选项”字段中添加一个SACK，<em><strong>将缓存的地图发送给发送方</strong></em>，发送方就知道哪些数据收到了，哪些没有，就可以<em><strong>只传丢失的数据</strong></em>、</p><h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p>使用了SACK告诉 发送方，有哪些数据被重复接收了。</p><p>可以让发送方知道，是发出去的包丢了；可以知道是不是发送方的数据包被网略延时了；可以知道网络中是不是把发送方的数据包给复制了</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>TCP是每发一个数据，收到回应后再发下一个，数据包忘返时间长，通信效率低。</p><p>发送方会定时发送窗口大小探测报文，及时知道接收方窗口大小辩护</p><p>窗口大小就是指<em><strong>无需等待确认应答，可以继续发送数据的最大值</strong></em></p><p>大小在TCP头部，该字段是接收端告诉发送端自己有多少缓冲区可接收数据，发送端根据这个发送数据</p><p>接收窗口和发送窗口大小不完全相等：接收窗口大小约等于发送窗口大小。因为滑动窗口大小不是一成不变，若接收方的程序读取数据很快，接收的滑动窗口就会空出来。那么新的接收窗口大小，是通过TCP头部的窗口大小字段告诉发送方，传输存在时延，所以两者是约等于的关系</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率，根据接收方的实际接收能力变化</p><p>窗口关闭：窗口大小为0，就会阻止发送方传递数据，直到窗口非0。当窗口关闭时，接收方处理完数据后会发送一个窗口非0的ACK报文，若该报文丢失，那会出现问题</p><p>​解决窗口关闭时潜在的死锁现象：TCP为每一个连接设置定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器。该计时器若超时，就发送窗口探测报文，对方在确认该探测报文时会给出自己的窗口大小</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>目的是<em><strong>避免发送方的数据填满整个网络</strong></em></p><p>拥塞窗口是发送方维护的一个状态变量，根据网络的拥塞程度动画变化。</p><p>发送了超时重传，就认为网络出现拥塞</p><h2 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h2><p>慢启动：当发送方每收到一个ACK，拥塞窗口CWND的大小就加1。当没启动到ssthresh就使用拥塞避免算法</p><p>拥塞避免：每收到一个ACK时，CWND增加1&#x2F;CWND</p><p>拥塞发生：就出现数据包重传</p><p>​超时重传：ssthresh设为CWND&#x2F;2，CWND重置为1</p><p>​快速重传：CWND为原来的一半，ssthresh&#x3D;CWND，进入快速恢复算法</p><p>快速恢复：拥塞窗口CWND&#x3D;ssthresh+1；重传丢失的数据包；若重复收到ACK，CWND+1；收到新的ACK后，CWND就设置为第一步中的ssthresh的值，恢复到之前的状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;普通处理&quot;&gt;&lt;a href=&quot;#普通处理&quot; class=&quot;headerlink&quot; title=&quot;普通处理&quot;&gt;&lt;/a&gt;普通处理&lt;/h1&gt;&lt;p&gt;应用数据都被分割成TCP认为最适合发送的数据包&lt;/p&gt;
&lt;p&gt;  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三次握手</title>
    <link href="http://example.com/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>http://example.com/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2022-07-12T07:56:12.000Z</published>
    <updated>2022-07-17T07:54:28.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手简述"><a href="#三次握手简述" class="headerlink" title="三次握手简述"></a>三次握手简述</h1><p>目的是建立可靠的通信信道，也就是双方确认自己与对方发送与接收是正常的</p><p>TCP连接：用于保证可靠性和流浪控制维护的某些状态信息，包括socket、序列号和窗口大小</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><img src="/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/guocheng.png"></p><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端<strong>随机初始化序号</strong>，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以<em><strong>阻止重复历史连接的初始化</strong></em>（最主要，若是两次握手就不能判断，防止旧的重复连接初始化造成混乱，因为在网络拥塞下，旧的SYN比新的SYN先到服务端，那服务端就会回SYN+ACK）：若是历史连接，客户端发送的报文就是RST报文，表示终止这一次连接，反之则是ACK报文。先发的数据包不一定先到，所以客户端会通过上下文比较实际收到的ACK与期望收到的ACK。</p><p><em><strong>同步双方的初始序列号</strong></em>：</p><p>​序列号的作用：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发出去的数据包，哪些已被对方收到。</p><p>​两次握手只保证一方的初始化序列号能被对方成功接收，没办法保证双方</p><p>避免资源浪费：若服务端阻塞，客户端没有收到ACK就会发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：<strong>无法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立</strong>，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p><em><strong>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</strong></em></p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么客户端和服务端和初始序列号ICN是不同的若一个已经失效的连接被重用了，但旧连接的历史报文还残留在网络中，若序列号相同究就不能判断该报文是不是历史报文，历史报文被接收就会发生数据混乱。所以每次建立连接前重新初始化序列号是为了<em><strong>通信双方能根据序号将不属于本连接的报文丢弃</strong></em></p><p>SYN攻击：攻击者短时间伪造不同的IP地址的SYN报文，服务端每收到一个SYN报文，就进入下一个状态，但服务端发送的ACK+SYN报文无法得到IP的ACK应答，久而久之就沾满SYN接收队列（未连接队列），服务器就不能为正常的用户服务。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>​     客户端优化：修改SYN重传次数、调整客户端的三次握手时间上限。</p><p>​     服务端优化：调整SYN半连接队列大小，增大accept全连接队列大小</p><p>​     绕开三次握手：客户端从第二次向服务器建立连接之后。就减少了1个RTT时间的（客户端到服务器端的忘返时间）消耗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三次握手简述&quot;&gt;&lt;a href=&quot;#三次握手简述&quot; class=&quot;headerlink&quot; title=&quot;三次握手简述&quot;&gt;&lt;/a&gt;三次握手简述&lt;/h1&gt;&lt;p&gt;目的是建立可靠的通信信道，也就是双方确认自己与对方发送与接收是正常的&lt;/p&gt;
&lt;p&gt;TCP连接：用于保证可靠</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>进程调度算法</title>
    <link href="http://example.com/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2022-07-07T16:37:18.000Z</published>
    <updated>2022-07-07T16:55:11.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>无论是在批处理系统还是分时系统中，用户进程数一般都多用于处理机数，这将导致它们互相争夺处理。另外，系统进程也同样需要使用处理机。<br>这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><h1 id="7种调度算法"><a href="#7种调度算法" class="headerlink" title="7种调度算法"></a>7种调度算法</h1><h2 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h2><p>最简单的一种调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><p>算法思想：主要从“公平的角度考虑”</p><p>规则：按照作业&#x2F;进程到达的先后顺序进行服务</p><p>用于作业&#x2F;进程调度：用于作业调度时，考虑的是哪个作业先到达后备<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>；用于进程调度时，考虑的是哪个进程先到达就绪队列</p><p><strong>非抢占式的算法</strong></p><p><strong>优缺：</strong> 公平、算法实现简单<br><strong>缺点：</strong> 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利<br><strong>不会导致饥饿</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">周转时间=作业完成时间-作业提交时间</span><br><span class="line">平均周转时间=各作业周转时间之和 / 作业数</span><br><span class="line">带权周转时间=作业周转时间 / 作业实际运行的时间=（作业完成时间-作业提交时间）/ 作业实际运行的时间</span><br></pre></td></tr></table></figure><h2 id="短作业优先的调度算法（SJF）"><a href="#短作业优先的调度算法（SJF）" class="headerlink" title="短作业优先的调度算法（SJF）"></a>短作业优先的调度算法（SJF）</h2><p>从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。</p><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级</p><h2 id="时间⽚轮转调度算法-RR"><a href="#时间⽚轮转调度算法-RR" class="headerlink" title="时间⽚轮转调度算法(RR)"></a>时间⽚轮转调度算法(RR)</h2><p>时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许运⾏的时间。</p><h2 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h2><p>最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p><h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>根据比率：<em><strong>R&#x3D;(w+s)&#x2F;s</strong></em> （R为响应比，w为等待处理的时间，s为预计的服务时间）</p><p>如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p><p> 高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p><strong>根据公式可知：</strong></p><ul><li>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</li><li>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</li></ul><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</p><p>多级反馈队列调度算法的实现思想如下：</p><ol><li>应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</li><li>赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。</li><li>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</li><li>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;无论是在批处理系统还是分时系统中，用户进程数一般都多用于处理机数，这将导致它们互相争夺处理。另外，系统进程也同样需要使用处理机。&lt;br&gt;这就</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWiteArrayList</title>
    <link href="http://example.com/2022/07/04/CopyOnWiteAayList/"/>
    <id>http://example.com/2022/07/04/CopyOnWiteAayList/</id>
    <published>2022-07-04T11:01:41.000Z</published>
    <updated>2022-07-24T08:12:43.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>写数组的拷贝，<em><strong>支持高效率并发且是线程安全</strong></em>，读操作无锁的ArrayList。所有操作都是通过对底层进行一次新的复制实现</p><p>适用于读操作远远大于写操作的场景里。</p><p>存在扩容的概念，因为每次写操作都要复制一个副本，在副本的基础上修改后改变Aray引用。写操作需要大面积复制数组，所以性能很差</p><p><em><strong>读多写少</strong></em>的场景</p><h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><p>核心：创建新副本，读写分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;<span class="comment">//内部维护的数组</span></span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (E) a[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>直接通过下标访问数组，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有CAS操作。因为只是读，不会进行任何修改</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局的锁的状态</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当下（旧）的数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">//创建新的数组，并将旧的数组所有数据赋值到新的数组中</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//在末尾添加新的数据</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//将旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                    <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">            Object[] newElements;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index;</span><br><span class="line">            <span class="comment">//如果就是插入到末尾</span></span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//旧数组里的所有数据都赋值到新的数组</span></span><br><span class="line">                newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//声明新长度的数组</span></span><br><span class="line">                newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//以要插入的位置为分界线，把插入的下标的数据空出来</span></span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                 numMoved);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往index插入数据</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">//旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add方法采用ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份数据被复制的数组；因为一开始的数组引用时被volatile修饰，根据happens-beffore规则，写线程对数组引用的修改对读线程是可见的；</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="comment">//获取的数组中下标为index的数据值</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">            <span class="comment">//如果数组里该下标本身的值与需要设定的值不一样</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">                <span class="comment">//旧数组的值复制到新数组里</span></span><br><span class="line">                Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">                <span class="comment">//在下标为index处赋值</span></span><br><span class="line">                newElements[index] = element;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一样就不需要更改，直接修改旧数组的引用即可</span></span><br><span class="line">                <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove、removeRange与上面都类似</p><h2 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h2><p>读读共享、其他都互斥</p><p>读写锁规则的升级：读取时完全不用加锁的，并且更厉害的是，<em><strong>写入也不会阻塞读操作</strong></em></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>读多写少的场景，写即使慢一些也行</p><p>场景：黑名单、每日更新；监听看；迭代操作远多余修改操作</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>数据一致性问题：CopyOnWite容器只能<em><strong>保证数据的最终一致性</strong></em>，不能保证数据<em><strong>实时</strong></em>的一致性。所以，一旦写入不会马上就可以被读到</p><p>内容占用：因为通过复制机制开辟出一个新的副本，进行写操作时，内存里会同时驻扎两个对象的内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;写数组的拷贝，&lt;em&gt;&lt;strong&gt;支持高效率并发且是线程安全&lt;/strong&gt;&lt;/em&gt;，读操作无锁的ArrayList。所有操作都是通</summary>
      
    
    
    
    
    <category term="List" scheme="http://example.com/tags/List/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java线程安全的集合类</title>
    <link href="http://example.com/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://example.com/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2022-07-02T15:11:16.000Z</published>
    <updated>2022-07-02T15:18:56.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全的，它给几乎所有的public方法都加上了synchronized关键字，也正因为如此，加锁导致性能降低，在不需要并发访问同一对象时，这种强制性的同步机制就显得多余，所以现在Vector已被弃用。</p><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>HashTable和HashMap类似，不同点是HashTable是线程安全的，它给几乎所有public方法都加上了synchronized关键字，还有一个不同点是HashTable的K，V都不能是null，但HashMap可以，它现在也因为性能原因被弃用了。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Vector和HashTable被弃用后，它们被ArrayList和HashMap代替，但它们不是线程安全的，所以Collections工具类中提供了相应的包装方法把它们包装成线程安全的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Set&lt;E&gt; synHashSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Map&lt;K,V&gt; synHashMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K,V&gt;());</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步。</p><h1 id="Java-util-concurrent包中的集合"><a href="#Java-util-concurrent包中的集合" class="headerlink" title="Java.util.concurrent包中的集合"></a>Java.util.concurrent包中的集合</h1><h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h4><p>ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而ConcurrentHashMap是更细粒度的加锁。</p><p>在JDK1.8之前，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment含有整个table的一部分，这样不同分段之间的并发操作就互不影响。</p><p>JDK1.8对此做了进一步的改进，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</p><h4 id="2-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#2-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="2.CopyOnWriteArrayList和CopyOnWriteArraySet"></a>2.CopyOnWriteArrayList和CopyOnWriteArraySet</h4><p>它们是加了写锁的ArrayList和ArraySet，锁住的是整个对象，但读操作可以并发执行。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vector&quot;&gt;&lt;a href=&quot;#Vector&quot; class=&quot;headerlink&quot; title=&quot;Vector&quot;&gt;&lt;/a&gt;Vector&lt;/h1&gt;&lt;p&gt;vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Autowired和Resource</title>
    <link href="http://example.com/2022/06/25/Autowired%E5%92%8CResource/"/>
    <id>http://example.com/2022/06/25/Autowired%E5%92%8CResource/</id>
    <published>2022-06-25T13:40:50.000Z</published>
    <updated>2022-06-25T14:34:00.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>@Auwired：</p><p>对成员变量、方法及构造函数进行标注，完成自动装配的工作</p><p>@Resource：</p><p>​官方定义：在语义上被定义为通过其唯一的名称来标识特定的目标组件，其中声明的类型与匹配过程无关</p><p>​若没有明确指定名称，则默认名称是从字段名称或设置方法（get、set方法）派生的。若用在字段上，则采用字段名称；如果用在setter方法，它采用其属性名称（例如setProperty()方法，取property作为属性名称）    </p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>包含的属性不同：</p><p>​Autowired只包含一个参数：required，表示是否开启自动注入，默认是true</p><p>​Resource有七个参数，其中最重要的两个参数：name和type</p><p>注解使用的地方不同：</p><p>​Autowired可以用在构造方法、方法、参数、成员变量和注解上</p><p>​Resource可以用在类、成员变量、方法上</p><p>出处不同：</p><p>​Autowired是Spring定义的注解，所以只能用在Spring框架下</p><p>​Resource是JSR-250定义的注解，所以可以与其他框架一起使用</p><p>自动装配的方式不同：</p><p>​Autowired默认按byType，如果要使用byName，需要结合@Qualifier注解配合使用</p><p>​Resource默认byName自动装配，如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配</p><p>自动装配的顺序：</p><p>​Autowired：默认先按byTpe进行匹配，若发现找到多个bean则又按照byName方式进行匹配，如果还有多个，则抛出异常</p><p>​<img src="/2022/06/25/Autowired%E5%92%8CResource/A.png" alt="image-20220625222414253"></p><p>​Resource：</p><p>​若同时指定了name和type：会从容器中查找name和type唯一匹配bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了name：则按name后的名字去bean元素里查找有与之相等的name属性的bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了type：则从上下文汇总找到类型匹配的<em><strong>唯一</strong></em>bean进行装配，找不到或者找到多个，都会抛出异常</p><p>​都没有指定：自动按照byName方式找，若没有找到符合的bean，则回退为一个原始类型进行查找，如果找到就注入，没找到或者找到多个则抛出异常</p><p>​</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;@Auwired：&lt;/p&gt;
&lt;p&gt;对成员变量、方法及构造函数进行标注，完成自动装配的工作&lt;/p&gt;
&lt;p&gt;@Resource：&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="http://example.com/2022/06/16/Shiro/"/>
    <id>http://example.com/2022/06/16/Shiro/</id>
    <published>2022-06-16T07:20:29.000Z</published>
    <updated>2022-06-16T08:28:04.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/06/16/Shiro/jiegou1.png" alt="image-20220616152612753"></p><p><strong>Subject</strong>：主体，外部应用与subject进行交互，subject记录当前的用户。外部程序通过subject进行认证权限，subject通过Security Manager安全管理进行认证</p><p><strong>Security Manager</strong>：对全部subject进行安全管理，核心。可以对subjectManager完成subject的认证、授权，实质上是通过Authenticator</p><p>本身是一个接口，继承了Authenticator、Authorizer、SessionManager三个接口</p><p><strong>Authenticator</strong>：认证器，对用户身份进行认证，本身是一个接口，shiro提供ModularRealmAuthenticator的实现类，可以满足大部分需求</p><p><strong>Authorizer</strong>：授权器，用户通过授权器，用户通过认证器通过，在访问功能时需要通过授权器判断用户是否能操作的权限</p><p><strong>Realm</strong>：就相当于datasource数据源，subjectManager进行安全认证需要通过Realm获取用户权限数据</p><p><strong>SessionManager</strong>：会话管理，shiro定义了一套会话管理，不依赖web容器的session</p><p><strong>CacheManager</strong>：缓存管理，将用户的权限数据存储在缓存</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>即身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确</p><p>Subject：访问系统的用户，主体可以是用户、程序等</p><p>Principal：身份信息，是主体进行身份认证的标识，标识必须具有唯一性，一个主体可以有多个身份，但必须有一个主身份</p><p>credential：凭证信息，是只有主体自己知道的安全信息</p><h1 id="权限字符串"><a href="#权限字符串" class="headerlink" title="权限字符串"></a>权限字符串</h1><p>资源标识符：操作：资源实例标识符    对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用*通配符。</p><p>比如：用户创建权限   user:create  或 user:create:*</p><p>​用户实例001的所有权限 user:*:001</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><em><strong>以下所有代码来源于“编程不良人”</strong></em></p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 授权</span></span><br><span class="line"><span class="comment">     * @param principals</span></span><br><span class="line"><span class="comment">     * @return AuthorizationInfo</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">//获取身份信息 内容根据实际情况(看源码了解)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">primaryPrincipal</span> <span class="operator">=</span> (String) principals.getPrimaryPrincipal();</span><br><span class="line">        System.out.println(<span class="string">&quot;PrincipalCollection      &quot;</span>+primaryPrincipal);</span><br><span class="line">        <span class="comment">//从工厂中获取service对象</span></span><br><span class="line">        <span class="comment">//根据主身份信息获取角色 和 权限信息</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils</span><br><span class="line">                .getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="comment">//根据userService找到用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findRolesByUserName(primaryPrincipal);</span><br><span class="line">        <span class="comment">//授权角色信息</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(user.getRoles()))&#123;</span><br><span class="line">            <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">            user.getRoles().forEach(role-&gt;&#123;</span><br><span class="line">                <span class="comment">//从数据库中查出来的权限给该对象</span></span><br><span class="line">                simpleAuthorizationInfo.addRole(role.getName());</span><br><span class="line">                <span class="comment">//从数据库中角色具备的权限信息</span></span><br><span class="line">                List&lt;Perms&gt; perms = userService.findPermsByRoleId(role.getId());</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(perms))&#123;</span><br><span class="line">                    perms.forEach(perm-&gt;&#123;</span><br><span class="line">                        <span class="comment">//对该角色赋予相应的权限</span></span><br><span class="line">                        simpleAuthorizationInfo.addStringPermission(perm.getName());</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 身份认证,主体调用用户登录时，会调用该方法</span></span><br><span class="line"><span class="comment">     * @param token</span></span><br><span class="line"><span class="comment">     * @return AuthenticationInfo 里面收集用户提交的身份（比如：用户名）和凭据（比如：密码）</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取身份信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> (String) token.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">credentials</span> <span class="operator">=</span> (String) token.getCredentials();</span><br><span class="line">        <span class="comment">//在工厂中获取service对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUserName(principal);</span><br><span class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(user))&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   用户名</span></span><br><span class="line"><span class="comment">            *   加密的密码</span></span><br><span class="line"><span class="comment">            *   随机盐</span></span><br><span class="line"><span class="comment">            *   当前realm的名称</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user.getUsername(),user.getPassword(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MyByteSource</span>(user.getSalt()),</span><br><span class="line">                    <span class="built_in">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="doGetAuthenticationInfo中的principal和credentials的来源"><a href="#doGetAuthenticationInfo中的principal和credentials的来源" class="headerlink" title="doGetAuthenticationInfo中的principal和credentials的来源"></a>doGetAuthenticationInfo中的principal和credentials的来源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password,String code,HttpSession session)</span> &#123;</span><br><span class="line">       <span class="comment">//比较验证码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">codes</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (codes.equalsIgnoreCase(code))&#123;</span><br><span class="line">               <span class="comment">//获取主体对象</span></span><br><span class="line">               <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">               <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">               <span class="comment">//  重点  重点</span></span><br><span class="line">               <span class="comment">//将该UsernamePasswordToken类对象作为token专递给doGetAuthenticationInfo</span></span><br><span class="line">               subject.login(token);</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码错误!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;用户名错误!&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;密码错误!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/user/loginview&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="UsernamePasswordToken源码"><a href="#UsernamePasswordToken源码" class="headerlink" title="UsernamePasswordToken源码"></a>UsernamePasswordToken源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordToken</span> <span class="keyword">implements</span> <span class="title class_">HostAuthenticationToken</span>, RememberMeAuthenticationToken &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> rememberMe;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"><span class="comment">//省去了所有构造方法以及所有set方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] getPassword() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过该方法得到的username</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRememberMe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rememberMe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.host = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.rememberMe = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.password != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.password.length; ++i) &#123;</span><br><span class="line">                <span class="built_in">this</span>.password[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.password = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义的realm进行操作的配置"><a href="#自定义的realm进行操作的配置" class="headerlink" title="自定义的realm进行操作的配置"></a>自定义的realm进行操作的配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroDialect&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建shiroFilter  //负责拦截所有请求</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager defaultWebSecurityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//给filter设置安全管理器</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   可以实现权限相关的拦截器</span></span><br><span class="line"><span class="comment">         *       常用:</span></span><br><span class="line"><span class="comment">         *           anon:无需认证(登录)也已访问</span></span><br><span class="line"><span class="comment">         *           authc:必须认证和授权才可以访问</span></span><br><span class="line"><span class="comment">         *           user:若使用rememberMe的功能可以直接访问</span></span><br><span class="line"><span class="comment">         *           perms:该资源必须资源权限才可以访问</span></span><br><span class="line"><span class="comment">         *           role：该资源必须得到角色权限</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//配置系统受限资源</span></span><br><span class="line">        <span class="comment">//配置系统公共资源</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/getImage&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/register&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/registerview&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);<span class="comment">//authc 请求这个资源需要认证和授权</span></span><br><span class="line">        <span class="comment">//默认认证界面路径,没有登录的用户就都可以访问的</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/user/loginview&quot;</span>);</span><br><span class="line">        <span class="comment">//放在过滤链里面</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="comment">//未授权的</span></span><br><span class="line">        <span class="comment">//shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建安全管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(Realm realm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//给安全管理器设置</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建自定义realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Realm <span class="title function_">getRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CustomerRealm</span> <span class="variable">customerRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerRealm</span>();</span><br><span class="line">        <span class="comment">//修改凭证校验匹配器</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//设置加密算法为md5</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">//设置散列次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//放入realm</span></span><br><span class="line">        customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="comment">//开启缓存管理，用redis缓存信息</span></span><br><span class="line">        customerRealm.setCacheManager(<span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>());</span><br><span class="line">        customerRealm.setCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启全局缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCachingEnabled(<span class="literal">true</span>);<span class="comment">//认证认证缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCacheName(<span class="string">&quot;authenticationCache&quot;</span>);</span><br><span class="line">        customerRealm.setAuthorizationCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启授权缓存</span></span><br><span class="line">        customerRealm.setAuthorizationCacheName(<span class="string">&quot;authorizationCache&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customerRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的RediscacheManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title class_">CacheManager</span> &#123;</span><br><span class="line">    <span class="comment">//参数1:认证或者是授权缓存的统一名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; Cache&lt;K, V&gt; <span class="title function_">getCache</span><span class="params">(String cacheName)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;redis Cache      &quot;</span>+cacheName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCache</span>&lt;K,V&gt;(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现redis作为缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span>&lt;k,v&gt; <span class="keyword">implements</span> <span class="title class_">Cache</span>&lt;k,v&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cacheName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">(String cacheName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheName = cacheName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get              &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;get key:&quot;</span>+k);</span><br><span class="line">        System.out.println( <span class="string">&quot;redis  get value     &quot;</span>+getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString()));</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">put</span><span class="params">(k k, v v)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;put           &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;put key: &quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;put value:&quot;</span>+v);</span><br><span class="line">        getRedisTemplate().opsForHash().put(<span class="built_in">this</span>.cacheName,k.toString(),v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">remove</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============remove=============&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().delete(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;=============clear==============&quot;</span>);</span><br><span class="line">        getRedisTemplate().delete(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().size(<span class="built_in">this</span>.cacheName).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;k&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().keys(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;v&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().values(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate <span class="title function_">getRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用于接口（接口式）"><a href="#作用于接口（接口式）" class="headerlink" title="作用于接口（接口式）"></a>作用于接口（接口式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@RequiresRoles(value=&#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span><span class="comment">//用来判断角色  Logical.OR:满足其中一个就行   logical = Logical.AND:要同时满足</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;user:update:01&quot;)</span> <span class="comment">//用来判断权限字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入方法多个&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用于接口（编程式）"><a href="#作用于接口（编程式）" class="headerlink" title="作用于接口（编程式）"></a>作用于接口（编程式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">save1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">       <span class="keyword">if</span> (subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">           <span class="comment">//有权限</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有权限</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外还有标签式，因采用前后端分离，便不再展示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应</summary>
      
    
    
    
    <category term="权限框架" scheme="http://example.com/categories/%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
