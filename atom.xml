<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小二小二不停步</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-17T06:38:46.438Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小二小二不停步</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Http1.0-3.0</title>
    <link href="http://example.com/2022/07/17/Http1-0-3-0/"/>
    <id>http://example.com/2022/07/17/Http1-0-3-0/</id>
    <published>2022-07-17T06:35:00.000Z</published>
    <updated>2022-07-17T06:38:46.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="HTTP1-0和1-1"><a href="#HTTP1-0和1-1" class="headerlink" title="HTTP1.0和1.1"></a>HTTP1.0和1.1</h4><p>HTTP&#x2F;1.0性能上，每发起一个请求都要新建一次TCP连接（三次握手），而且是串行，做了没有用TCP连接和断开</p><p>长连接：HTTP&#x2F;1.1采取的，只要任意一端没有明确的提出断开连接，则保持TCP连接状态</p><p>错误状态响应码：1.1中新增加了24个错误状态响应码</p><p>缓存处理：1.1引用了更多缓存控制策略</p><p> 1.1的性能：<em><strong>长连接、管道网络传输、队头阻塞</strong></em></p><p>管道网络传输：在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不用等其回来，就可以发第二个请求出去</p><p>队头阻塞：顺序发送的请求序列中，一个请求因为某种原因被阻塞时，后面排队的所有请求都阻塞了</p><p><img src="/http1-0-3-0/1.0-1.1.png" alt="image-20220709114337819"></p><p>HTTP1.1的瓶颈：</p><p>最大的问题就是高延迟：因为延迟难以下降；并发连接优先；队头阻塞；HTTP头部巨大且重复；不支持服务器推送消息</p><ul><li>请求&#x2F;响应头部未经压缩就发送，首部信息越多，延迟越大。只能压缩body部分</li><li>发送冗长的首部。每次都发送相同的首部浪费较多</li><li>没有请求优先级</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h5 id="HTTP1-1-优化"><a href="#HTTP1-1-优化" class="headerlink" title="HTTP1.1 优化"></a>HTTP1.1 优化</h5><p>尽量避免HTTP请求（缓存技术）</p><p>在需要发HTTP请求，减少次数（减少重定向，合并请求，延迟发送）</p><p>​收到合并请求就是合并资源，以一个大资源的请求替换多个小资源的请求；当大资源中的小资源发生变化，客户端就要重新下载整个完整的大资源</p><p>​     延迟发送：只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源</p><p>减少服务器的HTTP响应大小</p><h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h4><p>通过<em><strong>静态表和哈夫曼编码</strong></em>的方式，将体积压缩了近一半，针对后续的请求头部也可建立动态表（会占用内存而影响并发能力）</p><p>  <em><strong>实现了Stream并发，多个Stream只需复用一个TCP连接，节约了TCP和TLS握手时间，以及减少了TCP慢启动阶段对流量的影响。</strong></em></p><p>  服务器支持主动推送资源，大大提升了消息的传输信息</p><p>  HTTP&#x2F;2是基于TCP协议来传输数据，TCP层必须保证收到的字节数据是完成且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用。有队头阻塞问题，TCP和TLS的握手时延迟，网络迁移需要重新连接</p><h5 id="相比于HTTP-x2F-1-1的改进"><a href="#相比于HTTP-x2F-1-1的改进" class="headerlink" title="相比于HTTP&#x2F;1.1的改进"></a>相比于HTTP&#x2F;1.1的改进</h5><p>&#x3D;&#x3D;头部压缩&#x3D;&#x3D;：会压缩头，若头一样，会消除重复的部分</p><p>&#x3D;&#x3D;二进制格式&#x3D;&#x3D;：全面采用二进制格式并同城为帧（头信息帧，数据帧）。对计算机友好，提高传输效率</p><p><img src="/http1-0-3-0/1.0-1.1-2.png" alt="image-20220709152032970"></p><p>&#x3D;&#x3D;数据流&#x3D;&#x3D;：数据包不是按顺序发送，每个请求或回应的所有数据包称为数据流。每个数据流里面有独一无二的编号，客户端发送的编号为奇数，服务器端发送的为偶数。多个stream复用一个TCP达到并发效果</p><p>&#x3D;&#x3D;多路复用&#x3D;&#x3D;：2.0是可以在一个连接中并发多个请求或回应，而不用按顺序对应</p><p>&#x3D;&#x3D;服务器推送&#x3D;&#x3D;：服务器也可以主动向客户端发</p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>因为多个HTTP都在复用一个TCP链接，所以一旦发生丢包，都会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求就必须这个丢的包被传回来</p><h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><p>传输层的TCP换成UDP，并在UDP协议开发了QUIC协议保证了数据的可靠传输。</p><p>QUIC</p><p>  无队头阻塞</p><p>  建立连接速度块</p><p>  连接迁移</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;发展&quot;&gt;&lt;a href=&quot;#发展&quot; class=&quot;headerlink&quot; title=&quot;发展&quot;&gt;&lt;/a&gt;发展&lt;/h3&gt;&lt;h4 id=&quot;HTTP1-0和1-1&quot;&gt;&lt;a href=&quot;#HTTP1-0和1-1&quot; class=&quot;headerlink&quot; title=&quot;HTT</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://example.com/2022/07/16/IP/"/>
    <id>http://example.com/2022/07/16/IP/</id>
    <published>2022-07-15T17:45:22.000Z</published>
    <updated>2022-07-16T06:41:24.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><p>网络层，<em><strong>实现主机与主机之间的通信，点对点通信</strong></em></p><p>MAC（数据链路层）是实现 直连 两个设备之间通信，IP是在没有直连的两个网络之间进行通信传输。个人理解：计划和实施的区别。IP是整个旅游行程表，MAC是行程表里的交通工具。</p><p>&#x3D;&#x3D;源IP地址和目标IP地址不会变化，只有源MAC地址和目标MAC一直在变化&#x3D;&#x3D;</p><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><p>IP地址（IPv4地址）32位，在计算机中二进制方式处理。点分十进制的标记方式处理</p><p>分类：A,B,C,D,E类</p><p>A（0<del>127.255.255.255）,B（128</del>191.255.255.255）,C（192~223）主要两部分，网络号和主机号（比如：A小区1栋101号和B小区1栋101号）</p><p>A,B,C类中有私有IP和公有IP区分</p><p>解析IP地址，看第一个0出现在哪一位。在第一位是A类，第二为是B类，依次类推</p><p>广播地址</p><p>用于在同一个链路中互相连接的主机之间发送的数据包</p><p>​    分为：本地广播（本网络内广播）和直接广播（不同网络间的广播）</p><p>D类和E类地址没有主机号，不可用于主机IP。</p><p>D类常用于多播，E类是预留的分类，暂未使用</p><p>多播地址</p><p>​    用于将包发送给特定组内的所有主机</p><h3 id="IPV4分类的优缺点"><a href="#IPV4分类的优缺点" class="headerlink" title="IPV4分类的优缺点"></a>IPV4分类的优缺点</h3><p>优点：简单明了、选路（基于网络地址）简单</p><p>缺点：同一网络下没有地址层次，就缺少地址的灵活性；不能很好与现实网路匹配</p><p>两个缺点都可在CIDR无分类地址解决：前面是网络号，后面是主机号</p><p>​    以a.b.c.d&#x2F;x形式表示，比如10.100.122.2&#x2F;24: &#x2F;24表示前24位是网络号，剩余是主机号。</p><h2 id="问点"><a href="#问点" class="headerlink" title="问点"></a>问点</h2><p>为什么要分离网络号和主机号：两台计算机要通讯，首先判断是否处于同一个广播域内，即网络地址是否相同。若相同，表名接收方在本网络上，数据包就可以发送到目标主机</p><p>怎么划分子网：子网掩码的作用之一就是划分子网，将主机地址分为 子网网络地址和子网主机地址</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>是128位，与v4比，可分配的地址变多；可自动装配；包头包首部长度固定的40字节，去掉包头检验和，简化了首部结构，减轻了路由器符合，提高传输的性能；可伪造IP地址的网络安全，防止窃听，提升了安全性</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>单播地址：一对一通信；</p><p>组播地址：一对多通信；</p><p>任播地址：通信最近的节点，最近的节点由路由协议决定</p><p>没有广播地址</p><h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS：可将域名网址自动转换成具体的IP地址。越靠右，层级越高</p><p>层级关系：根DNS服务器，顶级域DNS服务器，权威DNS服务器</p><p>解析流程：</p><p>客户端发送DNS请求，并发给本地DNS解析器；本地域名解析器收到请求后，若缓存中能找到就直接返回IP地址，反之本地DNS会去问它的根域名服务器；根DNS收到请求后，发现后置是.com，就给本地DNS关于顶级域名服务器的地址；本地DNS收到后再发请求给顶级域名服务器，顶级域名服务器就返回权威域名服务器的地址；本地收到后，发送权威域名服务器请求，权威域名查询后将IP地址告诉给本地DNS。本地DNS将得到的IP地址返回给客户端，客户端建立连接</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在传输IP数据包的时候，确定了源IP和目标IP后，就通过路由表确定IP数据包下一跳、因为网络层下面是数据链路层，所以要知道下一跳的MAC地址。</p><p>因为主机路由表可找到下一跳的IP地址，所以可通过ARP协议，求下一跳MAC地址</p><p>即已知IP地址求MAC地址</p><p>ARP就是借助ARP请求域ARP响应两种类型确定MAC地址</p><p>主机通过广播发送ARP请求（里面有想知道的MAC地址的主机IP地址）；同个链路中所有设备收到ARP请求时，会自动拆开ARP里的内容，若里面的IP地址与自己的一致就将自己MAC地址放入ARP响应包返回给主机</p><p>操作系统会把第一次获取的MAC地址缓存起来（有期限）。</p><p>RARP：已知MAC地址求IP地址。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态获取IP地址，省去了配IP信息繁琐过程</p><p>步骤：</p><p>​    客户端发起DHCP发现报文的IP数据报（用的UDP广播通信，因IP地址、DHCP服务器地址都不知道），并用0.0.0.0作为源IP地址，255.255.255.255为广播目的地址。DHCP客户端将该IP数据包传给MAC，MAC再将帧广播到所有网络设备中</p><p>​    DHCP服务器收到DHCP报文时向客户端响应，里面包含IP地址、子网掩码等信息。客户端收到一个或多个服务器的DHCP提供报文后，选择一个服务器，并对其发送DHCP请求报文进行响应，回显配置的参数。服务端用DHCP ACK报文进行响应，回应其要求的参数</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>网络地址转换NAT，缓解IPV4地址耗尽的问题</p><p>简单说就是在主机对外通信时，把私有IP地址转换成公有IP地址</p><p>缺点：外部无法主动与NAT内部服务器建立连接，因NAPT转换表没有转换记录；转换表的生成与转换操作会产生性能开销；通信过程中，若NAT路由器重启了，所有TCP链接将重置</p><p>解决：改用IPV6；NAT穿透技术</p><h3 id="ICMP（互联网控制报文协议）"><a href="#ICMP（互联网控制报文协议）" class="headerlink" title="ICMP（互联网控制报文协议）"></a>ICMP（互联网控制报文协议）</h3><p>主要功能：确认IP包是否到达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置</p><p>分类</p><p>​    查询报文类型：诊断查询信息</p><p>​    差错报文类型：通知出错原因的错误信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h1&gt;&lt;p&gt;网络层，&lt;em&gt;&lt;strong&gt;实现主机与主机之间的通信，点对点通信&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;MAC（数据</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="IP" scheme="http://example.com/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>四次挥手</title>
    <link href="http://example.com/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://example.com/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2022-07-14T15:54:24.000Z</published>
    <updated>2022-07-14T15:57:43.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；</p><p>当服务器端收到FIN后，发送ACK应答报文，服务端就进入close_wait状态，</p><p>客户端收到ACK应答报文后，进入FIN_WAIT_2状态</p><p>服务端做最后的数据处理（读到结束符EOF）已发送完成，则向客户端发FIN报文，服务端就进入LAST_ACK状态 ；</p><p>客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传），就进入TIME_WAIT状态；</p><p>服务器端收到ACK就关闭（CLOASE状态），客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/guocheng.png"></p><h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><p>关闭连接时，客户端向服务端发送FIN后，表示客户端不再发数据，但是能接收数据</p><p>服务端收到FIN后，先回ACK应答，但可能还有数据处理和发送不能立马关闭socket，等不再发数据后，才发FIN表示同意现在关闭连接。</p><p>所以，服务端需要等待完成数据的发送和处理，ACK和FIN一般都会分开发送，所以多一次</p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么TIME_WAIT等待时间是2MSL：是报文最大生存时间，超过这个时间报文将被丢弃。因为TCP报文基于IP协议的，IP头部中有一个TTL字段，是IP数据报可以经过最大路由数，<em><strong>MSL要  &amp;ge; TTL消耗为0的时间</strong></em>。2MSL是从<em><strong>客户端收到FIN后发送ACK开始计时的</strong></em>，若客户端的ACK没有传到服务端，客户端就又会收到来自服务端的FIN报文，那么2MSL将重新计时</p><p>为什么需要TIME_WAIT：主动发起关闭连接的一方才会有TIME-WAIT状态。需要TIME-WAIT状态，是<em><strong>防止接收到具有相同的四元组出现的旧数据包</strong></em>，2MSL足以上两个方向上数据包都被丢掉，保证出现的数据包一定是建立连接时所产生的；保证连接能正确关闭：给出足够的时间确保最后的ACK能让被动关闭方接收</p><p>TIME_WAIT过多的危害：内存资源占用；端口资源的占用，一个TCP连接至少消耗一个本地端口，若沾满了所有端口，就不能创建新链接</p><p>若已建立了链接，但客户端突然故障：</p><p>​TCP的&#x3D;&#x3D;保活机制&#x3D;&#x3D;：定义一个时间段，该时间段内，若没有任何连接相关的活动，TCP保活机制就会开始作用，每隔一个时间段就发探测报文（数据很少），若连续几个探测报文没有回应，则认为当前TCP连接已死亡，系统内核就将错误信息通知给上层应用</p><p>​对端程序工作正常：TCP保活的探测报文，对端会正常响应，TCP保活时间会被重置</p><p>​对端程序崩溃并重启：发探测报文，对端可响应，但是没有该连接的有效信息，会产生一个RST报文，就很块发现TCP连接已被重置</p><p>​对端程序崩溃或其他原因让报文能不到达：探测报文不能得到响应，TCP会报告该TCP连接已死亡</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>四次挥手优化</p><p>​    主动方优化：发FIN报文的方式有close和shutdown，所以发送更改方式。调整FIN重传次数。调整状态时间和孤儿连接的上限个数。</p><p>   被动方优化：复用time_wait状态的连接（只使用于客户端）</p><p>Close：断开后，不能传输数据也不能发数据。</p><p>Shutdown：控制只关闭一个方向的连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要流程&quot;&gt;&lt;a href=&quot;#主要流程&quot; class=&quot;headerlink&quot; title=&quot;主要流程&quot;&gt;&lt;/a&gt;主要流程&lt;/h1&gt;&lt;p&gt;客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP怎么保证可靠传输</title>
    <link href="http://example.com/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <id>http://example.com/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</id>
    <published>2022-07-13T12:17:56.000Z</published>
    <updated>2022-07-13T12:29:59.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="普通处理"><a href="#普通处理" class="headerlink" title="普通处理"></a>普通处理</h1><p>应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传送</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；</p><p>TCP会在<strong>数据包丢失和确认应答丢失后发生超时重传</strong></p><p>设置的时间RTO：RTO太大，重发慢，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时。所以，设置的RTO应该略大于报文忘返RTT的值</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>以<em><strong>数据驱动重传</strong></em>。收到三个相同ACK报文时，会在定时器过期之前，重传文段。</p><p>只解决了超时时间的问题，有另一个问题：重传的时候，是重传一个，还是重传之前的所有，所以就有了SACK方法</p><h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p>在TCP头部的“选项”字段中添加一个SACK，<em><strong>将缓存的地图发送给发送方</strong></em>，发送方就知道哪些数据收到了，哪些没有，就可以<em><strong>只传丢失的数据</strong></em>、</p><h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p>使用了SACK告诉 发送方，有哪些数据被重复接收了。</p><p>可以让发送方知道，是发出去的包丢了；可以知道是不是发送方的数据包被网略延时了；可以知道网络中是不是把发送方的数据包给复制了</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>TCP是每发一个数据，收到回应后再发下一个，数据包忘返时间长，通信效率低。</p><p>发送方会定时发送窗口大小探测报文，及时知道接收方窗口大小辩护</p><p>窗口大小就是指<em><strong>无需等待确认应答，可以继续发送数据的最大值</strong></em></p><p>大小在TCP头部，该字段是接收端告诉发送端自己有多少缓冲区可接收数据，发送端根据这个发送数据</p><p>接收窗口和发送窗口大小不完全相等：接收窗口大小约等于发送窗口大小。因为滑动窗口大小不是一成不变，若接收方的程序读取数据很快，接收的滑动窗口就会空出来。那么新的接收窗口大小，是通过TCP头部的窗口大小字段告诉发送方，传输存在时延，所以两者是约等于的关系</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率，根据接收方的实际接收能力变化</p><p>窗口关闭：窗口大小为0，就会阻止发送方传递数据，直到窗口非0。当窗口关闭时，接收方处理完数据后会发送一个窗口非0的ACK报文，若该报文丢失，那会出现问题</p><p>​解决窗口关闭时潜在的死锁现象：TCP为每一个连接设置定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器。该计时器若超时，就发送窗口探测报文，对方在确认该探测报文时会给出自己的窗口大小</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>目的是<em><strong>避免发送方的数据填满整个网络</strong></em></p><p>拥塞窗口是发送方维护的一个状态变量，根据网络的拥塞程度动画变化。</p><p>发送了超时重传，就认为网络出现拥塞</p><h2 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h2><p>慢启动：当发送方每收到一个ACK，拥塞窗口CWND的大小就加1。当没启动到ssthresh就使用拥塞避免算法</p><p>拥塞避免：每收到一个ACK时，CWND增加1&#x2F;CWND</p><p>拥塞发生：就出现数据包重传</p><p>​超时重传：ssthresh设为CWND&#x2F;2，CWND重置为1</p><p>​快速重传：CWND为原来的一半，ssthresh&#x3D;CWND，进入快速恢复算法</p><p>快速恢复：拥塞窗口CWND&#x3D;ssthresh+1；重传丢失的数据包；若重复收到ACK，CWND+1；收到新的ACK后，CWND就设置为第一步中的ssthresh的值，恢复到之前的状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;普通处理&quot;&gt;&lt;a href=&quot;#普通处理&quot; class=&quot;headerlink&quot; title=&quot;普通处理&quot;&gt;&lt;/a&gt;普通处理&lt;/h1&gt;&lt;p&gt;应用数据都被分割成TCP认为最适合发送的数据包&lt;/p&gt;
&lt;p&gt;  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三次握手</title>
    <link href="http://example.com/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>http://example.com/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2022-07-12T07:56:12.000Z</published>
    <updated>2022-07-12T08:01:08.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手简述"><a href="#三次握手简述" class="headerlink" title="三次握手简述"></a>三次握手简述</h1><p>目的是建立可靠的通信信道，也就是双方确认自己与对方发送与接收是正常的</p><p>TCP连接：用于保证可靠性和流浪控制维护的某些状态信息，包括socket、序列号和窗口大小</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><img src="/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/guocheng.png"></p><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端<strong>随机初始化序号</strong>，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以<em><strong>阻止重复历史连接的初始化</strong></em>（最主要，若是两次握手就不能判断，防止旧的重复连接初始化造成混乱）：若是历史连接，客户端发送的报文就是RST报文，反之则是ACK报文</p><p><em><strong>同步双方的初始序列号</strong></em>：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发出去的数据包，哪些已被对方收到</p><p>避免资源浪费：若服务端阻塞，发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：<strong>无法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立</strong>，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p><em><strong>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</strong></em></p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么客户端和服务端和初始序列号ICN是不同的若一个已经失效的连接被重用了，但旧连接的历史报文还残留在网络中，若序列号相同究就不能判断该报文是不是历史报文，历史报文被接收就会发生数据混乱。所以每次建立连接前重新初始化序列号是为了<em><strong>通信双方能根据序号将不属于本连接的报文丢弃</strong></em></p><p>SYN攻击：攻击者短时间伪造不同的IP地址的SYN报文，服务端每收到一个SYN报文，就进入下一个状态，但服务端发送的ACK+SYN报文无法得到IP的ACK应答，久而久之就沾满SYN接收队列（未连接队列），服务器就不能为正常的用户服务。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>​     客户端优化：修改SYN重传次数、调整客户端的三次握手时间上限。</p><p>​     服务端优化：调整SYN半连接队列大小，增大accept全连接队列大小</p><p>​     绕开三次握手：客户端从第二次向服务器建立连接之后。就减少了1个RTT时间的（客户端到服务器端的忘返时间）消耗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三次握手简述&quot;&gt;&lt;a href=&quot;#三次握手简述&quot; class=&quot;headerlink&quot; title=&quot;三次握手简述&quot;&gt;&lt;/a&gt;三次握手简述&lt;/h1&gt;&lt;p&gt;目的是建立可靠的通信信道，也就是双方确认自己与对方发送与接收是正常的&lt;/p&gt;
&lt;p&gt;TCP连接：用于保证可靠</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>进程调度算法</title>
    <link href="http://example.com/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2022-07-07T16:37:18.000Z</published>
    <updated>2022-07-07T16:55:11.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>无论是在批处理系统还是分时系统中，用户进程数一般都多用于处理机数，这将导致它们互相争夺处理。另外，系统进程也同样需要使用处理机。<br>这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><h1 id="7种调度算法"><a href="#7种调度算法" class="headerlink" title="7种调度算法"></a>7种调度算法</h1><h2 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h2><p>最简单的一种调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><p>算法思想：主要从“公平的角度考虑”</p><p>规则：按照作业&#x2F;进程到达的先后顺序进行服务</p><p>用于作业&#x2F;进程调度：用于作业调度时，考虑的是哪个作业先到达后备<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>；用于进程调度时，考虑的是哪个进程先到达就绪队列</p><p><strong>非抢占式的算法</strong></p><p><strong>优缺：</strong> 公平、算法实现简单<br><strong>缺点：</strong> 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利<br><strong>不会导致饥饿</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">周转时间=作业完成时间-作业提交时间</span><br><span class="line">平均周转时间=各作业周转时间之和 / 作业数</span><br><span class="line">带权周转时间=作业周转时间 / 作业实际运行的时间=（作业完成时间-作业提交时间）/ 作业实际运行的时间</span><br></pre></td></tr></table></figure><h2 id="短作业优先的调度算法（SJF）"><a href="#短作业优先的调度算法（SJF）" class="headerlink" title="短作业优先的调度算法（SJF）"></a>短作业优先的调度算法（SJF）</h2><p>从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。</p><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级</p><h2 id="时间⽚轮转调度算法-RR"><a href="#时间⽚轮转调度算法-RR" class="headerlink" title="时间⽚轮转调度算法(RR)"></a>时间⽚轮转调度算法(RR)</h2><p>时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许运⾏的时间。</p><h2 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h2><p>最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p><h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>根据比率：<em><strong>R&#x3D;(w+s)&#x2F;s</strong></em> （R为响应比，w为等待处理的时间，s为预计的服务时间）</p><p>如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p><p> 高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p><strong>根据公式可知：</strong></p><ul><li>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</li><li>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</li></ul><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</p><p>多级反馈队列调度算法的实现思想如下：</p><ol><li>应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</li><li>赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。</li><li>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</li><li>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;无论是在批处理系统还是分时系统中，用户进程数一般都多用于处理机数，这将导致它们互相争夺处理。另外，系统进程也同样需要使用处理机。&lt;br&gt;这就</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWiteArrayList</title>
    <link href="http://example.com/2022/07/04/CopyOnWiteAayList/"/>
    <id>http://example.com/2022/07/04/CopyOnWiteAayList/</id>
    <published>2022-07-04T11:01:41.000Z</published>
    <updated>2022-07-04T11:47:10.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>写数组的拷贝，<em><strong>支持高效率并发且是线程安全</strong></em>，读操作无锁的ArrayList。所有操作都是通过对底层进行一次新的复制实现</p><p>适用于读操作远远大于写操作的场景里。</p><p>存在扩容的概念，因为每次写操作都要复制一个副本，在副本的基础上修改后改变Aray引用。写操作需要大面积复制数组，所以性能很差</p><p><em><strong>读多写少</strong></em>的场景</p><h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><p>核心：创建新副本，读写分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;<span class="comment">//内部维护的数组</span></span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (E) a[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>直接通过下标访问数组，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有CAS操作。因为只是读，不会进行任何修改</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局的锁的状态</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当下（旧）的数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">//创建新的数组，并将旧的数组所有数据赋值到新的数组中</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//在末尾添加新的数据</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//将旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                    <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">            Object[] newElements;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index;</span><br><span class="line">            <span class="comment">//如果就是插入到末尾</span></span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//旧数组里的所有数据都赋值到新的数组</span></span><br><span class="line">                newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//声明新长度的数组</span></span><br><span class="line">                newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//以要插入的位置为分界线，把插入的下标的数据空出来</span></span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                 numMoved);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往index插入数据</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">//旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add方法采用ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份数据被复制的数组；因为一开始的数组引用时被volatile修饰，根据happens-beffore规则，写线程对数组引用的修改对读线程是可见的；</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="comment">//获取的数组中下标为index的数据值</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">            <span class="comment">//如果数组里该下标本身的值与需要设定的值不一样</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">                <span class="comment">//旧数组的值复制到新数组里</span></span><br><span class="line">                Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">                <span class="comment">//在下标为index处赋值</span></span><br><span class="line">                newElements[index] = element;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一样就不需要更改，直接修改旧数组的引用即可</span></span><br><span class="line">                <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove、removeRange与上面都类似</p><h2 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h2><p>读读共享、其他都互斥</p><p>读写锁规则的升级：读取时完全不用加锁的，并且更厉害的是，<em><strong>写入也不会阻塞读操作</strong></em></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>读多写少的场景，写即使慢一些也行</p><p>场景：黑名单、每日更新；监听看；迭代操作远多余修改操作</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>数据一致性问题：CopyOnWite容器只能<em><strong>保证数据的最终一致性</strong></em>，不能保证数据<em><strong>实时</strong></em>的一致性。所以，一旦写入不会马上就可以被读到</p><p>内容占用：因为通过复制机制开辟出一个新的副本，进行写操作时，内存里会同时驻扎两个对象的内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;写数组的拷贝，&lt;em&gt;&lt;strong&gt;支持高效率并发且是线程安全&lt;/strong&gt;&lt;/em&gt;，读操作无锁的ArrayList。所有操作都是通</summary>
      
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java线程安全的集合类</title>
    <link href="http://example.com/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://example.com/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2022-07-02T15:11:16.000Z</published>
    <updated>2022-07-02T15:18:56.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全的，它给几乎所有的public方法都加上了synchronized关键字，也正因为如此，加锁导致性能降低，在不需要并发访问同一对象时，这种强制性的同步机制就显得多余，所以现在Vector已被弃用。</p><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>HashTable和HashMap类似，不同点是HashTable是线程安全的，它给几乎所有public方法都加上了synchronized关键字，还有一个不同点是HashTable的K，V都不能是null，但HashMap可以，它现在也因为性能原因被弃用了。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Vector和HashTable被弃用后，它们被ArrayList和HashMap代替，但它们不是线程安全的，所以Collections工具类中提供了相应的包装方法把它们包装成线程安全的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Set&lt;E&gt; synHashSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Map&lt;K,V&gt; synHashMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K,V&gt;());</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步。</p><h1 id="Java-util-concurrent包中的集合"><a href="#Java-util-concurrent包中的集合" class="headerlink" title="Java.util.concurrent包中的集合"></a>Java.util.concurrent包中的集合</h1><h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h4><p>ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而ConcurrentHashMap是更细粒度的加锁。</p><p>在JDK1.8之前，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment含有整个table的一部分，这样不同分段之间的并发操作就互不影响。</p><p>JDK1.8对此做了进一步的改进，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</p><h4 id="2-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#2-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="2.CopyOnWriteArrayList和CopyOnWriteArraySet"></a>2.CopyOnWriteArrayList和CopyOnWriteArraySet</h4><p>它们是加了写锁的ArrayList和ArraySet，锁住的是整个对象，但读操作可以并发执行。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vector&quot;&gt;&lt;a href=&quot;#Vector&quot; class=&quot;headerlink&quot; title=&quot;Vector&quot;&gt;&lt;/a&gt;Vector&lt;/h1&gt;&lt;p&gt;vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Autowired和Resource</title>
    <link href="http://example.com/2022/06/25/Autowired%E5%92%8CResource/"/>
    <id>http://example.com/2022/06/25/Autowired%E5%92%8CResource/</id>
    <published>2022-06-25T13:40:50.000Z</published>
    <updated>2022-06-25T14:34:00.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>@Auwired：</p><p>对成员变量、方法及构造函数进行标注，完成自动装配的工作</p><p>@Resource：</p><p>​官方定义：在语义上被定义为通过其唯一的名称来标识特定的目标组件，其中声明的类型与匹配过程无关</p><p>​若没有明确指定名称，则默认名称是从字段名称或设置方法（get、set方法）派生的。若用在字段上，则采用字段名称；如果用在setter方法，它采用其属性名称（例如setProperty()方法，取property作为属性名称）    </p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>包含的属性不同：</p><p>​Autowired只包含一个参数：required，表示是否开启自动注入，默认是true</p><p>​Resource有七个参数，其中最重要的两个参数：name和type</p><p>注解使用的地方不同：</p><p>​Autowired可以用在构造方法、方法、参数、成员变量和注解上</p><p>​Resource可以用在类、成员变量、方法上</p><p>出处不同：</p><p>​Autowired是Spring定义的注解，所以只能用在Spring框架下</p><p>​Resource是JSR-250定义的注解，所以可以与其他框架一起使用</p><p>自动装配的方式不同：</p><p>​Autowired默认按byType，如果要使用byName，需要结合@Qualifier注解配合使用</p><p>​Resource默认byName自动装配，如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配</p><p>自动装配的顺序：</p><p>​Autowired：默认先按byTpe进行匹配，若发现找到多个bean则又按照byName方式进行匹配，如果还有多个，则抛出异常</p><p>​<img src="/2022/06/25/Autowired%E5%92%8CResource/A.png" alt="image-20220625222414253"></p><p>​Resource：</p><p>​若同时指定了name和type：会从容器中查找name和type唯一匹配bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了name：则按name后的名字去bean元素里查找有与之相等的name属性的bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了type：则从上下文汇总找到类型匹配的<em><strong>唯一</strong></em>bean进行装配，找不到或者找到多个，都会抛出异常</p><p>​都没有指定：自动按照byName方式找，若没有找到符合的bean，则回退为一个原始类型进行查找，如果找到就注入，没找到或者找到多个则抛出异常</p><p>​</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;@Auwired：&lt;/p&gt;
&lt;p&gt;对成员变量、方法及构造函数进行标注，完成自动装配的工作&lt;/p&gt;
&lt;p&gt;@Resource：&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="http://example.com/2022/06/16/Shiro/"/>
    <id>http://example.com/2022/06/16/Shiro/</id>
    <published>2022-06-16T07:20:29.000Z</published>
    <updated>2022-06-16T08:28:04.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/06/16/Shiro/jiegou1.png" alt="image-20220616152612753"></p><p><strong>Subject</strong>：主体，外部应用与subject进行交互，subject记录当前的用户。外部程序通过subject进行认证权限，subject通过Security Manager安全管理进行认证</p><p><strong>Security Manager</strong>：对全部subject进行安全管理，核心。可以对subjectManager完成subject的认证、授权，实质上是通过Authenticator</p><p>本身是一个接口，继承了Authenticator、Authorizer、SessionManager三个接口</p><p><strong>Authenticator</strong>：认证器，对用户身份进行认证，本身是一个接口，shiro提供ModularRealmAuthenticator的实现类，可以满足大部分需求</p><p><strong>Authorizer</strong>：授权器，用户通过授权器，用户通过认证器通过，在访问功能时需要通过授权器判断用户是否能操作的权限</p><p><strong>Realm</strong>：就相当于datasource数据源，subjectManager进行安全认证需要通过Realm获取用户权限数据</p><p><strong>SessionManager</strong>：会话管理，shiro定义了一套会话管理，不依赖web容器的session</p><p><strong>CacheManager</strong>：缓存管理，将用户的权限数据存储在缓存</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>即身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确</p><p>Subject：访问系统的用户，主体可以是用户、程序等</p><p>Principal：身份信息，是主体进行身份认证的标识，标识必须具有唯一性，一个主体可以有多个身份，但必须有一个主身份</p><p>credential：凭证信息，是只有主体自己知道的安全信息</p><h1 id="权限字符串"><a href="#权限字符串" class="headerlink" title="权限字符串"></a>权限字符串</h1><p>资源标识符：操作：资源实例标识符    对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用*通配符。</p><p>比如：用户创建权限   user:create  或 user:create:*</p><p>​用户实例001的所有权限 user:*:001</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><em><strong>以下所有代码来源于“编程不良人”</strong></em></p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 授权</span></span><br><span class="line"><span class="comment">     * @param principals</span></span><br><span class="line"><span class="comment">     * @return AuthorizationInfo</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">//获取身份信息 内容根据实际情况(看源码了解)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">primaryPrincipal</span> <span class="operator">=</span> (String) principals.getPrimaryPrincipal();</span><br><span class="line">        System.out.println(<span class="string">&quot;PrincipalCollection      &quot;</span>+primaryPrincipal);</span><br><span class="line">        <span class="comment">//从工厂中获取service对象</span></span><br><span class="line">        <span class="comment">//根据主身份信息获取角色 和 权限信息</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils</span><br><span class="line">                .getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="comment">//根据userService找到用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findRolesByUserName(primaryPrincipal);</span><br><span class="line">        <span class="comment">//授权角色信息</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(user.getRoles()))&#123;</span><br><span class="line">            <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">            user.getRoles().forEach(role-&gt;&#123;</span><br><span class="line">                <span class="comment">//从数据库中查出来的权限给该对象</span></span><br><span class="line">                simpleAuthorizationInfo.addRole(role.getName());</span><br><span class="line">                <span class="comment">//从数据库中角色具备的权限信息</span></span><br><span class="line">                List&lt;Perms&gt; perms = userService.findPermsByRoleId(role.getId());</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(perms))&#123;</span><br><span class="line">                    perms.forEach(perm-&gt;&#123;</span><br><span class="line">                        <span class="comment">//对该角色赋予相应的权限</span></span><br><span class="line">                        simpleAuthorizationInfo.addStringPermission(perm.getName());</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 身份认证,主体调用用户登录时，会调用该方法</span></span><br><span class="line"><span class="comment">     * @param token</span></span><br><span class="line"><span class="comment">     * @return AuthenticationInfo 里面收集用户提交的身份（比如：用户名）和凭据（比如：密码）</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取身份信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> (String) token.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">credentials</span> <span class="operator">=</span> (String) token.getCredentials();</span><br><span class="line">        <span class="comment">//在工厂中获取service对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUserName(principal);</span><br><span class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(user))&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   用户名</span></span><br><span class="line"><span class="comment">            *   加密的密码</span></span><br><span class="line"><span class="comment">            *   随机盐</span></span><br><span class="line"><span class="comment">            *   当前realm的名称</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user.getUsername(),user.getPassword(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MyByteSource</span>(user.getSalt()),</span><br><span class="line">                    <span class="built_in">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="doGetAuthenticationInfo中的principal和credentials的来源"><a href="#doGetAuthenticationInfo中的principal和credentials的来源" class="headerlink" title="doGetAuthenticationInfo中的principal和credentials的来源"></a>doGetAuthenticationInfo中的principal和credentials的来源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password,String code,HttpSession session)</span> &#123;</span><br><span class="line">       <span class="comment">//比较验证码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">codes</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (codes.equalsIgnoreCase(code))&#123;</span><br><span class="line">               <span class="comment">//获取主体对象</span></span><br><span class="line">               <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">               <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">               <span class="comment">//  重点  重点</span></span><br><span class="line">               <span class="comment">//将该UsernamePasswordToken类对象作为token专递给doGetAuthenticationInfo</span></span><br><span class="line">               subject.login(token);</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码错误!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;用户名错误!&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;密码错误!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/user/loginview&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="UsernamePasswordToken源码"><a href="#UsernamePasswordToken源码" class="headerlink" title="UsernamePasswordToken源码"></a>UsernamePasswordToken源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordToken</span> <span class="keyword">implements</span> <span class="title class_">HostAuthenticationToken</span>, RememberMeAuthenticationToken &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> rememberMe;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"><span class="comment">//省去了所有构造方法以及所有set方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] getPassword() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过该方法得到的username</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRememberMe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rememberMe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.host = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.rememberMe = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.password != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.password.length; ++i) &#123;</span><br><span class="line">                <span class="built_in">this</span>.password[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.password = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义的realm进行操作的配置"><a href="#自定义的realm进行操作的配置" class="headerlink" title="自定义的realm进行操作的配置"></a>自定义的realm进行操作的配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroDialect&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建shiroFilter  //负责拦截所有请求</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager defaultWebSecurityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//给filter设置安全管理器</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   可以实现权限相关的拦截器</span></span><br><span class="line"><span class="comment">         *       常用:</span></span><br><span class="line"><span class="comment">         *           anon:无需认证(登录)也已访问</span></span><br><span class="line"><span class="comment">         *           authc:必须认证和授权才可以访问</span></span><br><span class="line"><span class="comment">         *           user:若使用rememberMe的功能可以直接访问</span></span><br><span class="line"><span class="comment">         *           perms:该资源必须资源权限才可以访问</span></span><br><span class="line"><span class="comment">         *           role：该资源必须得到角色权限</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//配置系统受限资源</span></span><br><span class="line">        <span class="comment">//配置系统公共资源</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/getImage&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/register&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/registerview&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);<span class="comment">//authc 请求这个资源需要认证和授权</span></span><br><span class="line">        <span class="comment">//默认认证界面路径,没有登录的用户就都可以访问的</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/user/loginview&quot;</span>);</span><br><span class="line">        <span class="comment">//放在过滤链里面</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="comment">//未授权的</span></span><br><span class="line">        <span class="comment">//shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建安全管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(Realm realm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//给安全管理器设置</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建自定义realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Realm <span class="title function_">getRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CustomerRealm</span> <span class="variable">customerRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerRealm</span>();</span><br><span class="line">        <span class="comment">//修改凭证校验匹配器</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//设置加密算法为md5</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">//设置散列次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//放入realm</span></span><br><span class="line">        customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="comment">//开启缓存管理，用redis缓存信息</span></span><br><span class="line">        customerRealm.setCacheManager(<span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>());</span><br><span class="line">        customerRealm.setCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启全局缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCachingEnabled(<span class="literal">true</span>);<span class="comment">//认证认证缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCacheName(<span class="string">&quot;authenticationCache&quot;</span>);</span><br><span class="line">        customerRealm.setAuthorizationCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启授权缓存</span></span><br><span class="line">        customerRealm.setAuthorizationCacheName(<span class="string">&quot;authorizationCache&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customerRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的RediscacheManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title class_">CacheManager</span> &#123;</span><br><span class="line">    <span class="comment">//参数1:认证或者是授权缓存的统一名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; Cache&lt;K, V&gt; <span class="title function_">getCache</span><span class="params">(String cacheName)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;redis Cache      &quot;</span>+cacheName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCache</span>&lt;K,V&gt;(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现redis作为缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span>&lt;k,v&gt; <span class="keyword">implements</span> <span class="title class_">Cache</span>&lt;k,v&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cacheName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">(String cacheName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheName = cacheName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get              &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;get key:&quot;</span>+k);</span><br><span class="line">        System.out.println( <span class="string">&quot;redis  get value     &quot;</span>+getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString()));</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">put</span><span class="params">(k k, v v)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;put           &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;put key: &quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;put value:&quot;</span>+v);</span><br><span class="line">        getRedisTemplate().opsForHash().put(<span class="built_in">this</span>.cacheName,k.toString(),v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">remove</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============remove=============&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().delete(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;=============clear==============&quot;</span>);</span><br><span class="line">        getRedisTemplate().delete(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().size(<span class="built_in">this</span>.cacheName).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;k&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().keys(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;v&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().values(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate <span class="title function_">getRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用于接口（接口式）"><a href="#作用于接口（接口式）" class="headerlink" title="作用于接口（接口式）"></a>作用于接口（接口式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@RequiresRoles(value=&#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span><span class="comment">//用来判断角色  Logical.OR:满足其中一个就行   logical = Logical.AND:要同时满足</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;user:update:01&quot;)</span> <span class="comment">//用来判断权限字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入方法多个&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用于接口（编程式）"><a href="#作用于接口（编程式）" class="headerlink" title="作用于接口（编程式）"></a>作用于接口（编程式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">save1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">       <span class="keyword">if</span> (subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">           <span class="comment">//有权限</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有权限</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外还有标签式，因采用前后端分离，便不再展示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应</summary>
      
    
    
    
    <category term="权限框架" scheme="http://example.com/categories/%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud简单阐述</title>
    <link href="http://example.com/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <id>http://example.com/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</id>
    <published>2022-06-15T07:21:38.000Z</published>
    <updated>2022-06-15T08:24:20.406Z</updated>
    
    <content type="html"><![CDATA[<p>Spring社区有大一统java的趋势，快速构建一个单体单元SpringBoot，分布式微服务解决方案，SpringCloud和SpringFrameWork和各种组件等等</p><p>SpringCloud是一个分布式的微服务解决方案。区别于Dubbo，Dubbo只是一个远程RPC框架，而前者则是一整套的解决方案，包括<strong>服务注册、服务调用、负载均衡、服务网关、服务降级与熔断、分布式配置管理、消息总线</strong>等等技术。</p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou3.png" alt="1"></p><p>SpringCloud 是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。</p><p>通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p><p>SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix</p><h2 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h2><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/eureka.png" alt="1"></p><p>作用：实现服务治理（服务注册与发现）</p><p>简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</p><p>由两个组件组成：Eureka服务端和Eureka客户端。</p><p>Eureka服务端用作服务注册中心。支持集群部署。</p><p>Eureka客户端是一个java客户端，用来处理服务注册与发现。</p><p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个组件可实现自动拼接服务地址</p><ul><li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li><li>接着你要是调用那个接口，<strong>本质就是会调用 Feign创建的动态代理</strong></li><li>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来<strong>动态构造出你要请求的服务的地址</strong></li><li>最后针对这个地址，发起请求、解析响应</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>主要提供客户侧的软件<strong>负载均衡</strong>算法。</p><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p><ul><li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</li><li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li><li>Feign就会针对这台机器，构造并发起请求。</li></ul><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>可以在调用服务的时候，在服务出现异常时进行服务熔断和降级避免一直长时间等待服务返回结果而出现雪崩效应</li><li>它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</li></ul><p>熔断：当发现有服务卡死不能工作的时候，熔断器会对他进行熔断，比如这5分钟对这个服务的请求就直接返回了，不要去走网络请求卡几秒钟，这个过程就是溶断！</p><p>降级：就是当服务被熔断后，每次调用这个服务，你就写到单独的数据库中，等这个服务修复后，你手工的添加到业务的数据库中。这个过程就是降级！</p><p>雪崩：如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><h1 id="为什么还要SpringCloudAlibaba？"><a href="#为什么还要SpringCloudAlibaba？" class="headerlink" title="为什么还要SpringCloudAlibaba？"></a>为什么还要SpringCloudAlibaba？</h1><p>因为SpringCloud版本迭代非常快，每次发布一个realease之后又会马上发布下一个版本，所以可能会积累很多bug，而若是进入到了维护阶段，意味着不会再有新的组件技术出现，只是在原来的技术上修改。</p><h1 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title="SpringCloudAlibaba"></a>SpringCloudAlibaba</h1><p>是Spring cloud的子项目，符合SpringCloud的标准，致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li></ul><h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><p>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。<br>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。<br>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。<br>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。<br>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。<br>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。<br>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。<br><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou1.png" alt="1"></p><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou2.png" alt="1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring社区有大一统java的趋势，快速构建一个单体单元SpringBoot，分布式微服务解决方案，SpringCloud和SpringFrameWork和各种组件等等&lt;/p&gt;
&lt;p&gt;SpringCloud是一个分布式的微服务解决方案。区别于Dubbo，Dubbo只是一</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Bean</title>
    <link href="http://example.com/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-06-14T05:21:37.000Z</published>
    <updated>2022-06-14T07:21:29.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置Bean"><a href="#配置Bean" class="headerlink" title="配置Bean"></a>配置Bean</h1><p>两种方式：在xml中写<bean>标签，用@Bean注解</bean></p><p>两个方法都在sping的refresh方法中都会用loadBeanDefinitions加载到容器里面，通过BeanDefinitionRegistry.register方法，会包括一些后置处理</p><h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><p>配置bean之后就拿到了BeanDefinition，是配置bean的加载结果，也是下面步骤的原始数据。</p><p>Spring在启动时，会扫描到类的信息，将相关信息封装为BeanDefinition存入到beanDefinitionMap中，根据里面的扫描信息生成bean                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><p>注意：beanName、ClassType。</p><p>提前初始化：把那个没有配置的懒加载bean开始初始化</p><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>入参实际上只有一个beanName，与beanDefinition的两个属性相对应，通过beanName然后找到beanType，找到type之后调用&#x3D;&#x3D;反射&#x3D;&#x3D;返回了一object。</p><p>反射的大致：获取class对象得到一个构造器，Constructor ctor&#x3D;clazz.getDeclaredConstructor()，Object obj &#x3D; ctor.newInstance()。</p><p>容器中按照使用者来分，可以把bean对象分为用户自定义对象、容器对象（比如：ApplicationContext、BeanFactory等等）</p><p>注意：InstantiationAwareBeanPostProcessor去生成代理类回来</p><h1 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h1><p>此处就需要解决循环依赖-三级缓存</p><p>给自定义属性赋值：核心在于populateBean里面的autowireByName、autowireByType两个方法（@Autowire，@Resource）</p><p>给容器对象属性赋值：invokeAwareMethods</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>对象的拓展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220614145857358.png" alt="image-20220614145857358"></p><p>在属性赋值阶段后，postProcessBeforeInitialization方法之前，会执行很多Aware类型的接口，这种接口类型作用就是加载到Spring容器中，Aware前面的名字就是对应哪种资源</p><p>aware：如果实现了某些接口，比如BeanNameAware、BeanFactoryAware、ApplicationContextAware，就把这些实例给set进去。</p><p>初始化的方式有三个：分别是Initialization的afterPropertiesSet方法；PostConstruct注解标注方法；配置的init-method</p><p>BeanPostProcessor实现了AOP，AOP就是在整个IOC处理流程中某一个拓展点的实现</p><p>执行完就是一个完成的对象</p><h1 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h1><p>要么去实现DisposableBean接口，要么去定义destory-method方法 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置Bean&quot;&gt;&lt;a href=&quot;#配置Bean&quot; class=&quot;headerlink&quot; title=&quot;配置Bean&quot;&gt;&lt;/a&gt;配置Bean&lt;/h1&gt;&lt;p&gt;两种方式：在xml中写&lt;bean&gt;标签，用@Bean注解&lt;/bean&gt;&lt;/p&gt;
&lt;p&gt;两个方法都在sping</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Bean" scheme="http://example.com/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>循环依赖</title>
    <link href="http://example.com/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://example.com/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-06-13T08:33:50.000Z</published>
    <updated>2022-06-13T16:05:15.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环依赖问题简述"><a href="#循环依赖问题简述" class="headerlink" title="循环依赖问题简述"></a>循环依赖问题简述</h1><p><img src="/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/question.png" alt="image-20220613223428341"></p><p>如图所示，在创建对象A的时候，需要依赖注入对象B，但此时容器里面并没有B，所以去创建B，B在创建的过程中又需要A的注入，而此时A在等待B的创建，所以就造成了双方都在等待，类似的“死锁”的情况，导致两者都无法创建成功。</p><p>创建Spring Bean对象到初始化的大致流程</p><p>getSingleton：从单例池中获取bean对象，若没有就创建</p><p>doCreateBean：创建bean对象</p><p>populateBean：填充依赖，若被填充的对象不存在于单例池中，则进行创建</p><p>addSingleton：将初始化完成的对象加入到单例池</p><h1 id="三级循环"><a href="#三级循环" class="headerlink" title="三级循环"></a>三级循环</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">//一级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一级缓存：是成品，里面是完成生命周期的对象，是完成的bean，可以被任意使用</p><p>二级缓存：是半成品，不完整，里面是刚刚实例化但是没有全部实例化的原始对象</p><p>三级缓存：里面的bean是构造器反射创建出来的bean，没有任何的填充属性，单例工程的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">        <span class="comment">//从singletonObjects（一级缓存）尝试获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//如果一次缓存中获取不到并且对象正在创建中，就在二级缓存中查找</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//二级缓存中也查找不到且允许从三级缓存中经过getObject获取</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">               <span class="comment">//对一级缓存进行加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">//一级缓存获取不到</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//二级缓存还是获取不到</span></span><br><span class="line">                        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//获取工厂</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//就从三级缓存中得到bean</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">//若是获取到了，就将singletonObject放入到二级缓存中，并移除三级缓存中的实例</span></span><br><span class="line">                                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isSingletonCurrentlyInCreation（）：判断当前的单例bean是否正在创建的过程中，即没有执行初始化方法</span><br><span class="line">allowEarlyReference：是否允许从三级缓存中经过getObject()方法获取bean对象</span><br></pre></td></tr></table></figure><p>大致：</p><p>Spring会先从一级缓存中去获取bean对象</p><p>获取不到而且对象正在建立中，就会尝试从二级缓存中获取bean</p><p>若还是获取不到，且允许从第三次缓存中的getObject()获取对象，就尝试从三级缓存中获取</p><p>若是三级缓存中获取到了bean，就会将bean放入二级缓存中</p><p>如上图A、B在三级缓存中的迁移过程：</p><p>1创建对象A，完成生命周期第一步（实例化），在调用createBeanInstance方法后，会调用addSingletonFactory方法，将已实例化但未属性赋值未初始化的对象放入三级缓存中。即将对象A提早曝光给IOC容器</p><p>2执行对象A生命周期第二步（属性赋值）。此时，发现对象A依赖对象B，所以就会尝试去获取对象B</p><p>3发现B没有被创建，所以会执行创建对象B的过程</p><p>4创建对象B的过程中，执行实例化和属性赋值操作，此时发生对象B依赖对象A</p><p>5 尝试去缓存中查找对象A。从一级缓存开始找，没有对象A（因为对象A此时还没有初始化完成）；再找二级缓存，也没有对象A（此时的对象A还没有进行属性赋值）；转而查找三级缓存，对象B通过singletonFactory.getObject();拿到对象A</p><p>6对象B获取到对象A后，继续执行生命周期，属性赋值、初始化操作。对象B完成初始化操作后，会被存到一级缓存中</p><p>7转到【对象A执行属性赋值过程并发现依赖了对象B】的阶段，此时对象已经可以从一级缓存中获取到对象B。所以可以顺利执行属性赋值操作</p><p>8对象A执行初始化操作，完成后，对象A也会放到一级缓存中</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>Spring进行扫描-&gt;反射后封装成beanDefinition对象-&gt;放入beanDefinitionMap-&gt;遍历map-&gt;验证（是否单例、是否延迟加载、是否抽象）-&gt;推断构造方法-&gt;准备开始进行实例-&gt;去单例池中查，没有-&gt;去二级缓存中找，没有提前暴露-&gt;生成一个objectFactory对象暴露到二级缓存中-&gt;属性注入，发现依赖Y-&gt;此时Y开始它的生命周期直到属性注入，发现依赖X-&gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;完成循环依赖。</p><h1 id="Spring为什么不能解决非单例Bean的循环依赖"><a href="#Spring为什么不能解决非单例Bean的循环依赖" class="headerlink" title="Spring为什么不能解决非单例Bean的循环依赖"></a>Spring为什么不能解决非单例Bean的循环依赖</h1><p>该问题可以分为：</p><p>Spring为什么不能解决构造器的循环依赖？</p><p>​因为对象的构造函数实在实例化阶段调用。因为在对象实例化后，会将对象放到三级缓存中。在调用对象的构造函数时，对象还没有初始化，所以不能把对象放入三级缓存中。在构造函数注入时，两个对象都没在三级缓存中，所以两个bean都不能实例化</p><p>Spring为什么不能解决prototype作用域循环依赖？</p><p>​IOC只会管理Bean的生命周期，并将单例Bean存放到缓存池中（三级缓存）。Spring不会管理prototype作用域的bean</p><p>Spring为什么不能解决多例的循环依赖?</p><p>​多实例Bean每次调用getBean都会创建一个新的Bean对象，该对象不能缓存。而解决循环依赖是通过缓存实现</p><h1 id="非单实例对象怎么解决？"><a href="#非单实例对象怎么解决？" class="headerlink" title="非单实例对象怎么解决？"></a>非单实例对象怎么解决？</h1><p>对于构造器注入产生的循环依赖，使用@Lazy注解，延迟加载</p><p>对于多例bean和prototype作用域产生的循环依赖，可以尝试改为单例Bean</p><h1 id="为什么一定要三级缓存"><a href="#为什么一定要三级缓存" class="headerlink" title="为什么一定要三级缓存"></a>为什么一定要三级缓存</h1><p><strong>如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理</strong></p><p>使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于 IOC 的考虑，而是出于 AOP 的考虑，即若使用二级缓存，在 AOP 情形注入到其他 Bean的，不是最终的代理对象，而是原始对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;循环依赖问题简述&quot;&gt;&lt;a href=&quot;#循环依赖问题简述&quot; class=&quot;headerlink&quot; title=&quot;循环依赖问题简述&quot;&gt;&lt;/a&gt;循环依赖问题简述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap部分解析</title>
    <link href="http://example.com/2022/06/09/concurrentHashMap/"/>
    <id>http://example.com/2022/06/09/concurrentHashMap/</id>
    <published>2022-06-09T06:17:13.000Z</published>
    <updated>2022-06-09T06:21:08.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><img src="/2022/06/09/concurrentHashMap/jiegou.png" alt="image-20220609111027013"></p><p>JDK1.7：本质上是一个16个Segment对象的数组，每个Segment都是HashEntry&lt;K,V&gt;[] table，每个table包含若干个HashEntry对象连接起来的链表。get、put等操作只锁当前需要用的桶。即分段数组+链表。</p><p>实现上与hashMap类似，只是采用了分段锁，每个分段锁维护着几个桶（hashEntry），&#x3D;&#x3D;多个线程可以同时访问不同分段锁上的桶&#x3D;&#x3D;</p><p>concurrentHashMap中含有几个segment数组 ，每个segment又含有几个hashEntry数组</p><p>JDK1.8：没有使用段锁，而是采用了Node数组+链表+红黑树的方式</p><h4 id="构造方法（1-8）"><a href="#构造方法（1-8）" class="headerlink" title="构造方法（1.8）"></a>构造方法（1.8）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量              扩容因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, </span></span><br><span class="line"><span class="params">     //并发级别（当前concurrentHashMap对象，最多同时支持多少线程同时操作）segment数组的长度。但是不会随着扩容长度发生变化（因为有了最大的限制）</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//以上均是防止传非法数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Put（1-8）"><a href="#Put（1-8）" class="headerlink" title="Put（1.8）"></a>Put（1.8）</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="comment">//首先就是不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());<span class="comment">//基于key进行计算，一定是正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录某个桶上元素的个数，若&gt;8就转变为红黑树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//是否要初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//根据下标计算，若f为空，数组的这个位置就没有元素，所以加进去就可以退出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//CAS操作，防止多个线程同时进行</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出值判断hash值，判断是否是forwar节点（代表是否正在扩容）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//锁这个节点，保证该节点的元素插入是安全的（不影响其他节点）。即保证安全又保证效率</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//为什么还要判断？ 防止变成树后节点发生了变化</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//fh&gt;0就代表是一个链表结构</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//遍历依次比对</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//原数组里面没有，就需要添加新的节点</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//不是&gt;0就不是链表结构，就是树结构</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以上就添加结束，就开始维护</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//泊松分布</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)  <span class="comment">//TREEIFY_THRESHOLD=8</span></span><br><span class="line">                        <span class="comment">//触发变成树的可能函数</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护集合长度，是否扩容</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Get（1-8）"><a href="#Get（1-8）" class="headerlink" title="Get（1.8）"></a>Get（1.8）</h4><p>  计算hash值</p><p>根据hash值计算得到数组相应的位置</p><p>在该位置进行针对性的查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">//计算值，将保存数据的table赋值给tab，且判断数组是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//该数组下标所对应的值</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组上的值就是所要查找的值</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//就表示正在进行扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//直接遍历链表需要所要查找的值</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现高效并发机制的保证：</p><p>通过不加锁和加锁的两种方案控制跨段操作的安全性</p><p>通过HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作</p><p>（理想操作）可以支持16个线程执行并发写操作，及任意数量线程的读操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Map" scheme="http://example.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="http://example.com/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-05-28T15:56:14.000Z</published>
    <updated>2022-05-28T15:57:41.179Z</updated>
    
    <content type="html"><![CDATA[<p>微服务是一种架构风格，即将单体应用划分为小型的服务单元，微服务之间使用 HTTP 的 API 进行资源访问与操作。</p><p>在笔者看来，微服务架构的演变更像是一个公司的发展过程，从最开始的小公司，到后来的大集团。大集团可拆分出多个子公司，每个子公司的都有自己独立的业务、员工，各自发展，互不影响，合起来则是威力无穷。</p><p>臃肿的系统、重复的代码、超长的启动时间带给开发人员的只有无限的埋怨，丝毫没有那种很舒服的、很流畅的写代码的感觉。他们把大部分时间都花在解决问题和项目启动上面了。</p><h3 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h3><p>使用微服务架构能够为我们带来如下好处：</p><h4 id="1）服务的独立部署"><a href="#1）服务的独立部署" class="headerlink" title="1）服务的独立部署"></a>1）服务的独立部署</h4><p>每个服务都是一个独立的项目，可以独立部署，不依赖于其他服务，耦合性低。</p><h4 id="2）服务的快速启动"><a href="#2）服务的快速启动" class="headerlink" title="2）服务的快速启动"></a>2）服务的快速启动</h4><p>拆分之后服务启动的速度必然要比拆分之前快很多，因为依赖的库少了，代码量也少了。</p><h4 id="3）更加适合敏捷开发"><a href="#3）更加适合敏捷开发" class="headerlink" title="3）更加适合敏捷开发"></a>3）更加适合敏捷开发</h4><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行。服务拆分可以快速发布新版本，修改哪个服务只需要发布对应的服务即可，不用整体重新发布。</p><h4 id="4）职责专一，由专门的团队负责专门的服务"><a href="#4）职责专一，由专门的团队负责专门的服务" class="headerlink" title="4）职责专一，由专门的团队负责专门的服务"></a>4）职责专一，由专门的团队负责专门的服务</h4><p>业务发展迅速时，研发人员也会越来越多，每个团队可以负责对应的业务线，服务的拆分有利于团队之间的分工。</p><h4 id="5）服务可以按需动态扩容"><a href="#5）服务可以按需动态扩容" class="headerlink" title="5）服务可以按需动态扩容"></a>5）服务可以按需动态扩容</h4><p>当某个服务的访问量较大时，我们只需要将这个服务扩容即可。</p><h4 id="6）代码的复用"><a href="#6）代码的复用" class="headerlink" title="6）代码的复用"></a>6）代码的复用</h4><p>每个服务都提供 REST API，所有的基础服务都必须抽出来，很多的底层实现都可以以接口方式提供。</p><h3 id="微服务架构的劣势"><a href="#微服务架构的劣势" class="headerlink" title="微服务架构的劣势"></a>微服务架构的劣势</h3><p>微服务其实是一把双刃剑，有利有弊。下面我们来谈谈微服务有哪些弊端，以及能采取什么办法避免。</p><h4 id="1）分布式部署，调用的复杂性高"><a href="#1）分布式部署，调用的复杂性高" class="headerlink" title="1）分布式部署，调用的复杂性高"></a>1）分布式部署，调用的复杂性高</h4><p>单体应用的时候，所有模块之前的调用都是在本地进行的，在微服务中，每个模块都是独立部署的，通过 HTTP 来进行通信，这当中会产生很多问题，比如网络问题、容错问题、调用关系等。</p><h4 id="2）独立的数据库，分布式事务的挑战"><a href="#2）独立的数据库，分布式事务的挑战" class="headerlink" title="2）独立的数据库，分布式事务的挑战"></a>2）独立的数据库，分布式事务的挑战</h4><p>每个微服务都有自己的数据库，这就是所谓的去中心化的数据管理。这种模式的优点在于不同的服务，可以选择适合自身业务的数据，比如订单服务可以用 MySQL、评论服务可以用 MongoDB、商品搜索服务可以用 ElasticSearch。</p><p>缺点就是事务的问题了，目前最理想的解决方案就是柔性事务中的最终一致性，后面的章节会给大家做具体介绍。</p><h4 id="3）测试的难度提升"><a href="#3）测试的难度提升" class="headerlink" title="3）测试的难度提升"></a>3）测试的难度提升</h4><p>服务和服务之间通过接口来交互，当接口有改变的时候，对所有的调用方都是有影响的，这时自动化测试就显得非常重要了，如果要靠人工一个个接口去测试，那工作量就太大了。这里要强调一点，就是 API 文档的管理尤为重要。</p><h4 id="4）运维难度的提升"><a href="#4）运维难度的提升" class="headerlink" title="4）运维难度的提升"></a>4）运维难度的提升</h4><p>在采用传统的单体应用时，我们可能只需要关注一个 Tomcat 的集群、一个 MySQL 的集群就可以了，但这在微服务架构下是行不通的。当业务增加时，服务也将越来越多，服务的部署、监控将变得非常复杂，这个时候对于运维的要求就高了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微服务是一种架构风格，即将单体应用划分为小型的服务单元，微服务之间使用 HTTP 的 API 进行资源访问与操作。&lt;/p&gt;
&lt;p&gt;在笔者看来，微服务架构的演变更像是一个公司的发展过程，从最开始的小公司，到后来的大集团。大集团可拆分出多个子公司，每个子公司的都有自己独立的业务</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>父类子类加载顺序</title>
    <link href="http://example.com/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-05-27T02:56:23.000Z</published>
    <updated>2022-05-27T03:12:56.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><p>父类静态属性（成员变量） &gt; 父类静态代码块 &gt; 子类静态属性 &gt; 子类静态代码块 &gt; 父类非静态属性 &gt; 父类非静态代码块 &gt; 父类构造器 &gt; 子类非静态属性 &gt; 子类非静态代码块 &gt; 子类构造器</p><p>简而言之就是先静态后非静态，先父类后子类</p><ol><li>父类静态变量</li><li>父类静态代码块（若有多个按代码先后顺序执行）</li><li>子类静态变量</li><li>子类静态代码块（若有多个按代码先后顺序执行）</li><li>父类非静态变量</li><li>父类非静态代码块（若有多个按代码先后顺序执行）</li><li>父类构造函数</li><li>子类非静态变量</li><li>子类非静态代码块（若有多个按代码先后顺序执行）</li><li>子类构造函数</li></ol><p><em><strong>所有的静态资源都只会被加载一次，非静态资源可以被重复加载</strong></em></p><h1 id="类初始化和实例初始化"><a href="#类初始化和实例初始化" class="headerlink" title="类初始化和实例初始化"></a>类初始化和实例初始化</h1><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>一个类要创建实例需要先加载并初始化该类</p><p>  Main方法所在的类需要先加载和初始化</p><p>子类要初始化需要先初始化父类</p><p>一个类初始化就是执行<clinit>()方法 类初始化方法</clinit></p><p>  <clinit>()方法由静态类变量显示赋值代码和静态代码块组成</clinit></p><p>  类变量显示赋值代码和静态代码块代码从上到下顺序执行</p><h2 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h2><p>就是执行<init>()方法</init></p><p>  <init>()方法可能重载有多个，有几个构造器就有几个<init>方法</init></init></p><p>  <init>()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成</init></p><p>  非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应的构造器的代码最后执行</p><p>  每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法</init></p><p>  <init>方法的首行就是super()或super（实参列表），即对应父类的<init>方法</init></init></p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>不能被重写的方法</p><p>Final方法</p><p>  静态方法</p><p>  Private等子类中不可见的方法</p><p>多态性</p><p>  子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码</p><p>  非静态方法默认的调用对象是this</p><p>  This对象在构造器或者说<init>方法中就是正在创建的对象</init></p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法被子类重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Son()&#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//写或不写都在，一定会会调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="小结特点"><a href="#小结特点" class="headerlink" title="小结特点"></a>小结特点</h1><ol><li>静态属性和代码块，当且仅当该类在程序中第一次被 new 或者第一次被类加载器调用时才会触发（不考虑永久代的回收）。也正是因为上述原因，<strong>类优先于对象</strong> 加载&#x2F;new，即 <strong>静态优先于非静态</strong>。</li><li>属性（成员变量）优先于构造方法，可以这么理解，加载这整个类，需要先知道类具有哪些属性，并且这些属性初始化完毕之后，这个类的对象才算是<strong>完整的</strong>。另外，非静态代码块其实就是对象 new 的准备工作之一，算是一个不接受任何外来参数的构造方法。因此，<strong>属性 &gt; 非静态代码块 &gt; 构造方法。</strong></li><li>有趣的是，<strong>静态部分（前4个）是父类 &gt; 子类</strong>，而 <strong>非静态部分也是父类 &gt; 子类。</strong></li><li>另外容易忽略的是，非静态代码块在每次 new 对象时都会运行，可以理解：<strong>非静态代码块是正式构造方法前的准备工作</strong>（非静态代码块 &gt; 构造方法）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;加载顺序&quot;&gt;&lt;a href=&quot;#加载顺序&quot; class=&quot;headerlink&quot; title=&quot;加载顺序&quot;&gt;&lt;/a&gt;加载顺序&lt;/h1&gt;&lt;p&gt;父类静态属性（成员变量） &amp;gt; 父类静态代码块 &amp;gt; 子类静态属性 &amp;gt; 子类静态代码块 &amp;gt; 父类非静态属</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-26T06:18:56.000Z</published>
    <updated>2022-05-26T06:49:47.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>实现单例模式三个主要特点：</p><p>1、构造方法私有化；<br>2、实例化的变量引用私有化；<br>3、获取实例的方法共有。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>静态化实例对象</p><p>私有化构造方法，禁止通过构造方法创建实例</p><p>提供一个公共的静态方法，用来返回唯一的实例</p><h1 id="单例的好处"><a href="#单例的好处" class="headerlink" title="单例的好处"></a>单例的好处</h1><p>整个系统只存在一个对象，内存开始少，性能好</p><p>避免对资源的多重占用</p><p>在系统设置全局访问点，优化和共享资源访问</p><h1 id="不同创建方式"><a href="#不同创建方式" class="headerlink" title="不同创建方式"></a>不同创建方式</h1><p>饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//向外提供   自行创建   不能更改(单例)</span></span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">static</span>    <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的懒汉式：线程不安全，不可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内部类加载：静态内部类不会随着外部类的加载和初始化而初始化。因为是在内部类加载和初始化时创建的。所以线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h1><p>反射</p><p>常见的单例模式实现中，往往有一个私有的构造函数，防止外部程序的调用，但是通过反射可以轻而易举的破坏这个限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> singleton.getSingleton();</span><br><span class="line">            Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">reflectInstance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">            System.out.println(S\singleton == reflectInstance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：false，单例被破坏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>序列化</p><p>其中 Singleton 实现了 Serializable 接口，才有可能通过序列化破坏单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>克隆</p><p>实现 Cloneable 接口重写 clone 方法</p><h1 id="枚举类详解"><a href="#枚举类详解" class="headerlink" title="枚举类详解"></a>枚举类详解</h1><p>Joshua Bloch大神在《Effective Java》中明确表达过的观点：使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法</p><p>枚举类型单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">public</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类的单例模式优点</p><p>写法简单</p><p>枚举会自己处理序列化：<em><strong>传统的单例存在一个问题，一旦实现了序列化接口，那么就不再保持单例</strong></em>，因为readObject()方法一直返回一个新的对象，就像java的构造方法一样</p><p>枚举类创建的是thread-safe</p><p>面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点</p><p>在序列化的过程中Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。</p><p>如上，序列化的时候只将 INSTANCE这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。</p><h1 id="不会被破坏单例的原因"><a href="#不会被破坏单例的原因" class="headerlink" title="不会被破坏单例的原因"></a>不会被破坏单例的原因</h1><p>通过枚举实现的单例模式，利用反射构造新的对象，由于 <a href="https://so.csdn.net/so/search?q=enum&spm=1001.2101.3001.7020">enum</a> 没有无参构造器，结果会抛出 NoSuchMethodException 异常;</p><p>枚举类不实现 Serializable 接口，都可以进行序列化，并且返回原来的单例;</p><p>Enum 类中 clone 的方法是 final 类型，无法重写，也就不能通过克隆破坏单例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h1&gt;&lt;p&gt;实现单例模式三个主要特点：&lt;/p&gt;
&lt;p&gt;1、构造方法私有化；&lt;br&gt;2、实例化的变量引用私有化；&lt;</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="枚举" scheme="http://example.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础</title>
    <link href="http://example.com/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-25T12:47:24.000Z</published>
    <updated>2022-05-25T12:53:41.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>是管理计算机硬件与软件资源的程序</p><p>本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件的资源</p><p>屏蔽了硬件层的复杂性</p><p>内核是操作系统核心，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</p><h2 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h2><p>处理器的执行状态分为内核态和用户态，就是为了避免操作系统和关键字数据被用户程序破坏</p><p>内核态：是操作系统管理程序执行时所处状态，能执行包含特权指令在内的所有指令，能访问系统内所有的存储空间</p><p>用户态：用户态运行的进程或可以直接遁去用户程序的数据</p><h2 id="实现内核态和用户态的切换"><a href="#实现内核态和用户态的切换" class="headerlink" title="实现内核态和用户态的切换"></a>实现内核态和用户态的切换</h2><p>系统调用：是操作系统的最小功能单位，操作系统提供的用户接口，本身是一种软中断。</p><p>异常：也叫内中断，由错误引起</p><p>外中断: 通过两根信号线来通知处理器外设的状态变化，是硬中断</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配的基本单位，独立运行的基本单位</p><p>由以下组成：</p><p>  进程控制块PCB，进程唯一存在标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级，CPU现场保护区（用户进程切换），占有的资源清单</p><p>  程序段</p><p>  数据段</p><p>状态：</p><p>  创建态（进程正在被创建）</p><p>就绪态（除了CPU，其他资源都有，一个系统中可有多个进程处于该状态）、</p><p>运行态（占有处理器正在运行）、</p><p>阻塞态（不具备运行条件，在等待某个时间完成）</p><p>  结束态（进程正在从系统中消失）</p><p>孤儿进程：父进程退出，子进程还在运行。将被init进程收养</p><p>僵尸进程：进程使用fork创建子进程，若子进程退出，而父进程没有调用wait或waitpid获取子进程状态信息，那子进程的进程描述符仍然保存在系统中</p><h3 id="进程间的通信方法"><a href="#进程间的通信方法" class="headerlink" title="进程间的通信方法"></a>进程间的通信方法</h3><p>  每个进程各有不同的用户地址空间，任何一个进程的全局变量在另一个进程看不见。所以，进程间的交换数据必须在内核：在内核中开辟出一块缓冲区，进程A把数据从用户空间拷贝到内核缓冲区，进程B再从内核缓冲区把数据读走。</p><p>不同进程间的通信本质：进程间可以看到一份公共资源；提供这资源的形式或提供者不同，通信方式也就不同</p><p>主要包括：管道&#x2F;匿名管道，消息队列、信号量、信号、共享内存、套接字socket</p><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>互斥量：互斥对象机制</p><p>信号量：允许同一时刻多线程访问同一资源，但要控制同一时刻最大线程数</p><p>事件：通过通知操作的方式来保持多线程同步</p><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><p>当前运行的进程运行结束、当前运行进程阻塞、执行完系统调用等系统程序后返回用户进程、抢占式调度中有更高优先级的进行就绪、分时系统中，分给当前进程的时间片用完</p><h3 id="不能进行调度的时候"><a href="#不能进行调度的时候" class="headerlink" title="不能进行调度的时候"></a>不能进行调度的时候</h3><p>中断处理程序执行时，操作系统的内核程序临界区内、其他需要完全屏蔽中断的原子操作过程中</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>某个函数、数据库在并发环境中被调用时，能够正确的处理多个线程之间的共享变量，让程序功能正确完成</p><p>上下文就是这样的过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作</p><h3 id="进程同步的方法"><a href="#进程同步的方法" class="headerlink" title="进程同步的方法"></a>进程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程划分的任务，是一个进程内可调度的实体，CPU调度的基本单位，来保证程序的实时性，实现进程内部的并发</p><p>是操作系统可识别的最小执行和调度单位</p><h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p>用Volatile关键字，就是多个线程同时监听一个变量</p><p>Object类的wait和notify</p><p>JUC工具类CountDownLatch</p><h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>比线程更轻量级，不被操作系统管理，完全由程序控制（用户态执行）。这样能提升性能，不会像线程那样切换而消耗资源</p><p>单线程下的并发 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基本概述&lt;/h2&gt;&lt;p&gt;是管理计算机硬件与软件资源的程序&lt;/p&gt;
&lt;p&gt;本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件的资源&lt;/p&gt;
</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="http://example.com/2022/05/24/MySQL-1/"/>
    <id>http://example.com/2022/05/24/MySQL-1/</id>
    <published>2022-05-24T07:22:57.000Z</published>
    <updated>2022-07-06T14:38:34.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p> 连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、缓冲组件、优化器组件、插件式存储引擎、物理文件</p><h2 id="三大范式和反模式"><a href="#三大范式和反模式" class="headerlink" title="三大范式和反模式"></a>三大范式和反模式</h2><p>第一：属性不可分割，原子项</p><p>第二：原子性，即非主属性必完全依赖主属性</p><p>第三：原子性，非主属性必完全主属性，且不存在传递依赖</p><p>反模式：解决了旧问题，又产生了新问题。实际开发中，不会严格遵守三范式</p><h2 id="三种引擎"><a href="#三种引擎" class="headerlink" title="三种引擎"></a>三种引擎</h2><p><img src="/2022/05/24/MySQL-1/yinqin.png" alt="引擎"></p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><a href="https://xiaoerbutingbu.github.io/2022/05/11/InnoDB-1/">详情请看</a></p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存存放，hash索引（默认）</p><p>所有数据存在内存汇总，数据的处理速度快，但安全性不高，因对表的大小有要求，不能建太大的表。适用于需要很快的读写速度、安全性要求较低的</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快</p><p>若主要用于插入新记录和读出记录，该引擎就能实现处理的高效率。若应用的完整性、并发性要求较低，也可</p><p>每次查询具有原子性</p><p>B+树的索引结构</p><p>非聚集性索引，存储会有两个文件，一个索引文件，一个数据文件，其中索引文件的索引指向数据文件中的表数据</p><p>用一个变量保存了整个表的行数，而innodb是全表扫描</p><p>支持全文索引，innodb不支持全文索引（5.7以前）</p><p>可以被压缩后查询</p><p>所以MYISAM只缓存索引块，记录的直接是文件的OFFSET，定位比INNODB块。多以查询比较快</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制，是一种并发控制的方法，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p><em><strong>就是为了实现读写冲突不加锁。</strong></em></p><p>MVCC多版本并发控制：维持一个数据的多个版本，让读写操作没有冲突</p><p>在InnoDB中的实现主要是为了提高数据库并发性能</p><p>使用RC和RR隔离级别的事务，在执行普通selsect操作时，访问记录版本链的过程；让不同事务的读写、写操作并发执行，提高体统性能</p><h3 id="益处"><a href="#益处" class="headerlink" title="益处"></a>益处</h3><p>解决读写冲突的无锁并发控制</p><p>在并发读写时，可在读操作时不用阻塞写操作，写操作不用阻塞读操作，提供读写性能；解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>第一种：将数据记录的多个版本保存在数据库中，当这些版本数据不再需要时，垃圾回收器就回收这些记录</p><p>第二种：只在数据库中保存最新版本的数据，但是在使用undo时动态重构旧版本数据</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>3个隐式字段：分别记录</p><p>​                 最近修改事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</p><p>​                 指向这条记录的上一个版本；</p><p>​                 隐含自增ID，若数据表没有主键，就自动产生一个聚集索引</p><p>Undo日志：</p><p>​        Insert undo log：事务在insert新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>​        Update undo log：在update或delete时产生；事务回滚需要，快照读也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该该日志，才会被统一清除</p><p>Read View：</p><p>​         事务进行快照读操作的时候生产的读视图</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>适合索引的列是出现在where字句中的列或连接子句中指定的列</p><p>基础较小的类，索引效果差。</p><p>使用短索引：若对长字符串进行索引，应该指定要前缀长度，这样能够节省大量索引空间</p><p>不能过度索引，因为索引需要额外的磁盘空间，并降低写操作的性能。修改表的内容时，索引会进行更新甚至重构，索引的列越多，时间就越长。所以，只保持需要的索引有利于查询即可</p><p>存储引擎层实现，索引：帮助mysql高效获取数据的数据结构</p><p>提高数据库的性能，不用加内存，不用该程序，不同调sql</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>​每张表的主键构成一棵B+树，同时叶子节点存放的即为整张表的行记录数据，叶子节点也就是数据页</p><p>​将数据存储与索引放到一块，索引的叶子节点保存了行数据，&#x3D;&#x3D;必有且只有一个聚集索引&#x3D;&#x3D;。若有主键，主键即是；无主键用第一个唯一索引；若都没，会自动生成一个rowid作为隐藏的聚集索引。</p><p>​        结构：B+树：&#x3D;&#x3D;将所有数据都放在叶子节点&#x3D;&#x3D;，叶子节点形成一个列表；非叶子只存放键值，每个数据叶中的有效数据就多了，可以减少IO次数。按键值的大小顺序存放在同一层的叶子节点上</p><p>​    因为相对于二叉树（会有左倾右倾的情况），B+树层级更少，搜索效率高</p><p>​    因为B树：无论叶子节点还是非叶子，都保存数据，所以存储值减少，指针就减少，要同样保存大量数据，只能增加树的高度，导致性能降低，要查找就要遍历整个树</p><p>​    Hash索引只支持等值匹配，不支持排序操作</p><h4 id="辅助索引（非聚集索引）"><a href="#辅助索引（非聚集索引）" class="headerlink" title="辅助索引（非聚集索引）"></a>辅助索引（非聚集索引）</h4><p>与聚集索引不同的是，叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点索引行中还包含一个书签（用来让Innodb知道哪里可以找到与之对应的行数据）</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>把无序的数据变成有序的查询</p><p>创建了索引的列的内容进行排序</p><p>对排序结果倒排索引</p><p>在倒排表内容上拼上数据地址链</p><p>查询时，先拿倒排表内容，再取出数据地址链，从而拿到数据</p><h3 id="主要分类"><a href="#主要分类" class="headerlink" title="主要分类"></a>主要分类</h3><p>普通索引、唯一索引（hash）、主键索引、组合索引、全文索引（full text），BTREE，RTREE</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h2&gt;&lt;p&gt; 连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、缓冲组件、优化器组件、插件式存储引擎、物理文件&lt;/p&gt;
&lt;h2 id=&quot;三</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>kafka常见问题</title>
    <link href="http://example.com/2022/05/23/kafka-1/"/>
    <id>http://example.com/2022/05/23/kafka-1/</id>
    <published>2022-05-23T14:52:45.000Z</published>
    <updated>2022-05-23T14:57:51.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka比RocketMQ吞吐量高的原因"><a href="#Kafka比RocketMQ吞吐量高的原因" class="headerlink" title="Kafka比RocketMQ吞吐量高的原因"></a>Kafka比RocketMQ吞吐量高的原因</h3><p>kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息没有发送到Broker而是<em><strong>在生产者缓存起来</strong></em>，然后直接向业务返回成功。当缓存的消息达到了一定的数量时再分批量发送给Broker。这样就减少了网络IO，从而提高了消息发送的吞吐量，但若消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用该机制提高了性能却降低了可靠性</p><h3 id="Kafka的pull和Push的优缺点"><a href="#Kafka的pull和Push的优缺点" class="headerlink" title="Kafka的pull和Push的优缺点"></a>Kafka的pull和Push的优缺点</h3><p>pull表示消费者主动拉取，可批量拉也可单条拉，所有pull可由消费者自己控制，根据自己的消息处理能力来进行控制，但消费者不能及时知道是否有消息，拉的消息可能为空</p><p>push表示broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就消费多少消息，可能会造成网络堵塞，消费者压力大等问题</p><h3 id="kafka的rebalance机制"><a href="#kafka的rebalance机制" class="headerlink" title="kafka的rebalance机制"></a>kafka的rebalance机制</h3><p>consumer group中的消费者与topic下的partion重新匹配的过程</p><p>产生rebalance的时间： consumer group 中的成员个数发生变化， consumer消费超时，group订阅的topic个数发生变化，group订阅的topic的分区数发生变化</p><p>coordinator（协调者）：是partition的leader节点所在的broker，负责监控group中的consumer的存活，consumer维持到coordinator的心跳，判断consumer的消费超时。    通过心跳返回通知consumer进行rebalance；consumer请求coordinator加入组，coordinator选举产生leader consumer；leader consuemr从coordinator获取所有的consumer，发送syncGroup（分配信息）给到coordinator；coordinator通过心跳机制将syncGroup下发给consumer</p><p>leader consumer监控topic的变化，通知coordinator触发rebalance</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="/2022/05/23/kafka-1/jiagou.png" alt="image-20220501201317495"></p><p>consumer group：消费者组，消费者组内每个消费者负责消费不同分区的数据，提供消费能力。逻辑上的一个订阅者</p><p>topic：理解为一个队列，topic将消息分类，生产者和消费者面向同一个topic</p><p>partition：为了实现拓展性，提供并发能力，一个topic以多个partition的方式分布到多个broker上，每个partition是一个有序的队列。一个topic的每个partition都有若干个副本，一个leader和若干个follower。生产者发送数据的对象，以及消费者消费数据的对象都是leader。follower负责实时从leader中同步数据，保证和leader数据的同步。leader故障，某个follower会成为新的leader</p><h3 id="zookeeper作用"><a href="#zookeeper作用" class="headerlink" title="zookeeper作用"></a>zookeeper作用</h3><p>&#x2F;brokers&#x2F;ids：临时节点，保存所有broker节点信息，存储broker的物理地址、版本信息、启动时间等，节点名称为brokerID，broker定时发送心跳到zk，若断开该brokerID会被删除</p><p>&#x2F;brokers&#x2F;topic：临时节点，节点保存broker节点下所有的topic信息，每一个topic节点下包含一个固定的partition节点，partitions的子节点就是topic的分区，每个分区下保存一个state节点，保存着当前leader分区和ISR的brokerID，leader创建state节点，若leader宕机，该节点会被删除，直到新的leader产生，重新生成state节点</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;owners&#x2F;[topic]&#x2F;[broker_id-partition_id]：维护消费者和分区的注册关系。 比如：consumer下有c1，c2，c3分别与topic下的p1，p2，p3相连，该节点就是记录消费者消费的哪个分区关系。若c1宕机了，p1就没有消费端，就触发rebalance</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;offsets&#x2F;[topic]&#x2F;[broker_id-partition_id]：分区消息的消费进度offset。partition第一次拉取了consumer的第一条消息，第二次就拉取第二条，该节点就记录这个信息  </p><p>client通过topic找到topic树下的state节点，获取leader的brokerID，到broker树找到broker的物理地址，但是client不会直连zk，而是通过配置的broker获取到zk中的信息</p><h3 id="高性能的原因"><a href="#高性能的原因" class="headerlink" title="高性能的原因"></a>高性能的原因</h3><p>指读写性能</p><p>kafka<em><strong>不基于内存</strong></em>，而是硬盘存储，因此消息堆积能力更强，硬盘容量大。文件系统</p><p>顺序写：利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的，节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition物理上分为多个segment存储方便删除</p><p>传统：读取磁盘文件数据到内核缓冲区；将内核缓冲区的数据copy到用户缓冲区；将用户缓冲区的数据copy到socket的发送缓冲区；将socket发送缓冲区的数据发送到网卡，进行传输</p><p>零拷贝：直接将内核缓冲区的数据发送到网卡传输；使用的是操作系统的指令支持</p><p>kafka不太依赖jvm，主要理由操作系统的pageCache，由操作系统决定把数据从pageCache刷到磁盘，若生产消费速率相当，则直接用pageCache交换数据，不需要经过磁盘IO</p><h3 id="消息高可靠的解决方案"><a href="#消息高可靠的解决方案" class="headerlink" title="消息高可靠的解决方案"></a>消息高可靠的解决方案</h3><p>消息发送：</p><p>​ack：0、不重试；1、leader写入成功就返回了；all&#x2F;-1、等待ISR同步完再返回（ISR列表中的follow全部同步完成）</p><p>​unclean.leader.election.enable：false，禁止选举ISR以外的follower为leader。若为true，即允许leader从OSR中选举，即使ack为all，消息也可能丢失，因为leader从OSR中选的话，该follow与之前的leader相比已经差了很大了 </p><p>​tries&gt;1，重试次数</p><p>​min.insync.replicas&gt;1：最小同步副本数，没满足该值前，不提供读写服务、写操作异常</p><p>消费：</p><p>​手工提交offset；</p><p>broker：</p><p>​减少刷盘间隔；事务消息</p><h3 id="消息丢失的场景和解决"><a href="#消息丢失的场景和解决" class="headerlink" title="消息丢失的场景和解决"></a>消息丢失的场景和解决</h3><p>场景：</p><p>​ack&#x3D;0：即producer发送消息完后，不管发送结果了，若发送失败数据也就丢失了</p><p>​ack&#x3D;1，leader crash：producer发送消息后，只等待lead写入成功就返回了，leader crash了，这时follow没来得及同步，消息就丢失了</p><p>​unclean.leader.election.enable 配置为true：即允许OSR节点作为leader，producer发送完消息，只等待leader写入成功就返回了，但leader crash而ISR没有follower，leader就会从OSR选举，而OSR的信息本来就落后于leader，就造成信息发生丢失</p><p>解决：</p><p>发送端</p><p>​ack&#x3D;all&#x2F;-1，tries&gt;1,unclean.leader.election.enable配置为false ：producer发送完消息，等待follower同步完再返回，若异常则重试，副本的数量可能影响吞吐量</p><p>​不允许选举ISR以外的副本作为leader</p><p>​配置：min.insync.replicas&gt;1：<em><strong>副本指定必须确认写操作成功的最小副本数量</strong></em>。若不能满足这个最小值，则生产者将引发一个异常</p><p>​min.insync.relicas和ack跟搭嘎的持久性保证，确保如果大多数副本没有收到写操作，则生产者将引发异常</p><p>​失败的offset单独记录：producer发送消息，会自动重试，遇到不可恢复异常会抛出，这时可以捕获异常记录到数据库或缓存，进行单独处理</p><p>消费端</p><p>​先commit再处理消息，如果在处理消息的时候异常了，但是offset已经提交了，该消息对于该消费者就是丢失了，再也不会被消费到</p><p>​<em><strong>而若先处理，没来得及commit就宕机了，消息就会被重复消费</strong></em></p><p>broker</p><p>​减少刷盘间隔</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kafka&quot;&gt;&lt;a href=&quot;#Kafka&quot; class=&quot;headerlink&quot; title=&quot;Kafka&quot;&gt;&lt;/a&gt;Kafka&lt;/h2&gt;&lt;h3 id=&quot;Kafka比RocketMQ吞吐量高的原因&quot;&gt;&lt;a href=&quot;#Kafka比RocketMQ吞吐量高的原</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
