<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小二小二不停步</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-02T15:18:56.821Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小二小二不停步</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程安全的集合类</title>
    <link href="http://example.com/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://example.com/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2022-07-02T15:11:16.000Z</published>
    <updated>2022-07-02T15:18:56.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全的，它给几乎所有的public方法都加上了synchronized关键字，也正因为如此，加锁导致性能降低，在不需要并发访问同一对象时，这种强制性的同步机制就显得多余，所以现在Vector已被弃用。</p><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>HashTable和HashMap类似，不同点是HashTable是线程安全的，它给几乎所有public方法都加上了synchronized关键字，还有一个不同点是HashTable的K，V都不能是null，但HashMap可以，它现在也因为性能原因被弃用了。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Vector和HashTable被弃用后，它们被ArrayList和HashMap代替，但它们不是线程安全的，所以Collections工具类中提供了相应的包装方法把它们包装成线程安全的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Set&lt;E&gt; synHashSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Map&lt;K,V&gt; synHashMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K,V&gt;());</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步。</p><h1 id="Java-util-concurrent包中的集合"><a href="#Java-util-concurrent包中的集合" class="headerlink" title="Java.util.concurrent包中的集合"></a>Java.util.concurrent包中的集合</h1><h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h4><p>ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而ConcurrentHashMap是更细粒度的加锁。</p><p>在JDK1.8之前，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment含有整个table的一部分，这样不同分段之间的并发操作就互不影响。</p><p>JDK1.8对此做了进一步的改进，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</p><h4 id="2-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#2-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="2.CopyOnWriteArrayList和CopyOnWriteArraySet"></a>2.CopyOnWriteArrayList和CopyOnWriteArraySet</h4><p>它们是加了写锁的ArrayList和ArraySet，锁住的是整个对象，但读操作可以并发执行。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vector&quot;&gt;&lt;a href=&quot;#Vector&quot; class=&quot;headerlink&quot; title=&quot;Vector&quot;&gt;&lt;/a&gt;Vector&lt;/h1&gt;&lt;p&gt;vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Autowired和Resource</title>
    <link href="http://example.com/2022/06/25/Autowired%E5%92%8CResource/"/>
    <id>http://example.com/2022/06/25/Autowired%E5%92%8CResource/</id>
    <published>2022-06-25T13:40:50.000Z</published>
    <updated>2022-06-25T14:34:00.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>@Auwired：</p><p>对成员变量、方法及构造函数进行标注，完成自动装配的工作</p><p>@Resource：</p><p>​官方定义：在语义上被定义为通过其唯一的名称来标识特定的目标组件，其中声明的类型与匹配过程无关</p><p>​若没有明确指定名称，则默认名称是从字段名称或设置方法（get、set方法）派生的。若用在字段上，则采用字段名称；如果用在setter方法，它采用其属性名称（例如setProperty()方法，取property作为属性名称）    </p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>包含的属性不同：</p><p>​Autowired只包含一个参数：required，表示是否开启自动注入，默认是true</p><p>​Resource有七个参数，其中最重要的两个参数：name和type</p><p>注解使用的地方不同：</p><p>​Autowired可以用在构造方法、方法、参数、成员变量和注解上</p><p>​Resource可以用在类、成员变量、方法上</p><p>出处不同：</p><p>​Autowired是Spring定义的注解，所以只能用在Spring框架下</p><p>​Resource是JSR-250定义的注解，所以可以与其他框架一起使用</p><p>自动装配的方式不同：</p><p>​Autowired默认按byType，如果要使用byName，需要结合@Qualifier注解配合使用</p><p>​Resource默认byName自动装配，如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配</p><p>自动装配的顺序：</p><p>​Autowired：默认先按byTpe进行匹配，若发现找到多个bean则又按照byName方式进行匹配，如果还有多个，则抛出异常</p><p>​<img src="/2022/06/25/Autowired%E5%92%8CResource/A.png" alt="image-20220625222414253"></p><p>​Resource：</p><p>​若同时指定了name和type：会从容器中查找name和type唯一匹配bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了name：则按name后的名字去bean元素里查找有与之相等的name属性的bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了type：则从上下文汇总找到类型匹配的<em><strong>唯一</strong></em>bean进行装配，找不到或者找到多个，都会抛出异常</p><p>​都没有指定：自动按照byName方式找，若没有找到符合的bean，则回退为一个原始类型进行查找，如果找到就注入，没找到或者找到多个则抛出异常</p><p>​</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;@Auwired：&lt;/p&gt;
&lt;p&gt;对成员变量、方法及构造函数进行标注，完成自动装配的工作&lt;/p&gt;
&lt;p&gt;@Resource：&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="http://example.com/2022/06/16/Shiro/"/>
    <id>http://example.com/2022/06/16/Shiro/</id>
    <published>2022-06-16T07:20:29.000Z</published>
    <updated>2022-06-16T08:28:04.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/06/16/Shiro/jiegou1.png" alt="image-20220616152612753"></p><p><strong>Subject</strong>：主体，外部应用与subject进行交互，subject记录当前的用户。外部程序通过subject进行认证权限，subject通过Security Manager安全管理进行认证</p><p><strong>Security Manager</strong>：对全部subject进行安全管理，核心。可以对subjectManager完成subject的认证、授权，实质上是通过Authenticator</p><p>本身是一个接口，继承了Authenticator、Authorizer、SessionManager三个接口</p><p><strong>Authenticator</strong>：认证器，对用户身份进行认证，本身是一个接口，shiro提供ModularRealmAuthenticator的实现类，可以满足大部分需求</p><p><strong>Authorizer</strong>：授权器，用户通过授权器，用户通过认证器通过，在访问功能时需要通过授权器判断用户是否能操作的权限</p><p><strong>Realm</strong>：就相当于datasource数据源，subjectManager进行安全认证需要通过Realm获取用户权限数据</p><p><strong>SessionManager</strong>：会话管理，shiro定义了一套会话管理，不依赖web容器的session</p><p><strong>CacheManager</strong>：缓存管理，将用户的权限数据存储在缓存</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>即身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确</p><p>Subject：访问系统的用户，主体可以是用户、程序等</p><p>Principal：身份信息，是主体进行身份认证的标识，标识必须具有唯一性，一个主体可以有多个身份，但必须有一个主身份</p><p>credential：凭证信息，是只有主体自己知道的安全信息</p><h1 id="权限字符串"><a href="#权限字符串" class="headerlink" title="权限字符串"></a>权限字符串</h1><p>资源标识符：操作：资源实例标识符    对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用*通配符。</p><p>比如：用户创建权限   user:create  或 user:create:*</p><p>​用户实例001的所有权限 user:*:001</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><em><strong>以下所有代码来源于“编程不良人”</strong></em></p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 授权</span></span><br><span class="line"><span class="comment">     * @param principals</span></span><br><span class="line"><span class="comment">     * @return AuthorizationInfo</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">//获取身份信息 内容根据实际情况(看源码了解)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">primaryPrincipal</span> <span class="operator">=</span> (String) principals.getPrimaryPrincipal();</span><br><span class="line">        System.out.println(<span class="string">&quot;PrincipalCollection      &quot;</span>+primaryPrincipal);</span><br><span class="line">        <span class="comment">//从工厂中获取service对象</span></span><br><span class="line">        <span class="comment">//根据主身份信息获取角色 和 权限信息</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils</span><br><span class="line">                .getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="comment">//根据userService找到用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findRolesByUserName(primaryPrincipal);</span><br><span class="line">        <span class="comment">//授权角色信息</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(user.getRoles()))&#123;</span><br><span class="line">            <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">            user.getRoles().forEach(role-&gt;&#123;</span><br><span class="line">                <span class="comment">//从数据库中查出来的权限给该对象</span></span><br><span class="line">                simpleAuthorizationInfo.addRole(role.getName());</span><br><span class="line">                <span class="comment">//从数据库中角色具备的权限信息</span></span><br><span class="line">                List&lt;Perms&gt; perms = userService.findPermsByRoleId(role.getId());</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(perms))&#123;</span><br><span class="line">                    perms.forEach(perm-&gt;&#123;</span><br><span class="line">                        <span class="comment">//对该角色赋予相应的权限</span></span><br><span class="line">                        simpleAuthorizationInfo.addStringPermission(perm.getName());</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 身份认证,主体调用用户登录时，会调用该方法</span></span><br><span class="line"><span class="comment">     * @param token</span></span><br><span class="line"><span class="comment">     * @return AuthenticationInfo 里面收集用户提交的身份（比如：用户名）和凭据（比如：密码）</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取身份信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> (String) token.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">credentials</span> <span class="operator">=</span> (String) token.getCredentials();</span><br><span class="line">        <span class="comment">//在工厂中获取service对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUserName(principal);</span><br><span class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(user))&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   用户名</span></span><br><span class="line"><span class="comment">            *   加密的密码</span></span><br><span class="line"><span class="comment">            *   随机盐</span></span><br><span class="line"><span class="comment">            *   当前realm的名称</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user.getUsername(),user.getPassword(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MyByteSource</span>(user.getSalt()),</span><br><span class="line">                    <span class="built_in">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="doGetAuthenticationInfo中的principal和credentials的来源"><a href="#doGetAuthenticationInfo中的principal和credentials的来源" class="headerlink" title="doGetAuthenticationInfo中的principal和credentials的来源"></a>doGetAuthenticationInfo中的principal和credentials的来源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password,String code,HttpSession session)</span> &#123;</span><br><span class="line">       <span class="comment">//比较验证码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">codes</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (codes.equalsIgnoreCase(code))&#123;</span><br><span class="line">               <span class="comment">//获取主体对象</span></span><br><span class="line">               <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">               <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">               <span class="comment">//  重点  重点</span></span><br><span class="line">               <span class="comment">//将该UsernamePasswordToken类对象作为token专递给doGetAuthenticationInfo</span></span><br><span class="line">               subject.login(token);</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码错误!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;用户名错误!&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;密码错误!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/user/loginview&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="UsernamePasswordToken源码"><a href="#UsernamePasswordToken源码" class="headerlink" title="UsernamePasswordToken源码"></a>UsernamePasswordToken源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordToken</span> <span class="keyword">implements</span> <span class="title class_">HostAuthenticationToken</span>, RememberMeAuthenticationToken &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> rememberMe;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"><span class="comment">//省去了所有构造方法以及所有set方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] getPassword() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过该方法得到的username</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRememberMe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rememberMe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.host = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.rememberMe = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.password != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.password.length; ++i) &#123;</span><br><span class="line">                <span class="built_in">this</span>.password[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.password = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义的realm进行操作的配置"><a href="#自定义的realm进行操作的配置" class="headerlink" title="自定义的realm进行操作的配置"></a>自定义的realm进行操作的配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroDialect&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建shiroFilter  //负责拦截所有请求</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager defaultWebSecurityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//给filter设置安全管理器</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   可以实现权限相关的拦截器</span></span><br><span class="line"><span class="comment">         *       常用:</span></span><br><span class="line"><span class="comment">         *           anon:无需认证(登录)也已访问</span></span><br><span class="line"><span class="comment">         *           authc:必须认证和授权才可以访问</span></span><br><span class="line"><span class="comment">         *           user:若使用rememberMe的功能可以直接访问</span></span><br><span class="line"><span class="comment">         *           perms:该资源必须资源权限才可以访问</span></span><br><span class="line"><span class="comment">         *           role：该资源必须得到角色权限</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//配置系统受限资源</span></span><br><span class="line">        <span class="comment">//配置系统公共资源</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/getImage&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/register&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/registerview&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);<span class="comment">//authc 请求这个资源需要认证和授权</span></span><br><span class="line">        <span class="comment">//默认认证界面路径,没有登录的用户就都可以访问的</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/user/loginview&quot;</span>);</span><br><span class="line">        <span class="comment">//放在过滤链里面</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="comment">//未授权的</span></span><br><span class="line">        <span class="comment">//shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建安全管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(Realm realm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//给安全管理器设置</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建自定义realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Realm <span class="title function_">getRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CustomerRealm</span> <span class="variable">customerRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerRealm</span>();</span><br><span class="line">        <span class="comment">//修改凭证校验匹配器</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//设置加密算法为md5</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">//设置散列次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//放入realm</span></span><br><span class="line">        customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="comment">//开启缓存管理，用redis缓存信息</span></span><br><span class="line">        customerRealm.setCacheManager(<span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>());</span><br><span class="line">        customerRealm.setCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启全局缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCachingEnabled(<span class="literal">true</span>);<span class="comment">//认证认证缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCacheName(<span class="string">&quot;authenticationCache&quot;</span>);</span><br><span class="line">        customerRealm.setAuthorizationCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启授权缓存</span></span><br><span class="line">        customerRealm.setAuthorizationCacheName(<span class="string">&quot;authorizationCache&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customerRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的RediscacheManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title class_">CacheManager</span> &#123;</span><br><span class="line">    <span class="comment">//参数1:认证或者是授权缓存的统一名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; Cache&lt;K, V&gt; <span class="title function_">getCache</span><span class="params">(String cacheName)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;redis Cache      &quot;</span>+cacheName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCache</span>&lt;K,V&gt;(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现redis作为缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span>&lt;k,v&gt; <span class="keyword">implements</span> <span class="title class_">Cache</span>&lt;k,v&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cacheName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">(String cacheName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheName = cacheName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get              &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;get key:&quot;</span>+k);</span><br><span class="line">        System.out.println( <span class="string">&quot;redis  get value     &quot;</span>+getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString()));</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">put</span><span class="params">(k k, v v)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;put           &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;put key: &quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;put value:&quot;</span>+v);</span><br><span class="line">        getRedisTemplate().opsForHash().put(<span class="built_in">this</span>.cacheName,k.toString(),v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">remove</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============remove=============&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().delete(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;=============clear==============&quot;</span>);</span><br><span class="line">        getRedisTemplate().delete(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().size(<span class="built_in">this</span>.cacheName).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;k&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().keys(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;v&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().values(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate <span class="title function_">getRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用于接口（接口式）"><a href="#作用于接口（接口式）" class="headerlink" title="作用于接口（接口式）"></a>作用于接口（接口式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@RequiresRoles(value=&#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span><span class="comment">//用来判断角色  Logical.OR:满足其中一个就行   logical = Logical.AND:要同时满足</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;user:update:01&quot;)</span> <span class="comment">//用来判断权限字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入方法多个&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用于接口（编程式）"><a href="#作用于接口（编程式）" class="headerlink" title="作用于接口（编程式）"></a>作用于接口（编程式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">save1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">       <span class="keyword">if</span> (subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">           <span class="comment">//有权限</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有权限</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外还有标签式，因采用前后端分离，便不再展示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应</summary>
      
    
    
    
    <category term="权限框架" scheme="http://example.com/categories/%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud简单阐述</title>
    <link href="http://example.com/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <id>http://example.com/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</id>
    <published>2022-06-15T07:21:38.000Z</published>
    <updated>2022-06-15T08:24:20.406Z</updated>
    
    <content type="html"><![CDATA[<p>Spring社区有大一统java的趋势，快速构建一个单体单元SpringBoot，分布式微服务解决方案，SpringCloud和SpringFrameWork和各种组件等等</p><p>SpringCloud是一个分布式的微服务解决方案。区别于Dubbo，Dubbo只是一个远程RPC框架，而前者则是一整套的解决方案，包括<strong>服务注册、服务调用、负载均衡、服务网关、服务降级与熔断、分布式配置管理、消息总线</strong>等等技术。</p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou3.png" alt="1"></p><p>SpringCloud 是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。</p><p>通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p><p>SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix</p><h2 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h2><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/eureka.png" alt="1"></p><p>作用：实现服务治理（服务注册与发现）</p><p>简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</p><p>由两个组件组成：Eureka服务端和Eureka客户端。</p><p>Eureka服务端用作服务注册中心。支持集群部署。</p><p>Eureka客户端是一个java客户端，用来处理服务注册与发现。</p><p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个组件可实现自动拼接服务地址</p><ul><li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li><li>接着你要是调用那个接口，<strong>本质就是会调用 Feign创建的动态代理</strong></li><li>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来<strong>动态构造出你要请求的服务的地址</strong></li><li>最后针对这个地址，发起请求、解析响应</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>主要提供客户侧的软件<strong>负载均衡</strong>算法。</p><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p><ul><li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</li><li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li><li>Feign就会针对这台机器，构造并发起请求。</li></ul><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>可以在调用服务的时候，在服务出现异常时进行服务熔断和降级避免一直长时间等待服务返回结果而出现雪崩效应</li><li>它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</li></ul><p>熔断：当发现有服务卡死不能工作的时候，熔断器会对他进行熔断，比如这5分钟对这个服务的请求就直接返回了，不要去走网络请求卡几秒钟，这个过程就是溶断！</p><p>降级：就是当服务被熔断后，每次调用这个服务，你就写到单独的数据库中，等这个服务修复后，你手工的添加到业务的数据库中。这个过程就是降级！</p><p>雪崩：如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><h1 id="为什么还要SpringCloudAlibaba？"><a href="#为什么还要SpringCloudAlibaba？" class="headerlink" title="为什么还要SpringCloudAlibaba？"></a>为什么还要SpringCloudAlibaba？</h1><p>因为SpringCloud版本迭代非常快，每次发布一个realease之后又会马上发布下一个版本，所以可能会积累很多bug，而若是进入到了维护阶段，意味着不会再有新的组件技术出现，只是在原来的技术上修改。</p><h1 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title="SpringCloudAlibaba"></a>SpringCloudAlibaba</h1><p>是Spring cloud的子项目，符合SpringCloud的标准，致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li></ul><h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><p>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。<br>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。<br>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。<br>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。<br>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。<br>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。<br>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。<br><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou1.png" alt="1"></p><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou2.png" alt="1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring社区有大一统java的趋势，快速构建一个单体单元SpringBoot，分布式微服务解决方案，SpringCloud和SpringFrameWork和各种组件等等&lt;/p&gt;
&lt;p&gt;SpringCloud是一个分布式的微服务解决方案。区别于Dubbo，Dubbo只是一</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Bean</title>
    <link href="http://example.com/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-06-14T05:21:37.000Z</published>
    <updated>2022-06-14T07:21:29.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置Bean"><a href="#配置Bean" class="headerlink" title="配置Bean"></a>配置Bean</h1><p>两种方式：在xml中写<bean>标签，用@Bean注解</bean></p><p>两个方法都在sping的refresh方法中都会用loadBeanDefinitions加载到容器里面，通过BeanDefinitionRegistry.register方法，会包括一些后置处理</p><h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><p>配置bean之后就拿到了BeanDefinition，是配置bean的加载结果，也是下面步骤的原始数据。</p><p>Spring在启动时，会扫描到类的信息，将相关信息封装为BeanDefinition存入到beanDefinitionMap中，根据里面的扫描信息生成bean                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><p>注意：beanName、ClassType。</p><p>提前初始化：把那个没有配置的懒加载bean开始初始化</p><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>入参实际上只有一个beanName，与beanDefinition的两个属性相对应，通过beanName然后找到beanType，找到type之后调用&#x3D;&#x3D;反射&#x3D;&#x3D;返回了一object。</p><p>反射的大致：获取class对象得到一个构造器，Constructor ctor&#x3D;clazz.getDeclaredConstructor()，Object obj &#x3D; ctor.newInstance()。</p><p>容器中按照使用者来分，可以把bean对象分为用户自定义对象、容器对象（比如：ApplicationContext、BeanFactory等等）</p><p>注意：InstantiationAwareBeanPostProcessor去生成代理类回来</p><h1 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h1><p>此处就需要解决循环依赖-三级缓存</p><p>给自定义属性赋值：核心在于populateBean里面的autowireByName、autowireByType两个方法（@Autowire，@Resource）</p><p>给容器对象属性赋值：invokeAwareMethods</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>对象的拓展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220614145857358.png" alt="image-20220614145857358"></p><p>在属性赋值阶段后，postProcessBeforeInitialization方法之前，会执行很多Aware类型的接口，这种接口类型作用就是加载到Spring容器中，Aware前面的名字就是对应哪种资源</p><p>aware：如果实现了某些接口，比如BeanNameAware、BeanFactoryAware、ApplicationContextAware，就把这些实例给set进去。</p><p>初始化的方式有三个：分别是Initialization的afterPropertiesSet方法；PostConstruct注解标注方法；配置的init-method</p><p>BeanPostProcessor实现了AOP，AOP就是在整个IOC处理流程中某一个拓展点的实现</p><p>执行完就是一个完成的对象</p><h1 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h1><p>要么去实现DisposableBean接口，要么去定义destory-method方法 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置Bean&quot;&gt;&lt;a href=&quot;#配置Bean&quot; class=&quot;headerlink&quot; title=&quot;配置Bean&quot;&gt;&lt;/a&gt;配置Bean&lt;/h1&gt;&lt;p&gt;两种方式：在xml中写&lt;bean&gt;标签，用@Bean注解&lt;/bean&gt;&lt;/p&gt;
&lt;p&gt;两个方法都在sping</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Bean" scheme="http://example.com/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>循环依赖</title>
    <link href="http://example.com/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://example.com/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-06-13T08:33:50.000Z</published>
    <updated>2022-06-13T16:05:15.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环依赖问题简述"><a href="#循环依赖问题简述" class="headerlink" title="循环依赖问题简述"></a>循环依赖问题简述</h1><p><img src="/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/question.png" alt="image-20220613223428341"></p><p>如图所示，在创建对象A的时候，需要依赖注入对象B，但此时容器里面并没有B，所以去创建B，B在创建的过程中又需要A的注入，而此时A在等待B的创建，所以就造成了双方都在等待，类似的“死锁”的情况，导致两者都无法创建成功。</p><p>创建Spring Bean对象到初始化的大致流程</p><p>getSingleton：从单例池中获取bean对象，若没有就创建</p><p>doCreateBean：创建bean对象</p><p>populateBean：填充依赖，若被填充的对象不存在于单例池中，则进行创建</p><p>addSingleton：将初始化完成的对象加入到单例池</p><h1 id="三级循环"><a href="#三级循环" class="headerlink" title="三级循环"></a>三级循环</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">//一级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一级缓存：是成品，里面是完成生命周期的对象，是完成的bean，可以被任意使用</p><p>二级缓存：是半成品，不完整，里面是刚刚实例化但是没有全部实例化的原始对象</p><p>三级缓存：里面的bean是构造器反射创建出来的bean，没有任何的填充属性，单例工程的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">        <span class="comment">//从singletonObjects（一级缓存）尝试获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//如果一次缓存中获取不到并且对象正在创建中，就在二级缓存中查找</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//二级缓存中也查找不到且允许从三级缓存中经过getObject获取</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">               <span class="comment">//对一级缓存进行加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">//一级缓存获取不到</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//二级缓存还是获取不到</span></span><br><span class="line">                        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//获取工厂</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//就从三级缓存中得到bean</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">//若是获取到了，就将singletonObject放入到二级缓存中，并移除三级缓存中的实例</span></span><br><span class="line">                                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isSingletonCurrentlyInCreation（）：判断当前的单例bean是否正在创建的过程中，即没有执行初始化方法</span><br><span class="line">allowEarlyReference：是否允许从三级缓存中经过getObject()方法获取bean对象</span><br></pre></td></tr></table></figure><p>大致：</p><p>Spring会先从一级缓存中去获取bean对象</p><p>获取不到而且对象正在建立中，就会尝试从二级缓存中获取bean</p><p>若还是获取不到，且允许从第三次缓存中的getObject()获取对象，就尝试从三级缓存中获取</p><p>若是三级缓存中获取到了bean，就会将bean放入二级缓存中</p><p>如上图A、B在三级缓存中的迁移过程：</p><p>1创建对象A，完成生命周期第一步（实例化），在调用createBeanInstance方法后，会调用addSingletonFactory方法，将已实例化但未属性赋值未初始化的对象放入三级缓存中。即将对象A提早曝光给IOC容器</p><p>2执行对象A生命周期第二步（属性赋值）。此时，发现对象A依赖对象B，所以就会尝试去获取对象B</p><p>3发现B没有被创建，所以会执行创建对象B的过程</p><p>4创建对象B的过程中，执行实例化和属性赋值操作，此时发生对象B依赖对象A</p><p>5 尝试去缓存中查找对象A。从一级缓存开始找，没有对象A（因为对象A此时还没有初始化完成）；再找二级缓存，也没有对象A（此时的对象A还没有进行属性赋值）；转而查找三级缓存，对象B通过singletonFactory.getObject();拿到对象A</p><p>6对象B获取到对象A后，继续执行生命周期，属性赋值、初始化操作。对象B完成初始化操作后，会被存到一级缓存中</p><p>7转到【对象A执行属性赋值过程并发现依赖了对象B】的阶段，此时对象已经可以从一级缓存中获取到对象B。所以可以顺利执行属性赋值操作</p><p>8对象A执行初始化操作，完成后，对象A也会放到一级缓存中</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>Spring进行扫描-&gt;反射后封装成beanDefinition对象-&gt;放入beanDefinitionMap-&gt;遍历map-&gt;验证（是否单例、是否延迟加载、是否抽象）-&gt;推断构造方法-&gt;准备开始进行实例-&gt;去单例池中查，没有-&gt;去二级缓存中找，没有提前暴露-&gt;生成一个objectFactory对象暴露到二级缓存中-&gt;属性注入，发现依赖Y-&gt;此时Y开始它的生命周期直到属性注入，发现依赖X-&gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;完成循环依赖。</p><h1 id="Spring为什么不能解决非单例Bean的循环依赖"><a href="#Spring为什么不能解决非单例Bean的循环依赖" class="headerlink" title="Spring为什么不能解决非单例Bean的循环依赖"></a>Spring为什么不能解决非单例Bean的循环依赖</h1><p>该问题可以分为：</p><p>Spring为什么不能解决构造器的循环依赖？</p><p>​因为对象的构造函数实在实例化阶段调用。因为在对象实例化后，会将对象放到三级缓存中。在调用对象的构造函数时，对象还没有初始化，所以不能把对象放入三级缓存中。在构造函数注入时，两个对象都没在三级缓存中，所以两个bean都不能实例化</p><p>Spring为什么不能解决prototype作用域循环依赖？</p><p>​IOC只会管理Bean的生命周期，并将单例Bean存放到缓存池中（三级缓存）。Spring不会管理prototype作用域的bean</p><p>Spring为什么不能解决多例的循环依赖?</p><p>​多实例Bean每次调用getBean都会创建一个新的Bean对象，该对象不能缓存。而解决循环依赖是通过缓存实现</p><h1 id="非单实例对象怎么解决？"><a href="#非单实例对象怎么解决？" class="headerlink" title="非单实例对象怎么解决？"></a>非单实例对象怎么解决？</h1><p>对于构造器注入产生的循环依赖，使用@Lazy注解，延迟加载</p><p>对于多例bean和prototype作用域产生的循环依赖，可以尝试改为单例Bean</p><h1 id="为什么一定要三级缓存"><a href="#为什么一定要三级缓存" class="headerlink" title="为什么一定要三级缓存"></a>为什么一定要三级缓存</h1><p><strong>如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理</strong></p><p>使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于 IOC 的考虑，而是出于 AOP 的考虑，即若使用二级缓存，在 AOP 情形注入到其他 Bean的，不是最终的代理对象，而是原始对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;循环依赖问题简述&quot;&gt;&lt;a href=&quot;#循环依赖问题简述&quot; class=&quot;headerlink&quot; title=&quot;循环依赖问题简述&quot;&gt;&lt;/a&gt;循环依赖问题简述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap部分解析</title>
    <link href="http://example.com/2022/06/09/concurrentHashMap/"/>
    <id>http://example.com/2022/06/09/concurrentHashMap/</id>
    <published>2022-06-09T06:17:13.000Z</published>
    <updated>2022-06-09T06:21:08.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><img src="/2022/06/09/concurrentHashMap/jiegou.png" alt="image-20220609111027013"></p><p>JDK1.7：本质上是一个16个Segment对象的数组，每个Segment都是HashEntry&lt;K,V&gt;[] table，每个table包含若干个HashEntry对象连接起来的链表。get、put等操作只锁当前需要用的桶。即分段数组+链表。</p><p>实现上与hashMap类似，只是采用了分段锁，每个分段锁维护着几个桶（hashEntry），&#x3D;&#x3D;多个线程可以同时访问不同分段锁上的桶&#x3D;&#x3D;</p><p>concurrentHashMap中含有几个segment数组 ，每个segment又含有几个hashEntry数组</p><p>JDK1.8：没有使用段锁，而是采用了Node数组+链表+红黑树的方式</p><h4 id="构造方法（1-8）"><a href="#构造方法（1-8）" class="headerlink" title="构造方法（1.8）"></a>构造方法（1.8）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量              扩容因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, </span></span><br><span class="line"><span class="params">     //并发级别（当前concurrentHashMap对象，最多同时支持多少线程同时操作）segment数组的长度。但是不会随着扩容长度发生变化（因为有了最大的限制）</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//以上均是防止传非法数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Put（1-8）"><a href="#Put（1-8）" class="headerlink" title="Put（1.8）"></a>Put（1.8）</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="comment">//首先就是不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());<span class="comment">//基于key进行计算，一定是正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录某个桶上元素的个数，若&gt;8就转变为红黑树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//是否要初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//根据下标计算，若f为空，数组的这个位置就没有元素，所以加进去就可以退出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//CAS操作，防止多个线程同时进行</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出值判断hash值，判断是否是forwar节点（代表是否正在扩容）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//锁这个节点，保证该节点的元素插入是安全的（不影响其他节点）。即保证安全又保证效率</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//为什么还要判断？ 防止变成树后节点发生了变化</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//fh&gt;0就代表是一个链表结构</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//遍历依次比对</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//原数组里面没有，就需要添加新的节点</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//不是&gt;0就不是链表结构，就是树结构</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以上就添加结束，就开始维护</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//泊松分布</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)  <span class="comment">//TREEIFY_THRESHOLD=8</span></span><br><span class="line">                        <span class="comment">//触发变成树的可能函数</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护集合长度，是否扩容</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Get（1-8）"><a href="#Get（1-8）" class="headerlink" title="Get（1.8）"></a>Get（1.8）</h4><p>  计算hash值</p><p>根据hash值计算得到数组相应的位置</p><p>在该位置进行针对性的查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">//计算值，将保存数据的table赋值给tab，且判断数组是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//该数组下标所对应的值</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组上的值就是所要查找的值</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//就表示正在进行扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//直接遍历链表需要所要查找的值</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现高效并发机制的保证：</p><p>通过不加锁和加锁的两种方案控制跨段操作的安全性</p><p>通过HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作</p><p>（理想操作）可以支持16个线程执行并发写操作，及任意数量线程的读操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Map" scheme="http://example.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="http://example.com/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-05-28T15:56:14.000Z</published>
    <updated>2022-05-28T15:57:41.179Z</updated>
    
    <content type="html"><![CDATA[<p>微服务是一种架构风格，即将单体应用划分为小型的服务单元，微服务之间使用 HTTP 的 API 进行资源访问与操作。</p><p>在笔者看来，微服务架构的演变更像是一个公司的发展过程，从最开始的小公司，到后来的大集团。大集团可拆分出多个子公司，每个子公司的都有自己独立的业务、员工，各自发展，互不影响，合起来则是威力无穷。</p><p>臃肿的系统、重复的代码、超长的启动时间带给开发人员的只有无限的埋怨，丝毫没有那种很舒服的、很流畅的写代码的感觉。他们把大部分时间都花在解决问题和项目启动上面了。</p><h3 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h3><p>使用微服务架构能够为我们带来如下好处：</p><h4 id="1）服务的独立部署"><a href="#1）服务的独立部署" class="headerlink" title="1）服务的独立部署"></a>1）服务的独立部署</h4><p>每个服务都是一个独立的项目，可以独立部署，不依赖于其他服务，耦合性低。</p><h4 id="2）服务的快速启动"><a href="#2）服务的快速启动" class="headerlink" title="2）服务的快速启动"></a>2）服务的快速启动</h4><p>拆分之后服务启动的速度必然要比拆分之前快很多，因为依赖的库少了，代码量也少了。</p><h4 id="3）更加适合敏捷开发"><a href="#3）更加适合敏捷开发" class="headerlink" title="3）更加适合敏捷开发"></a>3）更加适合敏捷开发</h4><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行。服务拆分可以快速发布新版本，修改哪个服务只需要发布对应的服务即可，不用整体重新发布。</p><h4 id="4）职责专一，由专门的团队负责专门的服务"><a href="#4）职责专一，由专门的团队负责专门的服务" class="headerlink" title="4）职责专一，由专门的团队负责专门的服务"></a>4）职责专一，由专门的团队负责专门的服务</h4><p>业务发展迅速时，研发人员也会越来越多，每个团队可以负责对应的业务线，服务的拆分有利于团队之间的分工。</p><h4 id="5）服务可以按需动态扩容"><a href="#5）服务可以按需动态扩容" class="headerlink" title="5）服务可以按需动态扩容"></a>5）服务可以按需动态扩容</h4><p>当某个服务的访问量较大时，我们只需要将这个服务扩容即可。</p><h4 id="6）代码的复用"><a href="#6）代码的复用" class="headerlink" title="6）代码的复用"></a>6）代码的复用</h4><p>每个服务都提供 REST API，所有的基础服务都必须抽出来，很多的底层实现都可以以接口方式提供。</p><h3 id="微服务架构的劣势"><a href="#微服务架构的劣势" class="headerlink" title="微服务架构的劣势"></a>微服务架构的劣势</h3><p>微服务其实是一把双刃剑，有利有弊。下面我们来谈谈微服务有哪些弊端，以及能采取什么办法避免。</p><h4 id="1）分布式部署，调用的复杂性高"><a href="#1）分布式部署，调用的复杂性高" class="headerlink" title="1）分布式部署，调用的复杂性高"></a>1）分布式部署，调用的复杂性高</h4><p>单体应用的时候，所有模块之前的调用都是在本地进行的，在微服务中，每个模块都是独立部署的，通过 HTTP 来进行通信，这当中会产生很多问题，比如网络问题、容错问题、调用关系等。</p><h4 id="2）独立的数据库，分布式事务的挑战"><a href="#2）独立的数据库，分布式事务的挑战" class="headerlink" title="2）独立的数据库，分布式事务的挑战"></a>2）独立的数据库，分布式事务的挑战</h4><p>每个微服务都有自己的数据库，这就是所谓的去中心化的数据管理。这种模式的优点在于不同的服务，可以选择适合自身业务的数据，比如订单服务可以用 MySQL、评论服务可以用 MongoDB、商品搜索服务可以用 ElasticSearch。</p><p>缺点就是事务的问题了，目前最理想的解决方案就是柔性事务中的最终一致性，后面的章节会给大家做具体介绍。</p><h4 id="3）测试的难度提升"><a href="#3）测试的难度提升" class="headerlink" title="3）测试的难度提升"></a>3）测试的难度提升</h4><p>服务和服务之间通过接口来交互，当接口有改变的时候，对所有的调用方都是有影响的，这时自动化测试就显得非常重要了，如果要靠人工一个个接口去测试，那工作量就太大了。这里要强调一点，就是 API 文档的管理尤为重要。</p><h4 id="4）运维难度的提升"><a href="#4）运维难度的提升" class="headerlink" title="4）运维难度的提升"></a>4）运维难度的提升</h4><p>在采用传统的单体应用时，我们可能只需要关注一个 Tomcat 的集群、一个 MySQL 的集群就可以了，但这在微服务架构下是行不通的。当业务增加时，服务也将越来越多，服务的部署、监控将变得非常复杂，这个时候对于运维的要求就高了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微服务是一种架构风格，即将单体应用划分为小型的服务单元，微服务之间使用 HTTP 的 API 进行资源访问与操作。&lt;/p&gt;
&lt;p&gt;在笔者看来，微服务架构的演变更像是一个公司的发展过程，从最开始的小公司，到后来的大集团。大集团可拆分出多个子公司，每个子公司的都有自己独立的业务</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>父类子类加载顺序</title>
    <link href="http://example.com/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-05-27T02:56:23.000Z</published>
    <updated>2022-05-27T03:12:56.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><p>父类静态属性（成员变量） &gt; 父类静态代码块 &gt; 子类静态属性 &gt; 子类静态代码块 &gt; 父类非静态属性 &gt; 父类非静态代码块 &gt; 父类构造器 &gt; 子类非静态属性 &gt; 子类非静态代码块 &gt; 子类构造器</p><p>简而言之就是先静态后非静态，先父类后子类</p><ol><li>父类静态变量</li><li>父类静态代码块（若有多个按代码先后顺序执行）</li><li>子类静态变量</li><li>子类静态代码块（若有多个按代码先后顺序执行）</li><li>父类非静态变量</li><li>父类非静态代码块（若有多个按代码先后顺序执行）</li><li>父类构造函数</li><li>子类非静态变量</li><li>子类非静态代码块（若有多个按代码先后顺序执行）</li><li>子类构造函数</li></ol><p><em><strong>所有的静态资源都只会被加载一次，非静态资源可以被重复加载</strong></em></p><h1 id="类初始化和实例初始化"><a href="#类初始化和实例初始化" class="headerlink" title="类初始化和实例初始化"></a>类初始化和实例初始化</h1><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>一个类要创建实例需要先加载并初始化该类</p><p>  Main方法所在的类需要先加载和初始化</p><p>子类要初始化需要先初始化父类</p><p>一个类初始化就是执行<clinit>()方法 类初始化方法</clinit></p><p>  <clinit>()方法由静态类变量显示赋值代码和静态代码块组成</clinit></p><p>  类变量显示赋值代码和静态代码块代码从上到下顺序执行</p><h2 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h2><p>就是执行<init>()方法</init></p><p>  <init>()方法可能重载有多个，有几个构造器就有几个<init>方法</init></init></p><p>  <init>()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成</init></p><p>  非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应的构造器的代码最后执行</p><p>  每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法</init></p><p>  <init>方法的首行就是super()或super（实参列表），即对应父类的<init>方法</init></init></p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>不能被重写的方法</p><p>Final方法</p><p>  静态方法</p><p>  Private等子类中不可见的方法</p><p>多态性</p><p>  子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码</p><p>  非静态方法默认的调用对象是this</p><p>  This对象在构造器或者说<init>方法中就是正在创建的对象</init></p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法被子类重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Son()&#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//写或不写都在，一定会会调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="小结特点"><a href="#小结特点" class="headerlink" title="小结特点"></a>小结特点</h1><ol><li>静态属性和代码块，当且仅当该类在程序中第一次被 new 或者第一次被类加载器调用时才会触发（不考虑永久代的回收）。也正是因为上述原因，<strong>类优先于对象</strong> 加载&#x2F;new，即 <strong>静态优先于非静态</strong>。</li><li>属性（成员变量）优先于构造方法，可以这么理解，加载这整个类，需要先知道类具有哪些属性，并且这些属性初始化完毕之后，这个类的对象才算是<strong>完整的</strong>。另外，非静态代码块其实就是对象 new 的准备工作之一，算是一个不接受任何外来参数的构造方法。因此，<strong>属性 &gt; 非静态代码块 &gt; 构造方法。</strong></li><li>有趣的是，<strong>静态部分（前4个）是父类 &gt; 子类</strong>，而 <strong>非静态部分也是父类 &gt; 子类。</strong></li><li>另外容易忽略的是，非静态代码块在每次 new 对象时都会运行，可以理解：<strong>非静态代码块是正式构造方法前的准备工作</strong>（非静态代码块 &gt; 构造方法）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;加载顺序&quot;&gt;&lt;a href=&quot;#加载顺序&quot; class=&quot;headerlink&quot; title=&quot;加载顺序&quot;&gt;&lt;/a&gt;加载顺序&lt;/h1&gt;&lt;p&gt;父类静态属性（成员变量） &amp;gt; 父类静态代码块 &amp;gt; 子类静态属性 &amp;gt; 子类静态代码块 &amp;gt; 父类非静态属</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-26T06:18:56.000Z</published>
    <updated>2022-05-26T06:49:47.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>实现单例模式三个主要特点：</p><p>1、构造方法私有化；<br>2、实例化的变量引用私有化；<br>3、获取实例的方法共有。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>静态化实例对象</p><p>私有化构造方法，禁止通过构造方法创建实例</p><p>提供一个公共的静态方法，用来返回唯一的实例</p><h1 id="单例的好处"><a href="#单例的好处" class="headerlink" title="单例的好处"></a>单例的好处</h1><p>整个系统只存在一个对象，内存开始少，性能好</p><p>避免对资源的多重占用</p><p>在系统设置全局访问点，优化和共享资源访问</p><h1 id="不同创建方式"><a href="#不同创建方式" class="headerlink" title="不同创建方式"></a>不同创建方式</h1><p>饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//向外提供   自行创建   不能更改(单例)</span></span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">static</span>    <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的懒汉式：线程不安全，不可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内部类加载：静态内部类不会随着外部类的加载和初始化而初始化。因为是在内部类加载和初始化时创建的。所以线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h1><p>反射</p><p>常见的单例模式实现中，往往有一个私有的构造函数，防止外部程序的调用，但是通过反射可以轻而易举的破坏这个限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> singleton.getSingleton();</span><br><span class="line">            Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">reflectInstance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">            System.out.println(S\singleton == reflectInstance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：false，单例被破坏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>序列化</p><p>其中 Singleton 实现了 Serializable 接口，才有可能通过序列化破坏单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>克隆</p><p>实现 Cloneable 接口重写 clone 方法</p><h1 id="枚举类详解"><a href="#枚举类详解" class="headerlink" title="枚举类详解"></a>枚举类详解</h1><p>Joshua Bloch大神在《Effective Java》中明确表达过的观点：使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法</p><p>枚举类型单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">public</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类的单例模式优点</p><p>写法简单</p><p>枚举会自己处理序列化：<em><strong>传统的单例存在一个问题，一旦实现了序列化接口，那么就不再保持单例</strong></em>，因为readObject()方法一直返回一个新的对象，就像java的构造方法一样</p><p>枚举类创建的是thread-safe</p><p>面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点</p><p>在序列化的过程中Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。</p><p>如上，序列化的时候只将 INSTANCE这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。</p><h1 id="不会被破坏单例的原因"><a href="#不会被破坏单例的原因" class="headerlink" title="不会被破坏单例的原因"></a>不会被破坏单例的原因</h1><p>通过枚举实现的单例模式，利用反射构造新的对象，由于 <a href="https://so.csdn.net/so/search?q=enum&spm=1001.2101.3001.7020">enum</a> 没有无参构造器，结果会抛出 NoSuchMethodException 异常;</p><p>枚举类不实现 Serializable 接口，都可以进行序列化，并且返回原来的单例;</p><p>Enum 类中 clone 的方法是 final 类型，无法重写，也就不能通过克隆破坏单例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h1&gt;&lt;p&gt;实现单例模式三个主要特点：&lt;/p&gt;
&lt;p&gt;1、构造方法私有化；&lt;br&gt;2、实例化的变量引用私有化；&lt;</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="枚举" scheme="http://example.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础</title>
    <link href="http://example.com/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-25T12:47:24.000Z</published>
    <updated>2022-05-25T12:53:41.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>是管理计算机硬件与软件资源的程序</p><p>本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件的资源</p><p>屏蔽了硬件层的复杂性</p><p>内核是操作系统核心，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</p><h2 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h2><p>处理器的执行状态分为内核态和用户态，就是为了避免操作系统和关键字数据被用户程序破坏</p><p>内核态：是操作系统管理程序执行时所处状态，能执行包含特权指令在内的所有指令，能访问系统内所有的存储空间</p><p>用户态：用户态运行的进程或可以直接遁去用户程序的数据</p><h2 id="实现内核态和用户态的切换"><a href="#实现内核态和用户态的切换" class="headerlink" title="实现内核态和用户态的切换"></a>实现内核态和用户态的切换</h2><p>系统调用：是操作系统的最小功能单位，操作系统提供的用户接口，本身是一种软中断。</p><p>异常：也叫内中断，由错误引起</p><p>外中断: 通过两根信号线来通知处理器外设的状态变化，是硬中断</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配的基本单位，独立运行的基本单位</p><p>由以下组成：</p><p>  进程控制块PCB，进程唯一存在标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级，CPU现场保护区（用户进程切换），占有的资源清单</p><p>  程序段</p><p>  数据段</p><p>状态：</p><p>  创建态（进程正在被创建）</p><p>就绪态（除了CPU，其他资源都有，一个系统中可有多个进程处于该状态）、</p><p>运行态（占有处理器正在运行）、</p><p>阻塞态（不具备运行条件，在等待某个时间完成）</p><p>  结束态（进程正在从系统中消失）</p><p>孤儿进程：父进程退出，子进程还在运行。将被init进程收养</p><p>僵尸进程：进程使用fork创建子进程，若子进程退出，而父进程没有调用wait或waitpid获取子进程状态信息，那子进程的进程描述符仍然保存在系统中</p><h3 id="进程间的通信方法"><a href="#进程间的通信方法" class="headerlink" title="进程间的通信方法"></a>进程间的通信方法</h3><p>  每个进程各有不同的用户地址空间，任何一个进程的全局变量在另一个进程看不见。所以，进程间的交换数据必须在内核：在内核中开辟出一块缓冲区，进程A把数据从用户空间拷贝到内核缓冲区，进程B再从内核缓冲区把数据读走。</p><p>不同进程间的通信本质：进程间可以看到一份公共资源；提供这资源的形式或提供者不同，通信方式也就不同</p><p>主要包括：管道&#x2F;匿名管道，消息队列、信号量、信号、共享内存、套接字socket</p><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>互斥量：互斥对象机制</p><p>信号量：允许同一时刻多线程访问同一资源，但要控制同一时刻最大线程数</p><p>事件：通过通知操作的方式来保持多线程同步</p><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><p>当前运行的进程运行结束、当前运行进程阻塞、执行完系统调用等系统程序后返回用户进程、抢占式调度中有更高优先级的进行就绪、分时系统中，分给当前进程的时间片用完</p><h3 id="不能进行调度的时候"><a href="#不能进行调度的时候" class="headerlink" title="不能进行调度的时候"></a>不能进行调度的时候</h3><p>中断处理程序执行时，操作系统的内核程序临界区内、其他需要完全屏蔽中断的原子操作过程中</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>某个函数、数据库在并发环境中被调用时，能够正确的处理多个线程之间的共享变量，让程序功能正确完成</p><p>上下文就是这样的过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作</p><h3 id="进程同步的方法"><a href="#进程同步的方法" class="headerlink" title="进程同步的方法"></a>进程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程划分的任务，是一个进程内可调度的实体，CPU调度的基本单位，来保证程序的实时性，实现进程内部的并发</p><p>是操作系统可识别的最小执行和调度单位</p><h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p>用Volatile关键字，就是多个线程同时监听一个变量</p><p>Object类的wait和notify</p><p>JUC工具类CountDownLatch</p><h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>比线程更轻量级，不被操作系统管理，完全由程序控制（用户态执行）。这样能提升性能，不会像线程那样切换而消耗资源</p><p>单线程下的并发 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基本概述&lt;/h2&gt;&lt;p&gt;是管理计算机硬件与软件资源的程序&lt;/p&gt;
&lt;p&gt;本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件的资源&lt;/p&gt;
</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="http://example.com/2022/05/24/MySQL-1/"/>
    <id>http://example.com/2022/05/24/MySQL-1/</id>
    <published>2022-05-24T07:22:57.000Z</published>
    <updated>2022-05-24T07:32:00.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三大范式和反模式"><a href="#三大范式和反模式" class="headerlink" title="三大范式和反模式"></a>三大范式和反模式</h2><p>第一：属性不可分割，原子项</p><p>第二：原子性，即非主属性必完全依赖主属性</p><p>第三：原子性，非主属性必完全主属性，且不存在传递依赖</p><p>反模式：解决了旧问题，又产生了新问题。实际开发中，不会严格遵守三范式</p><h2 id="三种引擎"><a href="#三种引擎" class="headerlink" title="三种引擎"></a>三种引擎</h2><p><img src="/2022/05/24/MySQL-1/yinqin.png" alt="引擎"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快</p><p>若主要用于插入新记录和读出记录，该引擎就能实现处理的高效率。若应用的完整性、并发性要求较低，也可</p><p>每次查询具有原子性</p><p>B+树的索引结构</p><p>非聚集性索引，存储会有两个文件，一个索引文件，一个数据文件，其中索引文件的索引指向数据文件中的表数据</p><p>用一个变量保存了整个表的行数，而innodb是全表扫描</p><p>支持全文索引，innodb不支持全文索引（5.7以前）</p><p>可以被压缩后查询</p><p>所以MYISAM只缓存索引块，记录的直接是文件的OFFSET，定位比INNODB块。多以查询比较快</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存存放，hash索引（默认）</p><p>所有数据存在内存汇总，数据的处理速度快，但安全性不高，因对表的大小有要求，不能建太大的表。适用于需要很快的读写速度、安全性要求较低的</p><h3 id="MyISAM-1"><a href="#MyISAM-1" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快</p><p>若主要用于插入新记录和读出记录，该引擎就能实现处理的高效率。若应用的完整性、并发性要求较低，也可</p><p>每次查询具有原子性</p><p>B+树的索引结构</p><p>非聚集性索引，存储会有两个文件，一个索引文件，一个数据文件，其中索引文件的索引指向数据文件中的表数据</p><p>用一个变量保存了整个表的行数，而innodb是全表扫描</p><p>支持全文索引，innodb不支持全文索引（5.7以前）</p><p>可以被压缩后查询</p><p>所以MYISAM只缓存索引块，记录的直接是文件的OFFSET，定位比INNODB块。多以查询比较快</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制，是一种并发控制的方法，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p><em><strong>就是为了实现读写冲突不加锁。</strong></em></p><p>MVCC多版本并发控制：维持一个数据的多个版本，让读写操作没有冲突</p><p>在InnoDB中的实现主要是为了提高数据库并发性能</p><p>使用RC和RR隔离级别的事务，在执行普通selsect操作时，访问记录版本链的过程；让不同事务的读写、写操作并发执行，提高体统性能</p><h3 id="益处"><a href="#益处" class="headerlink" title="益处"></a>益处</h3><p>解决读写冲突的无锁并发控制</p><p>在并发读写时，可在读操作时不用阻塞写操作，写操作不用阻塞读操作，提供读写性能；解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>第一种：将数据记录的多个版本保存在数据库中，当这些版本数据不再需要时，垃圾回收器就回收这些记录</p><p>第二种：只在数据库中保存最新版本的数据，但是在使用undo时动态重构旧版本数据</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>3个隐式字段：分别记录</p><p>​                 最近修改事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</p><p>​                 指向这条记录的上一个版本；</p><p>​                 隐含自增ID，若数据表没有主键，就自动产生一个聚集索引</p><p>Undo日志：</p><p>​        Insert undo log：事务在insert新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>​        Update undo log：在update或delete时产生；事务回滚需要，快照读也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该该日志，才会被统一清除</p><p>Read View：</p><p>​         事务进行快照读操作的时候生产的读视图</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>存储引擎层实现，索引：帮助mysql高效获取数据的数据结构</p><p>提高数据库的性能，不用加内存，不用该程序，不同调sql</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>把无序的数据变成有序的查询</p><p>创建了索引的列的内容进行排序</p><p>对排序结果倒排索引</p><p>在倒排表内容上拼上数据地址链</p><p>查询时，先拿倒排表内容，再取出数据地址链，从而拿到数据</p><h3 id="主要分类"><a href="#主要分类" class="headerlink" title="主要分类"></a>主要分类</h3><p>普通索引、唯一索引（hash）、主键索引、组合索引、全文索引（full text），BTREE，RTREE</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;三大范式和反模式&quot;&gt;&lt;a href=&quot;#三大范式和反模式&quot; class=&quot;headerlink&quot; title=&quot;三大范式和反模式&quot;&gt;&lt;/a&gt;三大范式和反模式&lt;/h2&gt;&lt;p&gt;第一：属性不可分割，原子项&lt;/p&gt;
&lt;p&gt;第二：原子性，即非主属性必完全依赖主属性&lt;/p&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>kafka常见问题</title>
    <link href="http://example.com/2022/05/23/kafka-1/"/>
    <id>http://example.com/2022/05/23/kafka-1/</id>
    <published>2022-05-23T14:52:45.000Z</published>
    <updated>2022-05-23T14:57:51.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka比RocketMQ吞吐量高的原因"><a href="#Kafka比RocketMQ吞吐量高的原因" class="headerlink" title="Kafka比RocketMQ吞吐量高的原因"></a>Kafka比RocketMQ吞吐量高的原因</h3><p>kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息没有发送到Broker而是<em><strong>在生产者缓存起来</strong></em>，然后直接向业务返回成功。当缓存的消息达到了一定的数量时再分批量发送给Broker。这样就减少了网络IO，从而提高了消息发送的吞吐量，但若消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用该机制提高了性能却降低了可靠性</p><h3 id="Kafka的pull和Push的优缺点"><a href="#Kafka的pull和Push的优缺点" class="headerlink" title="Kafka的pull和Push的优缺点"></a>Kafka的pull和Push的优缺点</h3><p>pull表示消费者主动拉取，可批量拉也可单条拉，所有pull可由消费者自己控制，根据自己的消息处理能力来进行控制，但消费者不能及时知道是否有消息，拉的消息可能为空</p><p>push表示broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就消费多少消息，可能会造成网络堵塞，消费者压力大等问题</p><h3 id="kafka的rebalance机制"><a href="#kafka的rebalance机制" class="headerlink" title="kafka的rebalance机制"></a>kafka的rebalance机制</h3><p>consumer group中的消费者与topic下的partion重新匹配的过程</p><p>产生rebalance的时间： consumer group 中的成员个数发生变化， consumer消费超时，group订阅的topic个数发生变化，group订阅的topic的分区数发生变化</p><p>coordinator（协调者）：是partition的leader节点所在的broker，负责监控group中的consumer的存活，consumer维持到coordinator的心跳，判断consumer的消费超时。    通过心跳返回通知consumer进行rebalance；consumer请求coordinator加入组，coordinator选举产生leader consumer；leader consuemr从coordinator获取所有的consumer，发送syncGroup（分配信息）给到coordinator；coordinator通过心跳机制将syncGroup下发给consumer</p><p>leader consumer监控topic的变化，通知coordinator触发rebalance</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="/2022/05/23/kafka-1/jiagou.png" alt="image-20220501201317495"></p><p>consumer group：消费者组，消费者组内每个消费者负责消费不同分区的数据，提供消费能力。逻辑上的一个订阅者</p><p>topic：理解为一个队列，topic将消息分类，生产者和消费者面向同一个topic</p><p>partition：为了实现拓展性，提供并发能力，一个topic以多个partition的方式分布到多个broker上，每个partition是一个有序的队列。一个topic的每个partition都有若干个副本，一个leader和若干个follower。生产者发送数据的对象，以及消费者消费数据的对象都是leader。follower负责实时从leader中同步数据，保证和leader数据的同步。leader故障，某个follower会成为新的leader</p><h3 id="zookeeper作用"><a href="#zookeeper作用" class="headerlink" title="zookeeper作用"></a>zookeeper作用</h3><p>&#x2F;brokers&#x2F;ids：临时节点，保存所有broker节点信息，存储broker的物理地址、版本信息、启动时间等，节点名称为brokerID，broker定时发送心跳到zk，若断开该brokerID会被删除</p><p>&#x2F;brokers&#x2F;topic：临时节点，节点保存broker节点下所有的topic信息，每一个topic节点下包含一个固定的partition节点，partitions的子节点就是topic的分区，每个分区下保存一个state节点，保存着当前leader分区和ISR的brokerID，leader创建state节点，若leader宕机，该节点会被删除，直到新的leader产生，重新生成state节点</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;owners&#x2F;[topic]&#x2F;[broker_id-partition_id]：维护消费者和分区的注册关系。 比如：consumer下有c1，c2，c3分别与topic下的p1，p2，p3相连，该节点就是记录消费者消费的哪个分区关系。若c1宕机了，p1就没有消费端，就触发rebalance</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;offsets&#x2F;[topic]&#x2F;[broker_id-partition_id]：分区消息的消费进度offset。partition第一次拉取了consumer的第一条消息，第二次就拉取第二条，该节点就记录这个信息  </p><p>client通过topic找到topic树下的state节点，获取leader的brokerID，到broker树找到broker的物理地址，但是client不会直连zk，而是通过配置的broker获取到zk中的信息</p><h3 id="高性能的原因"><a href="#高性能的原因" class="headerlink" title="高性能的原因"></a>高性能的原因</h3><p>指读写性能</p><p>kafka<em><strong>不基于内存</strong></em>，而是硬盘存储，因此消息堆积能力更强，硬盘容量大。文件系统</p><p>顺序写：利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的，节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition物理上分为多个segment存储方便删除</p><p>传统：读取磁盘文件数据到内核缓冲区；将内核缓冲区的数据copy到用户缓冲区；将用户缓冲区的数据copy到socket的发送缓冲区；将socket发送缓冲区的数据发送到网卡，进行传输</p><p>零拷贝：直接将内核缓冲区的数据发送到网卡传输；使用的是操作系统的指令支持</p><p>kafka不太依赖jvm，主要理由操作系统的pageCache，由操作系统决定把数据从pageCache刷到磁盘，若生产消费速率相当，则直接用pageCache交换数据，不需要经过磁盘IO</p><h3 id="消息高可靠的解决方案"><a href="#消息高可靠的解决方案" class="headerlink" title="消息高可靠的解决方案"></a>消息高可靠的解决方案</h3><p>消息发送：</p><p>​ack：0、不重试；1、leader写入成功就返回了；all&#x2F;-1、等待ISR同步完再返回（ISR列表中的follow全部同步完成）</p><p>​unclean.leader.election.enable：false，禁止选举ISR以外的follower为leader。若为true，即允许leader从OSR中选举，即使ack为all，消息也可能丢失，因为leader从OSR中选的话，该follow与之前的leader相比已经差了很大了 </p><p>​tries&gt;1，重试次数</p><p>​min.insync.replicas&gt;1：最小同步副本数，没满足该值前，不提供读写服务、写操作异常</p><p>消费：</p><p>​手工提交offset；</p><p>broker：</p><p>​减少刷盘间隔；事务消息</p><h3 id="消息丢失的场景和解决"><a href="#消息丢失的场景和解决" class="headerlink" title="消息丢失的场景和解决"></a>消息丢失的场景和解决</h3><p>场景：</p><p>​ack&#x3D;0：即producer发送消息完后，不管发送结果了，若发送失败数据也就丢失了</p><p>​ack&#x3D;1，leader crash：producer发送消息后，只等待lead写入成功就返回了，leader crash了，这时follow没来得及同步，消息就丢失了</p><p>​unclean.leader.election.enable 配置为true：即允许OSR节点作为leader，producer发送完消息，只等待leader写入成功就返回了，但leader crash而ISR没有follower，leader就会从OSR选举，而OSR的信息本来就落后于leader，就造成信息发生丢失</p><p>解决：</p><p>发送端</p><p>​ack&#x3D;all&#x2F;-1，tries&gt;1,unclean.leader.election.enable配置为false ：producer发送完消息，等待follower同步完再返回，若异常则重试，副本的数量可能影响吞吐量</p><p>​不允许选举ISR以外的副本作为leader</p><p>​配置：min.insync.replicas&gt;1：<em><strong>副本指定必须确认写操作成功的最小副本数量</strong></em>。若不能满足这个最小值，则生产者将引发一个异常</p><p>​min.insync.relicas和ack跟搭嘎的持久性保证，确保如果大多数副本没有收到写操作，则生产者将引发异常</p><p>​失败的offset单独记录：producer发送消息，会自动重试，遇到不可恢复异常会抛出，这时可以捕获异常记录到数据库或缓存，进行单独处理</p><p>消费端</p><p>​先commit再处理消息，如果在处理消息的时候异常了，但是offset已经提交了，该消息对于该消费者就是丢失了，再也不会被消费到</p><p>​<em><strong>而若先处理，没来得及commit就宕机了，消息就会被重复消费</strong></em></p><p>broker</p><p>​减少刷盘间隔</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kafka&quot;&gt;&lt;a href=&quot;#Kafka&quot; class=&quot;headerlink&quot; title=&quot;Kafka&quot;&gt;&lt;/a&gt;Kafka&lt;/h2&gt;&lt;h3 id=&quot;Kafka比RocketMQ吞吐量高的原因&quot;&gt;&lt;a href=&quot;#Kafka比RocketMQ吞吐量高的原</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="http://example.com/2022/05/22/IO/"/>
    <id>http://example.com/2022/05/22/IO/</id>
    <published>2022-05-22T15:10:30.000Z</published>
    <updated>2022-05-22T15:12:17.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><h3 id="阻塞式I-x2F-O"><a href="#阻塞式I-x2F-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h3><p>用户线程发出IO请求后，内核会查看数据是否就绪，若没有就绪，就会等待数据就绪，而一直处于阻塞状态并交出CPU资源</p><h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><p>用户线程发出一个请求后会立刻得到一个结果，若结果是error就再次发起请求，直到得到结果。在此期间会一直占用CPU，因为会一直询问内核数据是否就绪</p><h3 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h3><p>一种机制</p><p>用的较多，NIO就是</p><p>总有一个线程轮询多个socket状态，只有当真正有读写事件时，才真正调用实际的IO读写操作。因为只需要一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不用维护这些，只有真的socket读写事件进行时才使用IO资源。</p><p>该模型用到了select、poll函数，两个函数可以同时阻塞多个I&#x2F;O操作</p><p>函数方法</p><p>selsect：监视的文件描述符分三类，调用select函数会阻塞，直到描述符就绪或超时</p><p>​         缺陷：单线程打开的FD有限制；对socket进行线性扫描（轮询）IO，效率低；限定大小，因为保存文件描述符的bitmaps是1024</p><p>​         阻塞函数，没数据阻塞</p><p>​        一开始是收集文件描述符给内核看哪儿有数据（提高了效率，不然用户态判断会因为切换而浪费资源），有数据的话，FD置位，select函数返回，后面就遍历FD，判断哪个置位并读出数据再处理</p><p>poll：本质与select无区别；将用户给的数组拷贝进内核，查询每个fd对应设备的状态</p><p>若遍历fd都没有就绪设备就挂起当前线程，直到设备就绪或主动超时，被唤醒后再次遍历fd</p><p>​             没有最大连接次数（因为恢复revents）；大量fd数组复制进内核（有些无意义）；若报告的fd没处理，那下次poll会再次报告fd</p><p>​           有超时时间，5个FD拷贝到内核态并监听数据</p><p>​           有数据时内核会对revents字段置位，poll返回，遍历找置位读数据</p><p>Epoll：没有描述符的限制；可水平触发和边缘触发；</p><p>没有最大并发连接的限制；效率提升，不是轮询方式；内存拷贝</p><p>​             连接数较多且很多的不活跃连接时，epoll效率更好；反之，epoll因需要回调，所以性能此时会低</p><p>​             创建了epfd白板，再epoll_ctr，写了结构体；用户态和内核态共享fd内存（不像上面还需要拷贝）；水平触发：重排置位（有数据的放到前面），返回值为有多少个数据，遍历就遍历前几个，进行处理</p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>用户线程发起IO请求，会给对应的socket注册一个信号函数，线程再继续执行，当用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际IO请求操作</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>用户线程发起请求后，就可做其他事，当接收到数据内核返回的成功信号时，就表示IO操作已经完成，可以直接去使用数据</p><h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p>本身是指数据 从源头到目的地</p><p>其中的输入输出流都是在外部文件和内存之间数据的流通</p><p>分为两种：字符流和字节流。InputStream和OutputStream，Reader，Writer</p><h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>底层设备只接收字节数据，字符流是字节流的包装，字符流则是直接接收字符串，它会在内部转成字节，再写入底层设备</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>同步阻塞，服务器实现模式为一个连接一个线程</p><p>服务端：通过serverSocket注册端口；服务器通过调用accept方法用于监听客户端socket请求；从socket中获取字节输入或者输出进行数据读写</p><p>客户端：通过socket独享请求域服务端的连接；从socket得到字节输入或字节输出流进行数据的读写</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>同步非阻塞式，核心类：</p><p>​                 Buffer（缓冲区）为所有原始类型提供缓存支持，是一个容器，连续的数组 </p><p>​                 Charset字符集编码解决解码方案</p><p>​                 Channel（通道）一个新的原始I&#x2F;O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备、程序或是网络的连接</p><p>数据source：需要读取，使用：InputStream、Reader。对应了 硬盘、内存、键盘（System.in）</p><p>数据destination：就是需要写入，使用OutputStram、Writer对应了 硬盘、内存、控制台（System.out）</p><h3 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h3><p>BIO：同步阻塞式IO，就平常使用的，模式简单使用方便，并发处理能力低</p><p>​    是一个连接一个线程</p><p>​    适用于连接数目较小且固定的架构，对服务器资源要求较高</p><p>NIO：同步非阻塞IO，客户端和服务器端通过Channel通讯，多路复用</p><p>​    一个请求一个线程</p><p>​    适用于连接数目多且连接较短的架构，比如聊天服务器</p><p>AIO：NIO的升级，异步非阻塞IO，异步IO操作基于事件和回调机制</p><p>一个有效请求一个线程</p><p>适用于连接数据木多且连接较长的架构，比如相册服务器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;I-x2F-O模型&quot;&gt;&lt;a href=&quot;#I-x2F-O模型&quot; class=&quot;headerlink&quot; title=&quot;I&amp;#x2F;O模型&quot;&gt;&lt;/a&gt;I&amp;#x2F;O模型&lt;/h2&gt;&lt;h3 id=&quot;阻塞式I-x2F-O&quot;&gt;&lt;a href=&quot;#阻塞式I-x2F-O&quot; c</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="IO模型" scheme="http://example.com/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="IO流" scheme="http://example.com/tags/IO%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础-类加载</title>
    <link href="http://example.com/2022/05/21/JVM-2/"/>
    <id>http://example.com/2022/05/21/JVM-2/</id>
    <published>2022-05-21T05:41:56.000Z</published>
    <updated>2022-05-21T05:46:05.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h1><p>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件结构</p><p>ClassLoader只负责class文件的加载，至于是否可以运行，则由ExecutionEngine决定</p><p>加载的类信息存放于一块称为方法区的内存空间，除了类信息外，方法区还有存放运行时常量池的信息，可能还包含字符串自变量和数字常量</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>​    通过一个类的全限定名获取定义此类的二进制字节流（字节码文件）</p><p>​    将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>​    在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><p>​    补充：加载.class文件的方式</p><p>​         从本地系统中直接加载</p><p>​         通过网络获取，典型场景：web Applet</p><p>​         从zip压缩包中读取，成为日后jar，war格式的基础</p><p>​         运行时计算生成，使用最多的是：动态代理技术</p><p>​         由其他文件生成，典型：JSP应用</p><p>​         从专有数据库中提取.class文件，少见</p><p>​         从加密文件获取，典型：防class文件被反编译的保护措施</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>​    验证：目的确保class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性不会危害虚拟机自身安全</p><p>​          主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</p><p>​    准备：为类变量分配并且设置该类变量的默认初始值，即零值</p><p>此处不包含用修饰的static，因为final在编译时就已经会分配了，准备阶段会显示初始化</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中</p><p>​    解析：将常量池的符号引用（不一定已加在内存）转换为直接引用的过程</p><p>​          解析操作往往会伴随着JVM在执行完初始化之后再执行</p><p>​          符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个简介定位到目标的句柄。</p><p>​          解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    初始化过程就是执行类构造器方法<clinit>过程</clinit></p><p>​    也就是只对static修饰的初始化</p><p>​    该方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来</p><p>​    构造器方法中指令按语句在源文件中出现的顺序执行</p><p>​    <clinit>方法不同于类构造器，jvm会保证子类的<clinit>方法执行之前，父类的<clinit>已经执行完毕</clinit></clinit></clinit></p><p>​    虚拟机必须保证一个类的<clinit>方法在多线程下被同步加锁</clinit></p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器：引导类加载器，自定义加载器</p><p>所有派生于抽象类ClassLoader的类加载器都划分于自定义加载器</p><p>Java核心类库都是引导类加载器加载的</p><h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><p>​    该类由c&#x2F;c++实现，嵌套在JVM内部</p><p>​    用来加载java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path），提供JVM自身需要的类</p><p>​    并不继承java.lang.ClassLoader，没有父加载器</p><p>​    加载拓展类和应用程序类加载器，并指定为他们的父类加载器</p><p>​    为了安全，Bootstrap启动类加载器只加载名为java、javax、sun等开头的类</p><p>拓展类加载器（Extension ClassLoader）</p><p>Java编写，由sun.misc.Launcher$ExtClassLoader实现</p><p>派生于ClassLoader类</p><p>父类加载器为启动类加载器</p><p>​    如果用户创建的JAR放在此目录下，也会自动由拓展类加载器加载</p><p>系统类加载器（应用程序类加载器）</p><p>​    Java编写</p><p>​    父类加载器为拓展类加载器</p><p>​    负责加载环境变量classpath或系统属性，java.class.path指定路径下的类库</p><p>​    该类加载程序中默认的类加载器</p><h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><p>为什么要自定义类加载器</p><p>​    隔离加载类</p><p>​    修改类加载的方式</p><p>​    拓展加载源</p><p>​    防止源码泄露</p><p>实现步骤</p><p>​    通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</p><p>​    JDK1.2之前，在自定义加载类时，总会继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。JDK1.2以后，不再建议用户覆盖loadClass方法，而是建议把自定义的类加载逻辑写在findclass方法中    </p><p>​    若没有复杂需求，可直接继承URLClassLoadr类，这就可避免自己去编写findClass方法及其获取字节码流的方式，使自定义类加载器的简洁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载器和类加载过程&quot;&gt;&lt;a href=&quot;#类加载器和类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载器和类加载过程&quot;&gt;&lt;/a&gt;类加载器和类加载过程&lt;/h1&gt;&lt;p&gt;类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="类加载" scheme="http://example.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础-虚拟机栈</title>
    <link href="http://example.com/2022/05/20/JVM-1/"/>
    <id>http://example.com/2022/05/20/JVM-1/</id>
    <published>2022-05-20T13:18:58.000Z</published>
    <updated>2022-05-21T05:46:23.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h1><img src="/2022/05/20/JVM-1/zucheng.png" alt="组成" style="zoom:150%;"><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>一种快速有效的分配存储方式，<em><strong>访问速度仅次于程序计数器；</strong></em></p><p>线程私有</p><p>  JVM直接对java栈的操作：</p><p>​            每个方法的执行，伴随着进栈（入栈，压栈）</p><p>​            执行结果后的出栈工作</p><p>  不存在垃圾回收的问题</p><p>  栈中的数据都是以栈帧的格式存在，<em><strong>这个线程上正在执行的每个方法都各自对应一个栈帧</strong></em>。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。每一个方法执行结束就对应着一个栈帧从虚拟机栈从入栈到出栈</p><p>栈就只有 压栈 和 出栈</p><p>不同线程中所包含的线帧是不允许相互引用的，即不可能在一个栈帧之中引用另一个线程中的栈帧</p><p>若当前方法调用其他方法，方法返回的时候，当前栈帧会传回此方法的执行结果给前一个栈帧，然后虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p><p>方法的结束方式：正常结束和抛出异常（未被捕获处理）</p><h2 id="栈帧内部结构"><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h2><p><img src="/2022/05/20/JVM-1/zhangzhen.png" alt="zhanzhen"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>  定义为一个数字数组，主要用于<em><strong>存储方法参数和定义在方法体内的局部变量</strong></em></p><p>  因是建立在线程的栈上，是<em><strong>私有</strong></em>的，所以不存在数据安全问题</p><p>  所需的容量的大小是在编译期确定下来的</p><p>  方法嵌套使用的次数由栈的大小决定。越大，次数越多</p><p>  局部变量表中的变量只在当前方法调用中有效。方法调用结束，该表也会随之销毁</p><p>  里面最基本的存储单元Slot（变量槽）：</p><p>​    参数值的存放总是在局部变量数组的index0开始，到数组长度-1结束</p><p>局部变量表最基本的存储单元</p><p>​    局部变量表里，32位以内的类型只占用一个slot，64位占两个</p><p>​    当一个实例方法被调用，它的方法参数和方法体内部定义的局部变量将会按照顺序复制到局部变量表中的每一个slot上</p><p>​    若当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处。</p><p>  Slot重复利用：栈帧中的局部变量表中的槽位是可以重用，为了节省资源。</p><p>  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表直接或间接引用的对象都不会被回收</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>  是一个以字长为单位的数组，但是以后进先出的操作数栈（表达式栈），方法执行过程中，根据字节码指令，进行入栈、出栈操作。</p><p>  进行数据运算的</p><p>  并非采用访问索引的方式来进行数据访问</p><p>  若被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</p><p>Java虚拟机的解释引擎是基于栈（操作数栈）的执行引擎</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>  一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用就是为了支持当前方法的代码能够实现动态连接</p><p>  Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中，动态链接作用就是将这些符号引用转换为调用方法的直接引用</p><p>  常量池：提供一些符号和常量，便于指令的识别</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的PC寄存器的值。（交给执行引擎，让其执行后续操作）</p><p>调用者的PC计数器的值作为返回地址，即调用该方法的指令作为下一条指令的地址</p><p>正常完成与异常完成的区别：异常完成出口退出不会给他上层调用者产生任何的返回值</p><p>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</p><h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>不一定有。比如：对程序调试提供支持的信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM组成&quot;&gt;&lt;a href=&quot;#JVM组成&quot; class=&quot;headerlink&quot; title=&quot;JVM组成&quot;&gt;&lt;/a&gt;JVM组成&lt;/h1&gt;&lt;img src=&quot;/2022/05/20/JVM-1/zucheng.png&quot; alt=&quot;组成&quot; style=&quot;zoom</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="虚拟机栈" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>redis持久化</title>
    <link href="http://example.com/2022/05/19/redis_c/"/>
    <id>http://example.com/2022/05/19/redis_c/</id>
    <published>2022-05-19T12:03:28.000Z</published>
    <updated>2022-05-19T12:33:09.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>持久化就是指redis会把内存中的数据写入到硬盘中，redis重启的时候加载这些数据，就最大限度的降低惠存丢失带来的影响。</p><p><em><strong>因为数据全部在内存，若宕机、进程退出，若没有持久化机制，数据就会全部丢失</strong></em>。有了持久化后，redis在下次重启的时候就会进行数据</p><p>备份的执行过程：redis会单独创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上一次持久化好的文件。整个过程，主进程是不进行任何I&#x2F;O操作，就确保了极高的性能，若要大规模的数据恢复，且对于数据恢复的完整性不是很敏感，那RDB方式要比AOF方式更高效。缺点就是最后一次 持久化后数据可能丢失</p><h1 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h1><h2 id="RDB快照（默认）"><a href="#RDB快照（默认）" class="headerlink" title="RDB快照（默认）"></a>RDB快照（默认）</h2><p>​    将当前redis中的数据<em><strong>生成快照二进制的形式</strong></em>保存到硬盘，保存的文件后缀是rdb；redis重启时可以读取快照文件恢复数据。有手动触发和自动触发两种。记录结果</p><h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>​    创建命令：SAVE和BGSAVE（推荐，因为可在不阻塞服务器进程情况下执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save：会阻塞Redis服务，直到RDB持久化完成，当Rredis里面存储了大量数据的时候，就造成较长时间的阻塞，不建议用</span><br><span class="line">bgsave：一般不会阻塞，进行会执行fork操作创建子进程负责，不会阻塞Redis服务进程。Redis服务的阻塞只发生在fork阶段，一般时间很短</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bgsave的流程：</span><br><span class="line">执行besave命令，Redis进程会判断当前是否存在正在执行的RDB或AOF子线程，若存在就直接结束</span><br><span class="line">Redis进程执行fork操作创建子线程，fork操作过程中redis进程会被阻塞</span><br><span class="line">fork完成后，bgsave就结束了，redis进程就不会被阻塞，其他命令就可以被响应</span><br><span class="line">子进程根据redis进程的内存生成快照文件，并替换原有的RDB文件</span><br><span class="line">子进程通过信号量通知Redis进程已完成</span><br></pre></td></tr></table></figure><h3 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h3><p>在配置文件中设置save的相关配置，如save 5 1，就表示在5s内数据被修改1次时自动触发bgsave操作</p><p>当从节点做全量复制时，主节点会自动执行bgsave操作，并且把生成的RDB文件发送给从节点</p><p>执行 “debug reload”命令时，会触发</p><p>执行“shutdown”，若没有开启AOF持久化也会触发bgsave操作</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：节省磁盘空间，恢复速度快（有向的持久化文件，重启redis，数据就可恢复），方便备份，可最大化redis性能</p><p>  缺点：虽然在fork中使用了写时拷贝技术，但若数据庞大，还是较耗性能；在备份周期，意外down掉的话，就会丢失最后一次快照后的所有改变；</p><p>  较适合大数据集恢复速度的，能承受数分钟内的数据丢失</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>  以日志的形式来<em><strong>记录每个写操作</strong></em>，只追加文件，不改写文件。随着AOF越来越大，需要定期对其重写，达到压缩的目的。默认关闭</p><p>  保存redis服务器执行的所有写命令来记录数据库数据。记录过程</p><p>  优点：备份机制更稳健，丢失数据的概率更低；可读的日志形式，通过AOF更稳健，可处理误操作。</p><p>  缺点：比RDB占用更多磁盘空间；恢复备份速度慢；每次读写都同步的话，有一定的性能压力；存在个别bug，造成不能恢复</p><p>  较适合对业务数据敏感的，不能承受数分钟内的数据丢失</p><h3 id="文件同步的策略"><a href="#文件同步的策略" class="headerlink" title="文件同步的策略"></a>文件同步的策略</h3><p>alawas：每次写入缓存区都要同步到AOF文件中，硬盘的操作比较慢，限制了Redis高并发</p><p>no：每次写入缓存区后不进行同步，同步到AOF文件的操作由操作系统负责，每次同步AOF文件的周期不可控，而且增大了每次同步的硬盘的数据量。</p><p>eversec：每次写入缓存区后，由专门的线程每秒钟同步一次，做到了兼顾性能和数据安全。是建议的同步策略，也是默认的策略。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认AOF不开启，需要修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendonly改为yes，开启AOF</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名字</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># AOF文件的写入方式</span></span><br><span class="line"><span class="comment"># everysec 每个一秒将缓存区内容写入文件 默认开启的写入方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># 运行AOF重写时AOF文件大小的增长率的最小值</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment"># 运行AOF重写时文件大小的最小值</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><img src="/2022/05/19/redis_c/changjing.png" alt="场景"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;持久化就是指redis会把内存中的数据写入到硬盘中，redis重启的时候加载这些数据，就最大限度的降低惠存丢失带来的影响。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>HTTP基础</title>
    <link href="http://example.com/2022/05/18/http-1/"/>
    <id>http://example.com/2022/05/18/http-1/</id>
    <published>2022-05-18T09:56:16.000Z</published>
    <updated>2022-05-18T10:05:47.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>是一个在计算机世界专门在 两点 之间 传输 文字、图片、音频、视频等 超文本 数据的 约定和规范</p><p>简单、灵活和易于拓展、应用广泛和跨平台</p><p>不安全</p><p>基于TCP&#x2F;IP,并且使用了【请求-应答】的通信模式</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>HTTP1.0默认使用短连接。每发起一个请求，都要新建TCP连接（三次握手），而且是串行请求，做了无谓的TCP连接建立和断开，增加了开销；</p><p>HTTP1.1就提出了长连接的通信方式（持久连接），减少了服务器的负载。特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态</p><h4 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h4><p>因为采用了长连接，所以管道网络传输成为了可能</p><p>即在同一个TCP连接中，客户端可以发起多个请求，只要第一个请求发出去，不会等其回来就可以发第二个请求出去，也就减少正特的响应时间</p><h4 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h4><p>因为当顺序发送的请求序列中的一个请求因某种原因被阻塞，后面排队的所有请求也一同被阻塞，客户端也就一直请求不到资源</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>支持C&#x2F;S模式、简单快速、灵活、无连接、无状态</p><h4 id="请求头结构"><a href="#请求头结构" class="headerlink" title="请求头结构"></a>请求头结构</h4><p>由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号</p><p>User-Agent：产生请求的浏览器类型</p><p>Accept：客户端可识别的内容类型列表</p><p>Host：请求的主机名</p><h4 id="响应头格式"><a href="#响应头格式" class="headerlink" title="响应头格式"></a>响应头格式</h4><p>状态行：状态码、八本</p><p>响应头部：</p><p>​         Server：应用程序软件的名称和版本</p><p>​         Content-Type：发送给接受者的实体正文的媒体类型</p><p>​         Accept-Language：描述资源所用的自然语言</p><p>​         Content-Length：实体正文长度</p><p>响应正文：</p><h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><h5 id="HTTP1-0和1-1"><a href="#HTTP1-0和1-1" class="headerlink" title="HTTP1.0和1.1"></a>HTTP1.0和1.1</h5><p>长连接：同上</p><p>错误状态响应码：1.1中新增加了24个错误状态响应码</p><p>缓存处理：1.1引用了更多缓存控制策略</p><p>带宽优化及网络连接的使用</p><h5 id="HTTP1-1-优化"><a href="#HTTP1-1-优化" class="headerlink" title="HTTP1.1 优化"></a>HTTP1.1 优化</h5><p>尽量避免HTTP请求（缓存技术）</p><p>在需要发HTTP请求，减少次数（减少重定向，合并请求，延迟发送）</p><p>合并请求就是合并资源，以一个大资源的请求替换多个小资源的请求；当大资源中的小资源发生变化，客户端就要重新下载整个完整的大资源</p><p>  延迟发送：只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源</p><p>减少服务器的HTTP响应大小</p><h5 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h5><p>通过静态表和哈夫曼编码的方式，将体积压缩了近一半，针对后续的请求头部也可建立动态表（会占用内存而影响并发能力）</p><p>  实现了Stream并发，多个Stream只需复用一个TCP连接，节约了TCP和TLS握手时间，以及减少了TCP慢启动阶段对流量的影响。</p><p>  服务器支持主动推送资源，大大提升了消息的传输信息</p><p>  HTTP&#x2F;2是基于TCP协议来传输数据，TCP层必须保证收到的字节数据是完成且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用。有队头阻塞问题，TCP和TLS的握手时延迟，网络迁移需要重新连接</p><h5 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h5><p>传输层的TCP换成UDP，并在UDP协议开发了QUIC协议保证了数据的可靠传输。</p><p>QUIC</p><p>  无队头阻塞</p><p>  建立连接速度块</p><p>  连接迁移</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;headerlink&quot; title=&quot;http&quot;&gt;&lt;/a&gt;http&lt;/h3&gt;&lt;p&gt;是一个在计算机世界专门在 两点 之间 传输 文字、图片、音频、视频等 超文本 数据的 约定和规范&lt;/p&gt;
&lt;p&gt;简单、灵活和</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>TCP基础</title>
    <link href="http://example.com/2022/05/17/TCP/"/>
    <id>http://example.com/2022/05/17/TCP/</id>
    <published>2022-05-17T02:36:59.000Z</published>
    <updated>2022-05-17T02:45:15.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在运输层的可靠数据传输的服务，面向连接【1对1】、可靠的【一个报文一定能到达接收端】、基于字节流的传输层通信协议</p><p>头部包含端口号、序列号</p><p>唯一确定一个TCP连接：TCP四元组（源地址、源端口、目的地址、目的端口）</p><p><img src="/2022/05/17/TCP/jiegou.png" alt="结构"></p><p>标志位：</p><p>URG：表示TCP包的紧急指针域有效，保证TCP连接不被中断</p><p>ACK：应答域有效</p><p>PSH：push操作，让到达接收端的数据包能直接传给应用程序</p><p>RST：连接复位请求</p><p>SYN：建立连接</p><p>FIN：断开连接</p><h1 id="如何保证可靠性"><a href="#如何保证可靠性" class="headerlink" title="如何保证可靠性"></a>如何保证可靠性</h1><p>应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传给应用层</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><p>  流量控制：控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率</p><p>  拥塞控制：网络拥塞时，减少数据发送。慢启动（每收到一个ACK，拥塞窗口就+1，直到增加到门限状态变量），拥塞避免（超过慢启动门限后进行，每个ACK，cwnd+1），拥塞发生（超时重传，快速重传），快速恢复</p><p>  超时重传：TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；数据包丢失或确认应答丢失会发生该情况。定时器太长，重发就满了，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时</p><p>  QRQ协议：为实现可靠重传，每发完一个分组后就停止发，收到对方发的确认后再发下一个</p><p>重传机制：</p><p>​       超时重传：如上</p><p>​      快速重传：以数据驱动重传。收到三个相同ACK报文时，立刻重传丢失报文段</p><p>滑动窗口：</p><p>  TCP头部有一个字段交Window（窗口大小），接收端告诉发送端子机还有多少缓冲区可接收数据，于是发送端就根据这个发送数据。大小为0时，就会阻止发送方发送数据</p><p>解决窗口关闭：TCP为每个链接设有一个持续定时器，只要TCP连接一方收到对方的零窗口通知，就启动该定时器，定时器超时的话就发送窗口检测报文，而对方确认该报文时给出自己接收窗口大小</p><h1 id="黏包"><a href="#黏包" class="headerlink" title="黏包"></a>黏包</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多个数据包被连续存储在连续的缓存中，在对数据包读取时由于无法确定发生方的发送边界，而采用某一估测值大小来读出数据。双方size不一致就会让发送方发送的若干包数据到接收方接收时沾成一包，从接收缓冲区看，后一包的数据的头紧接着前一包数据的尾</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>TCP若连续几次发送的数据很少，那TCP根据优化算法把这些数据合成一包一次发送，接收方就收到了粘包数据</p><p>  TCP协议有MISS，若数据包过长就会被分开传输。接收方就收到粘包数据</p><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>TCP短连接就不用考虑</p><p>若数据无结构，发送放就只管发，接收方只管接，也不用考虑</p><p>双方建立长连接，要在连接一段是时间内发送不同数据结构：</p><p>​         发送端的每个数据包添加包首部，首部中应该至少包含数据包的长度。这样接收方就能知道数据包的实际长度</p><p>​         发送端将每个数据包封装为固定长度（不够的，0补充），接收端每次就从接收缓冲区中读取固定长度的数据就行，也就拆开了数据包</p><p>​         可在数据包之间设置边界</p><h1 id="与UDP的比较"><a href="#与UDP的比较" class="headerlink" title="与UDP的比较"></a>与UDP的比较</h1><table><thead><tr><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">面向连接</td><td align="center">无连接</td></tr><tr><td align="center">提供可靠服务</td><td align="center">尽最大努力交付</td></tr><tr><td align="center">面向字节流</td><td align="center">数据报文段</td></tr><tr><td align="center">每一条TCP连接都是点到点</td><td align="center">支持一对一，一对多，多对多的交互通信</td></tr><tr><td align="center">首部开销20字节</td><td align="center">首部开销8字节</td></tr><tr><td align="center">全双工可靠通信</td><td align="center">不可靠通信</td></tr><tr><td align="center">常用于FTP文件传输、HTTP&#x2F;HTTPS</td><td align="center">包总量较少信息，视频、音频等多媒体通信，广播通信</td></tr><tr><td align="center">传输较慢，所需资源较多</td><td align="center">传出快，所需资源少</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;在运输层的可靠数据传输的服务，面向连接【1对1】、可靠的【一个报文一定能到达接收端】、基于字节流的传输层通信协议&lt;/p&gt;
&lt;p&gt;头部包含端口</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Volatile</title>
    <link href="http://example.com/2022/05/16/volatile/"/>
    <id>http://example.com/2022/05/16/volatile/</id>
    <published>2022-05-16T04:02:43.000Z</published>
    <updated>2022-05-16T04:54:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>是java提供的一个轻量级的同步机制。java中有两种内在的同步机制：同步块和volatile变量，与synchronized相比，volatile更轻量，<em><strong>不会引起线程上下文切换和调度</strong></em>，但是同步性也较差</p><h1 id="并发编程的基本概念"><a href="#并发编程的基本概念" class="headerlink" title="并发编程的基本概念"></a>并发编程的基本概念</h1><p>原子性：一个或多个操作，要么全部执行且过程中不会打断，要么就都不执行。即拒绝多线程操作，同一时刻就只有一个线程进行操作。整个操作中，不会被线程调度器中断的操作，都可以认为是原子性</p><p>可见性：当多个线程去访问一个变量的时候，一个线程修改了一个或多个变量后，其他线程能够立刻看到这些被修改后的值。多线程环境下，一个线程对共享变量的操作对于其它线程是不可见的。volatile来保证可见性，变量被其修饰后，线程本地的内存就会无效，线程对该变量修改后就会同步更新到主内存中，其它线程读取变量时，就会从主内存中读取。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行</p><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>JMM决定一个线程对共享变量的写入在什么时候对另一个线程是可见的。JMM定义了线程和主内存之间的抽象空间：共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的操作必须在工作内存中进行，而不能直接读写主内存中的变量</p><img src="/2022/05/16/volatile/JMM.png" alt="JMM" style="zoom:50%;"><p>对于普通的共享变量，线程A将其修改为某个值的过程在本地内存A中，并没有同步到主内存中；而线程B已经缓存了该变量的旧值，也就导致了共享变量的值不一样。加锁（lock或synchronized）可以解决这样的问题，但是太重量级，影响效率，所以使用volatile</p><p>JMM是个<em><strong>抽象的内存模型</strong></em></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>保证共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量</p><p>该关键字能保证修改的值能立即被更新到主存</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JVM底层volatile是采用<em><strong>内存屏障</strong></em>实现，观察加入volatile关键字和没有加的关键字所产生的汇编代码发现，加入后的会有一个lock指令，实际上相当于一个内存屏障</p><p>内存屏障的作用：</p><p>​能确保指令重排时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障后面的；即执行到内存屏障这句指令时，前面的操作就已经完成</p><p>​会强调对缓存的修改操作立即写入主内存</p><p>​若是写操作，会让其它CPU中对应的缓存行无效，即必须从主内存中读取变量</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>可见性：对一个volatile变量的读，总能看到（任意线程）对该volatile变量最后的写入</p><p>防止指令重排的问题。</p><p>Java虚拟机中，每个线程对应一个工作内存，并共享主内存的数据</p><p>JMM：线程解锁前，必把共享变量的值刷新回主内存；加锁前，必须读主内存的值到自己的工作内存；加锁和解锁是同一把锁</p><h2 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h2><p>JMM会分别限制两种类型的重排序：编译重排序和处理器重排序</p><p>编译重排序：当第二个操作是volatile写时，不管第一个，都不能重排序；当第一个是读时，不管第二个，都不能重排序；第一个写，第二个读，不能</p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><p>对变量的写入操作不依赖变量的当前值或能确保只有单个线程改变变量的值</p><p>该变量不会与其他状态变量一起纳入不变性条件中</p><p>访问变量时不需要加锁</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p>volatile保证了<em><strong>可见性</strong></em>，提供了一定的<em><strong>有序性</strong></em>，<em><strong>不保证原子性</strong></em>。</p><h1 id="单例模式的双重锁为什么要写volatile"><a href="#单例模式的双重锁为什么要写volatile" class="headerlink" title="单例模式的双重锁为什么要写volatile"></a>单例模式的双重锁为什么要写volatile</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//在并发情况下，若没有volatile关键字，该行会出问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton();//分解为三行</span><br><span class="line"></span><br><span class="line">a. memory = allocate() //分配内存</span><br><span class="line"></span><br><span class="line">b. ctorInstanc(memory) //初始化对象</span><br><span class="line"></span><br><span class="line">c. instance = memory //设置instance指向刚分配的地址</span><br></pre></td></tr></table></figure><p>若没有volatile，可能会出现重排序的情况。多线程环境下，可能执行了a，c，没有执行b，A线程执行了c导致instance指向了一个地址，所以判断instance不会null，会直接返回一个初始化对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;是java提供的一个轻量级的同步机制。java中有两种内在的同步机制：同步块和volatile变量，与synchronized相比，vola</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="volatile" scheme="http://example.com/tags/volatile/"/>
    
    <category term="并发编程" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
