<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ribbon-2</title>
      <link href="/2022/10/15/Ribbon-2/"/>
      <url>/2022/10/15/Ribbon-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xiaoerbutingbu.github.io/2022/10/13/Ribbon-1/">承接上篇</a></p><h1 id="服务列表更新"><a href="#服务列表更新" class="headerlink" title="服务列表更新"></a>服务列表更新</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>所有在Ribbon中可以用到的服务列表数据信息，一般都可在第一次使用时将所有指定名称微服务的实例数据信息保存到本地，但这些数据肯定会改变</p><p>在Ribbon中为了可以及时获取到所有动态的列表更新的数据项，所以有一个专属的更新操作接口ServerListUpdater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServerListUpdater</span> &#123;</span><br><span class="line">    <span class="comment">//启动更新操作，正常应该是启动一个线程</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(ServerListUpdater.UpdateAction var1)</span>;</span><br><span class="line"><span class="comment">//停止更新</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//最后一次更新</span></span><br><span class="line">    String <span class="title function_">getLastUpdate</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//更新的间隔</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDurationSinceLastUpdateMs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//停止的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNumberMissedCycles</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//核心的线程数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCoreThreads</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//配置更新的操作行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateAction</span> &#123;</span><br><span class="line">        <span class="comment">//实现服务列表数据更新处理</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">doUpdate</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其子类PollingServerListUpdater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollingServerListUpdater</span> <span class="keyword">implements</span> <span class="title class_">ServerListUpdater</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isActive;<span class="comment">//激活状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> lastUpdated;<span class="comment">//当前时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> initialDelayMs;<span class="comment">//初始化延迟时间配置ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> refreshIntervalMs;<span class="comment">//刷新时间配置ms</span></span><br><span class="line">    <span class="comment">//之前的所有相关配置都在此</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">PollingServerListUpdater</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(LISTOFSERVERS_CACHE_UPDATE_DELAY, getRefreshIntervalMs(clientConfig));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="keyword">final</span> UpdateAction updateAction)</span> &#123;</span><br><span class="line">        <span class="comment">//CAS处理配置</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.isActive.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">//封装一个线程，不占用主线程</span></span><br><span class="line">             <span class="type">Runnable</span> <span class="variable">wrapperRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//判断状态</span></span><br><span class="line">                    <span class="keyword">if</span> (!PollingServerListUpdater.<span class="built_in">this</span>.isActive.get()) &#123;</span><br><span class="line">                        <span class="comment">//异步任务</span></span><br><span class="line">                        <span class="keyword">if</span> (PollingServerListUpdater.<span class="built_in">this</span>.scheduledFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">                            PollingServerListUpdater.<span class="built_in">this</span>.scheduledFuture.cancel(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//进行数据的更新</span></span><br><span class="line">                            updateAction.doUpdate();</span><br><span class="line">                            <span class="comment">//修改最后一次更新时间戳</span></span><br><span class="line">                            PollingServerListUpdater.<span class="built_in">this</span>.lastUpdated = System.currentTimeMillis();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">                            PollingServerListUpdater.logger.warn(<span class="string">&quot;Failed one update cycle&quot;</span>, var2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">this</span>.scheduledFuture = getRefreshExecutor().scheduleWithFixedDelay(wrapperRunnable, <span class="built_in">this</span>.initialDelayMs, <span class="built_in">this</span>.refreshIntervalMs, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Already active, no-op&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">        <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateListOfServers</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;T&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.serverListImpl != <span class="literal">null</span>) &#123;</span><br><span class="line">            servers = <span class="built_in">this</span>.serverListImpl.getUpdatedListOfServers();<span class="comment">//获取更新后的服务列表</span></span><br><span class="line">            LOGGER.debug(<span class="string">&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>, <span class="built_in">this</span>.getIdentifier(), servers);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.filter != <span class="literal">null</span>) &#123;</span><br><span class="line">                servers = <span class="built_in">this</span>.filter.getFilteredListOfServers((List)servers);</span><br><span class="line">                LOGGER.debug(<span class="string">&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;</span>, <span class="built_in">this</span>.getIdentifier(), servers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.updateAllServerList((List)servers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将获取到的列表进行更新处理。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">updateAllServerList</span><span class="params">(List&lt;T&gt; ls)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.serverListUpdateInProgress.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> ls.iterator();</span><br><span class="line">                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                    <span class="type">T</span> <span class="variable">s</span> <span class="operator">=</span> (Server)var2.next();</span><br><span class="line">                    s.setAlive(<span class="literal">true</span>);<span class="comment">//设置客户端是否能正确更新操作，即更新状态</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.setServersList(ls);<span class="comment">//设置到服务列表中</span></span><br><span class="line">                <span class="built_in">super</span>.forceQuickPing();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.serverListUpdateInProgress.set(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    以上两个就是更新启动的操作命令执行，通过注册中心加载最新的服务列表数据，并将数据进行客户端Ribbon数据实例的更新操作使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，最后实现数据更新处理的是随机由”ServerListUpdateAction”接口完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enableAndInitLearnNewServersFeature</span><span class="params">()</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;Using serverListUpdater &#123;&#125;&quot;</span>, <span class="built_in">this</span>.serverListUpdater.getClass().getSimpleName());</span><br><span class="line">        <span class="built_in">this</span>.serverListUpdater.start(<span class="built_in">this</span>.updateAction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行更新启动的操作命令执行</span></span><br></pre></td></tr></table></figure><h2 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Ribbon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.CommonClientConfigKey;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.DefaultClientConfigImpl;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.ConfigurationBasedServerList;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.PollingServerListUpdater;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.ServerListUpdater;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.ZoneAwareLoadBalancer;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSeverListUpdater</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实例数据，通过注册中心抓取到的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="string">&quot;10.0.19.1:8001,10.9.15.2:8002:10.8.13.5:8003&quot;</span>;<span class="comment">//定义当前服务列表，</span></span><br><span class="line">        <span class="type">DefaultClientConfigImpl</span> <span class="variable">clientConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultClientConfigImpl</span>();</span><br><span class="line">        clientConfig.set(CommonClientConfigKey.ListOfServers,instance);<span class="comment">//保存实例数据</span></span><br><span class="line">        <span class="comment">//获取的是基本的服务列表</span></span><br><span class="line">        <span class="type">ConfigurationBasedServerList</span> <span class="variable">basedServerList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationBasedServerList</span>();</span><br><span class="line">        basedServerList.initWithNiwsConfig(clientConfig);<span class="comment">//通过客户端配置类实现服务列表初始化</span></span><br><span class="line">        <span class="type">ServerListUpdater</span> <span class="variable">updater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PollingServerListUpdater</span>();<span class="comment">//服务列表更新</span></span><br><span class="line">        updater.start(<span class="keyword">new</span> <span class="title class_">ServerListUpdater</span>.UpdateAction() &#123;<span class="comment">//直接编写一个调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;updater.getLastUpdate() = &quot;</span> + updater.getLastUpdate()+<span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;上次更新间隔时长&quot;</span>+updater.getDurationSinceLastUpdateMs()+<span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;错过的更新周期数&quot;</span>+updater.getNumberMissedCycles()+<span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;使用的线程数量&quot;</span>+updater.getCoreThreads());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//负载均衡器，按区域</span></span><br><span class="line">        <span class="type">ZoneAwareLoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ZoneAwareLoadBalancer</span>();</span><br><span class="line">        loadBalancer.setServerListImpl(basedServerList);</span><br><span class="line">        loadBalancer.setServerListUpdater(updater);<span class="comment">//服务列表更新器</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">updater.getLastUpdate() = Sun Oct 16 22:31:47 CST 2022上次更新间隔时长1117错过的更新周期数0使用的线程数量2</span></span><br><span class="line"><span class="comment">updater.getLastUpdate() = Sun Oct 16 22:31:48 CST 2022上次更新间隔时长30000错过的更新周期数1使用的线程数量2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p>在某些环境中有可能存在有一些优先调度环节，就通过写过滤手段来进行实例调用的优先配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicServerListLoadBalancer</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Server</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalancer</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">//进行初始化操作和定义  核心方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        ServerList&lt;T&gt; niwsServerListImpl = (ServerList)ClientFactory.instantiateInstanceWithClientConfig(niwsServerListClassName, clientConfig);</span><br><span class="line">            <span class="built_in">this</span>.serverListImpl = niwsServerListImpl;</span><br><span class="line">            <span class="keyword">if</span> (niwsServerListImpl <span class="keyword">instanceof</span> AbstractServerList) &#123;</span><br><span class="line">                AbstractServerListFilter&lt;T&gt; niwsFilter = ((AbstractServerList)niwsServerListImpl).getFilterImpl(clientConfig);</span><br><span class="line">                niwsFilter.setLoadBalancerStats(<span class="built_in">this</span>.getLoadBalancerStats());</span><br><span class="line">                <span class="comment">//指定过滤器</span></span><br><span class="line">                <span class="built_in">this</span>.filter = niwsFilter;</span><br><span class="line">            &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServerListFilter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Server</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//获取过滤后的服务实例列表</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; var1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口定义能接收泛型类型统一为Server及其子类（存在有泛型上限的配置）</span></span><br><span class="line"><span class="comment">该接口库下面存在一个AbstractServerListFilter的抽象类，作为一些过滤处理的公共实现。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractServerListFilter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Server</span>&gt; <span class="keyword">implements</span> <span class="title class_">ServerListFilter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LoadBalancerStats stats;<span class="comment">//存在一个负载均衡的统计</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractServerListFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancerStats</span><span class="params">(LoadBalancerStats stats)</span> &#123;<span class="comment">//设置负载均衡器</span></span><br><span class="line">        <span class="built_in">this</span>.stats = stats;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> LoadBalancerStats <span class="title function_">getLoadBalancerStats</span><span class="params">()</span> &#123;<span class="comment">//得到负载均衡统计器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stats;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由此可知，所有负载均衡的处理都是有相关的统计信息。连接失败的、超时的等等（打开LoadBalancerStats可知）。</span></span><br><span class="line"><span class="comment">该类的实现类重点是ZoneAffinityServerListFilter，它描述的就是根据区域进行优先调度处理</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>不管怎么实现过滤，重点在于数据列表的获取，实现方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; servers)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否指定的区域配置，或没有排除等相关的处理，以及存在有服务列表</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.zone != <span class="literal">null</span> &amp;&amp; (<span class="built_in">this</span>.zoneAffinity || <span class="built_in">this</span>.zoneExclusive) &amp;&amp; servers != <span class="literal">null</span> &amp;&amp; servers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;T&gt; filteredServers = Lists.newArrayList(Iterables.filter(servers, <span class="built_in">this</span>.zoneAffinityPredicate.getServerOnlyPredicate()));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.shouldEnableZoneAffinity(filteredServers)) &#123;<span class="comment">//判断处理了</span></span><br><span class="line">                <span class="keyword">return</span> filteredServers;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.zoneAffinity) &#123;</span><br><span class="line">                <span class="built_in">this</span>.overrideCounter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> servers;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在区域判断的时候，会根据之前的负载均衡统计的结果来处理</span></span><br><span class="line"><span class="comment">shouldEnableZoneAffinity方法中，获取到了负载均衡的统计器、知道了调用的次数、获取的实例数量、故障实例百分比。</span></span><br><span class="line"><span class="comment">若没有负载均衡的统计，就不能排除一些可能存在的可能的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="自测-1"><a href="#自测-1" class="headerlink" title="自测"></a>自测</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Ribbon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.DefaultClientConfigImpl;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.IClientConfigKey;</span><br><span class="line"><span class="keyword">import</span> com.netflix.config.ConfigurationManager;</span><br><span class="line"><span class="keyword">import</span> com.netflix.config.DeploymentContext;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.Server;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.ServerListFilter;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.ZoneAffinityServerListFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServerListFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟注册中心数据</span></span><br><span class="line">        List&lt;Server&gt; serverList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        serverList.add(createServer(<span class="string">&quot;xiaoer&quot;</span>,<span class="string">&quot;xiaoer-1&quot;</span>,<span class="number">8001</span>));</span><br><span class="line">        serverList.add(createServer(<span class="string">&quot;xiaoer&quot;</span>,<span class="string">&quot;xiaoer-1&quot;</span>,<span class="number">8002</span>));</span><br><span class="line">        serverList.add(createServer(<span class="string">&quot;er&quot;</span>,<span class="string">&quot;er-1&quot;</span>,<span class="number">8001</span>));</span><br><span class="line">        <span class="comment">//所有与Ribbon有关的配置都是通过IClientConfig接口定义的(可以application.yml配置)</span></span><br><span class="line">        <span class="type">DefaultClientConfigImpl</span> <span class="variable">defaultClientConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultClientConfigImpl</span>();</span><br><span class="line">        defaultClientConfig.set(IClientConfigKey.Keys.EnableZoneAffinity,<span class="literal">true</span>);<span class="comment">//区域相关性</span></span><br><span class="line">        defaultClientConfig.set(IClientConfigKey.Keys.EnableZoneExclusivity,<span class="literal">true</span>);<span class="comment">//区域独占性</span></span><br><span class="line">        ConfigurationManager.getDeploymentContext().setValue(</span><br><span class="line">                DeploymentContext.ContextKey.zone,<span class="string">&quot;xiaoer&quot;</span>   <span class="comment">//区域优先配置</span></span><br><span class="line">        );</span><br><span class="line">        <span class="type">ZoneAffinityServerListFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZoneAffinityServerListFilter</span>();<span class="comment">//区域可用性的过滤器</span></span><br><span class="line">        filter.initWithNiwsConfig(defaultClientConfig); <span class="comment">//初始化配置</span></span><br><span class="line">        System.out.println(filter.getFilteredListOfServers(serverList));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title function_">createServer</span><span class="params">(String zone, String url, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Server</span>(url,index);</span><br><span class="line">        server.setZone(zone);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[xiaoer-1:8001, xiaoer-1:8002]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="IPing"><a href="#IPing" class="headerlink" title="IPing"></a>IPing</h1><p>消费端通过Ribbon获取了全部实例后，一般要确定实例是否是存活状态（习惯使用Ping命令），命令时进行网络通畅命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPing</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server var1)</span>;<span class="comment">//判断服务是否存活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常规情况判断一服务实例是否存活就必须知道实例的地址是什么</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//在IClientConfig的子类DefaultClientConfigImpl中也指明了使用的ping</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_NFLOADBALANCER_PING_CLASSNAME</span> <span class="operator">=</span> <span class="string">&quot;com.netflix.loadbalancer.DummyPing&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="IRule负载均衡算法"><a href="#IRule负载均衡算法" class="headerlink" title="IRule负载均衡算法"></a>IRule负载均衡算法</h1><p>每一次可以获取到的服务实例数据可能是很多，消费端在进行服务最终调用的时候需要通过一些算法来避免单台主机过忙的问题。</p><p>为了便于负载均衡算法的统一管理，在Ribbon中有一个IRule接口，该接口定义了规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRule</span> &#123;<span class="comment">//负载均衡算法的规则标准</span></span><br><span class="line">    <span class="comment">//实现负载均衡中的服务实例的选择，根绝指定Key通过列表获取</span></span><br><span class="line">    Server <span class="title function_">choose</span><span class="params">(Object var1)</span>;</span><br><span class="line"><span class="comment">//负载均衡器的配置</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer var1)</span>;</span><br><span class="line"><span class="comment">//该规则下使用的负载均衡器</span></span><br><span class="line">    ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IRule实现了整个处理规则，根据IRule接口的choose方法选择一个指定的服务实例，而实例的选择最终依靠负载均衡算法，该算法就是ILoadBalancer接口定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line">    <span class="comment">// 保存全部加载到的服务列表数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addServers</span><span class="params">(List&lt;Server&gt; var1)</span>;</span><br><span class="line"><span class="comment">//选择一个服务的实例</span></span><br><span class="line">    Server <span class="title function_">chooseServer</span><span class="params">(Object var1)</span>;</span><br><span class="line"><span class="comment">//标记服务下线</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">markServerDown</span><span class="params">(Server var1)</span>;</span><br><span class="line"><span class="comment">//返回所有的可达的服务列表</span></span><br><span class="line">    List&lt;Server&gt; <span class="title function_">getReachableServers</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//返回所有可用和不可用的服务列表</span></span><br><span class="line">    List&lt;Server&gt; <span class="title function_">getAllServers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/15/Ribbon-2/suanfa.png"></p><p>IRule提供了一个AbstractLoadBalancerRule抽象类（实现适配器设计模式）。 默认采用轮询的方式</p><p>还是看IClientConfig下的DefaultClientConfigImpl子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_NFLOADBALANCER_RULE_CLASSNAME</span> <span class="operator">=</span> <span class="string">&quot;com.netflix.loadbalancer.AvailabilityFilteringRule&quot;</span>;</span><br><span class="line"><span class="comment">//默认采用该规则</span></span><br></pre></td></tr></table></figure><p>用户自定义算法使用就定义配置Bean即可，但是与其他大部分配置的Bean不同的是，Ribbon的配置类不能放在被直接扫描的路径，因为可能有配置冲突。官网有说明，大致意思就是Ribbon与SpringCloud整合的时候，在容器启动时会自动进行配置，而该配置若用户的配置也放在了自定扫描的路径下，就会冲突。所以一般可以在程序的外包定义一个新的配置类。<em><strong>最通俗点就是，新建一个与启动类所在目录同级别的目录</strong></em>。还需要在启动类上添加@RibbonClient注解，若有多个配置项就使用RibbonClients注解（可以配置多个RibbonClient）。</p><h1 id="执行流程（核心）"><a href="#执行流程（核心）" class="headerlink" title="执行流程（核心）"></a>执行流程（核心）</h1><p>Ribbon是直接与Spring Boot和Spring Cloud绑定一起执行，所以在引入Ribbon时一般会有一个starter自动装配的定义，所以要理解Ribbon执行操作就要对组成部分分析。</p><p>Ribbon依赖库：所有自动装配的定义都在spring.factories配置文件中，里面仅有一个自动装配类RibbonAutoConfiguration。由下方源码可知，Ribbon数据加载的时候一般都需要考虑整个容器里面是否有RestTemplate对象（AsyncRestTemplate对象），分别为两个不同的Bean类型配置不同的Ribbon配置定义</p><p><img src="/2022/10/15/Ribbon-2/spring.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration</span><br></pre></td></tr></table></figure><p>RibbonAutoConfiguration自动装配类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//条件注入</span></span><br><span class="line"><span class="meta">@Conditional(&#123;RibbonAutoConfiguration.RibbonClassesConditions.class&#125;)</span></span><br><span class="line"><span class="meta">@RibbonClients</span></span><br><span class="line"><span class="comment">//在自动配置后要引入Eureka</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//有加载的自动配置和异步加载的自动配置                               （要有异步的RestTemplate）</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="comment">//Ribbon的饥饿加载属性               （饿汉式加载配置）</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RibbonEagerLoadProperties.class, ServerIntrospectorProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonAutoConfiguration</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;<span class="comment">//Ribbon饿汉式加载属性</span></span><br><span class="line">......</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringClientFactory <span class="title function_">springClientFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SpringClientFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringClientFactory</span>();<span class="comment">//获取工厂类的对象实例。该类大致作用是名为“ribbon”的命名空间去查询Ribbon客户端的名称，当然还有获取Client、Balance配置等作用，总之就可以通过其他环境获取Ribbon的相关配置 </span></span><br><span class="line">        factory.setConfigurations(<span class="built_in">this</span>.configurations);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;LoadBalancerClient.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalancerClient <span class="title function_">loadBalancerClient</span><span class="params">()</span> &#123;<span class="comment">//客户端负载均衡的处理  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonLoadBalancerClient</span>(<span class="built_in">this</span>.springClientFactory());<span class="comment">//关键步骤</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;org.springframework.retry.support.RetryTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalancedRetryFactory <span class="title function_">loadBalancedRetryPolicyFactory</span><span class="params">(<span class="keyword">final</span> SpringClientFactory clientFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonLoadBalancedRetryFactory</span>(clientFactory);<span class="comment">//Ribbon重试的处理工厂</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> PropertiesFactory <span class="title function_">propertiesFactory</span><span class="params">()</span> &#123; <span class="comment">// 属性的定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertiesFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(&#123;&quot;ribbon.eager-load.enabled&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title function_">ribbonApplicationContextInitializer</span><span class="params">()</span> &#123;<span class="comment">//饿汉式的加载配置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonApplicationContextInitializer</span>(<span class="built_in">this</span>.springClientFactory(), <span class="built_in">this</span>.ribbonEagerLoadProperties.getClients());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//一个内部类,用来做Ribbon客户端请求配置</span></span><br><span class="line">    <span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">        proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(&#123;HttpRequest.class&#125;)</span></span><br><span class="line">    <span class="meta">@RibbonAutoConfiguration</span>.ConditionalOnRibbonRestClient</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RibbonClientHttpRequestFactoryConfiguration</span> &#123;</span><br><span class="line">        <span class="comment">//属性注入Spring客户端的工厂</span></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> SpringClientFactory springClientFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对RestTemplate做处理</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> RestTemplateCustomizer <span class="title function_">restTemplateCustomizer</span><span class="params">(<span class="keyword">final</span> RibbonClientHttpRequestFactory ribbonClientHttpRequestFactory)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (restTemplate) -&gt; &#123;</span><br><span class="line">                restTemplate.setRequestFactory(ribbonClientHttpRequestFactory);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//Ribbon客户端的请求工厂</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> RibbonClientHttpRequestFactory <span class="title function_">ribbonClientHttpRequestFactory</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonClientHttpRequestFactory</span>(<span class="built_in">this</span>.springClientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RibbonAutoConfiguration</code>自动装配，最重要的就是获取一个LoadBalancerClient接口对象实例（<code>依靠的是RibbonLoadBalancerClient子类</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonLoadBalancerClient</span> <span class="keyword">implements</span> <span class="title class_">LoadBalancerClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SpringClientFactory clientFactory; <span class="comment">//Spring客户端工厂类，加载配置使用</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> URI <span class="title function_">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span> &#123;</span><br><span class="line">      .......</span><br><span class="line">             <span class="type">String</span> <span class="variable">serviceId</span> <span class="operator">=</span> instance.getServiceId();<span class="comment">//服务的id名称</span></span><br><span class="line">         <span class="type">RibbonLoadBalancerContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.clientFactory.getLoadBalancerContext(serviceId);</span><br><span class="line">        URI uri;<span class="comment">//根据服务实例拼凑出完整的访问路径</span></span><br><span class="line">            Server server;<span class="comment">//服务实例存储数据</span></span><br><span class="line">            <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> RibbonLoadBalancerClient.RibbonServer) &#123;<span class="comment">//是Ribbon实例</span></span><br><span class="line">            RibbonLoadBalancerClient.<span class="type">RibbonServer</span> <span class="variable">ribbonServer</span> <span class="operator">=</span> (RibbonLoadBalancerClient.RibbonServer)instance;</span><br><span class="line">            server = ribbonServer.getServer();</span><br><span class="line">               uri = RibbonUtils.updateToSecureConnectionIfNeeded(original, ribbonServer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//不是Ribbon实例</span></span><br><span class="line">            server = <span class="keyword">new</span> <span class="title class_">Server</span>(instance.getScheme(), instance.getHost(), instance.getPort());</span><br><span class="line">            <span class="type">IClientConfig</span> <span class="variable">clientConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.clientFactory.getClientConfig(serviceId);</span><br><span class="line">            <span class="type">ServerIntrospector</span> <span class="variable">serverIntrospector</span> <span class="operator">=</span> <span class="built_in">this</span>.serverIntrospector(serviceId);</span><br><span class="line">            uri = RibbonUtils.updateToSecureConnectionIfNeeded(original, clientConfig, serverIntrospector, server);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context.reconstructURIWithServer(server, uri);             </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> ServiceInstance <span class="title function_">choose</span><span class="params">(String serviceId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.choose(serviceId, (Object)<span class="literal">null</span>);<span class="comment">//获取指定的服务实例</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//实际执行   核心</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ILoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> <span class="built_in">this</span>.getLoadBalancer(serviceId);<span class="comment">//获取接口实例</span></span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="built_in">this</span>.getServer(loadBalancer, hint);<span class="comment">//加载实例信息 </span></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RibbonLoadBalancerClient.<span class="type">RibbonServer</span> <span class="variable">ribbonServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RibbonLoadBalancerClient</span>.RibbonServer(serviceId, server, <span class="built_in">this</span>.isSecure(server, serviceId), <span class="built_in">this</span>.serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">            <span class="comment">//最后重载实行另一个执行方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.execute(serviceId, (ServiceInstance)ribbonServer, (LoadBalancerRequest)request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (serviceInstance <span class="keyword">instanceof</span> RibbonLoadBalancerClient.RibbonServer) &#123;</span><br><span class="line">            server = ((RibbonLoadBalancerClient.RibbonServer)serviceInstance).getServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No instances available for &quot;</span> + serviceId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//确认服务可用后</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">RibbonLoadBalancerContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.clientFactory.getLoadBalancerContext(serviceId);<span class="comment">//Ribbon负载均衡上下文</span></span><br><span class="line">            <span class="type">RibbonStatsRecorder</span> <span class="variable">statsRecorder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RibbonStatsRecorder</span>(context, server);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">returnVal</span> <span class="operator">=</span> request.apply(serviceInstance);<span class="comment">//request发布，发送请求</span></span><br><span class="line">                statsRecorder.recordStats(returnVal);<span class="comment">//记录状态 </span></span><br><span class="line">                <span class="keyword">return</span> returnVal;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var8) &#123;</span><br><span class="line">                statsRecorder.recordStats(var8);</span><br><span class="line">                <span class="keyword">throw</span> var8;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                statsRecorder.recordStats(var9);</span><br><span class="line">                ReflectionUtils.rethrowRuntimeException(var9);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后续包括 是否是安全加密调用的判断、各种信息</span></span><br><span class="line">    ......</span><br><span class="line">     <span class="comment">//内部类，定义Ribbon服务实例</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RibbonServer</span> <span class="keyword">implements</span> <span class="title class_">ServiceInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String serviceId;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> secure;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, String&gt; metadata;</span><br><span class="line">    <span class="comment">//setter、getter方法</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个的代码处理最重要的就是execute方法，里面可以根据指定的负载均衡策略执行服务调用，而choose方法中将通过负载均衡加载到一个实例返回，即整个的自动配置bean提供了LoadBalancerClient接口的实例，而后该接口实例最终需要服务实例的加载，并返回一个服务实例给调用处。</p><p>与服务中心形式，Ribbon经过了许多的过滤、列表的更新返回了一个可用服务实例给用户并统计了数据的调用</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon-1</title>
      <link href="/2022/10/13/Ribbon-1/"/>
      <url>/2022/10/13/Ribbon-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>是基于Netflix Ribbon实现的一套<em><strong>客户端的负载均衡工具</strong></em>。通过<em><strong>Load Balance</strong></em>获取到服务提供的所有机器实例，Ribbon会以某种规则或算法去调用这些服务，也可以实现自己的负载均衡算法</p><h1 id="实例列表"><a href="#实例列表" class="headerlink" title="实例列表"></a>实例列表</h1><p>客户端通过Ribbon进行微服务调用时，首先要通过注册中心获取全部的微服务实例列表，这些注册中心数据会统一保存在ServerList接口实例中。而消费端在微服务调用时，会通过此实例列表获取一个实例地址，以实现微服务的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServerList</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Server</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//获取初始化的服务列表</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">getInitialListOfServers</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取更新后的服务列表</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">getUpdatedListOfServers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ServerList是由Ribbon提供的一个服务接口，该接口里的List接口里面保存当前微服务的所有实例（Server）数据，该数据可由开发者设置为静态内容或动态获取</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h1><p>Ribbon本身就是一个客户端实现负载均衡的开发组件，负载均衡最重要的就是一个合理的实现算法。</p><p>为了进行负载均衡处理的规范化定义，准备了一个ILoeadBalancer接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line">    <span class="comment">//初始化列表（在服务启动的时候将所需要的服务列表信息保存），逻辑服务的名称可以添加多次（同一个名称下可能有多台副主机）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addServers</span><span class="params">(List&lt;Server&gt; var1)</span>;</span><br><span class="line"><span class="comment">//每次调用的时候都应该通过负载均衡算法获取一个主机信息</span></span><br><span class="line">    Server <span class="title function_">chooseServer</span><span class="params">(Object var1)</span>;</span><br><span class="line"><span class="comment">//标记服务下线。就是有些服务不要了</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">markServerDown</span><span class="params">(Server var1)</span>;</span><br><span class="line"><span class="comment">//获取全部访问可达的服务列表</span></span><br><span class="line">    List&lt;Server&gt; <span class="title function_">getReachableServers</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取全部列表（可达和不可达列表）</span></span><br><span class="line">    List&lt;Server&gt; <span class="title function_">getAllServers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ILoadBalancer因为是一个接口，所以在SpringCloud配置范围内就会有一些其内置的实现子类。为了便于所有负载均衡子类的实现，在ILoeadBalancer接口中有一个适配器的抽象父类<code>AbstractLoadBalancer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalancer</span> <span class="keyword">implements</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractLoadBalancer</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.chooseServer((Object)<span class="literal">null</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Server&gt; <span class="title function_">getServerList</span><span class="params">(AbstractLoadBalancer.ServerGroup var1)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> LoadBalancerStats <span class="title function_">getLoadBalancerStats</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//枚举类，就是实例状态，标记作用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">ServerGroup</span> &#123;</span><br><span class="line">        ALL,</span><br><span class="line">        STATUS_UP,</span><br><span class="line">        STATUS_NOT_UP;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ServerGroup</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">除了一个枚举，其他均为空白，即交给他的子类实现，要分析子类就建议找默认情况下使用的子类即可（这一个配置就需要IClient接口子类实现）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>打开DefalutClientConfigImpl子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultClientConfigImpl</span> <span class="keyword">implements</span> <span class="title class_">IClientConfig</span> &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//指定了一个默认使用的操作子类。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_NFLOADBALANCER_CLASSNAME</span> <span class="operator">=</span> <span class="string">&quot;com.netflix.loadbalancer.ZoneAwareLoadBalancer&quot;</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开ZoneAwareLoadBalancer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZoneAwareLoadBalancer</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Server</span>&gt; <span class="keyword">extends</span> <span class="title class_">DynamicServerListLoadBalancer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//保持同步状态下数据安全更新，应该保存一个负载均衡配置 </span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, BaseLoadBalancer&gt; balancers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ZoneAwareLoadBalancer.class);<span class="comment">//日志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> DynamicDoubleProperty triggeringLoad;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> DynamicDoubleProperty triggeringBlackoutPercentage;</span><br><span class="line">    <span class="comment">//得到该配置文件的启用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DynamicBooleanProperty</span> <span class="variable">ENABLED</span> <span class="operator">=</span> DynamicPropertyFactory.getInstance().getBooleanProperty(<span class="string">&quot;ZoneAwareNIWSDiscoveryLoadBalancer.enabled&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//设置在线的服务列表</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUpServerList</span><span class="params">(List&lt;Server&gt; upServerList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.upServerList = upServerList;</span><br><span class="line">    &#125;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//根据区域实现服务列表数据的存储</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setServerListForZones</span><span class="params">(Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setServerListForZones(zoneServersMap);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balancers == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.balancers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> zoneServersMap.entrySet().iterator();</span><br><span class="line">        Entry existingLBEntry;</span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            existingLBEntry = (Entry)var2.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">zone</span> <span class="operator">=</span> ((String)existingLBEntry.getKey()).toLowerCase();</span><br><span class="line">            <span class="built_in">this</span>.getLoadBalancer(zone).setServersList((List)existingLBEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var2 = <span class="built_in">this</span>.balancers.entrySet().iterator();</span><br><span class="line"><span class="comment">//能获取到的列表应该是可用的状态</span></span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            existingLBEntry = (Entry)var2.next();</span><br><span class="line">            <span class="keyword">if</span> (!zoneServersMap.keySet().contains(existingLBEntry.getKey())) &#123;</span><br><span class="line">                ((BaseLoadBalancer)existingLBEntry.getValue()).setServersList(Collections.emptyList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//选择服务</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ENABLED.get() &amp;&amp; <span class="built_in">this</span>.getLoadBalancerStats().getAvailableZones().size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用统计状态</span></span><br><span class="line">                <span class="type">LoadBalancerStats</span> <span class="variable">lbStats</span> <span class="operator">=</span> <span class="built_in">this</span>.getLoadBalancerStats();</span><br><span class="line">                Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">                logger.debug(<span class="string">&quot;Zone snapshots: &#123;&#125;&quot;</span>, zoneSnapshot);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.triggeringLoad == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.triggeringLoad = DynamicPropertyFactory.getInstance().getDoubleProperty(<span class="string">&quot;ZoneAwareNIWSDiscoveryLoadBalancer.&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;.triggeringLoadPerServerThreshold&quot;</span>, <span class="number">0.2D</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.triggeringBlackoutPercentage == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.triggeringBlackoutPercentage = DynamicPropertyFactory.getInstance().getDoubleProperty(<span class="string">&quot;ZoneAwareNIWSDiscoveryLoadBalancer.&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;.avoidZoneWithBlackoutPercetage&quot;</span>, <span class="number">0.99999D</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//获取可用的区域，而区域又有算法规则，涉及到了IRule设计规则的顶级接口，</span></span><br><span class="line">                Set&lt;String&gt; availableZones = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, <span class="built_in">this</span>.triggeringLoad.get(), <span class="built_in">this</span>.triggeringBlackoutPercentage.get());</span><br><span class="line">                logger.debug(<span class="string">&quot;Available zones: &#123;&#125;&quot;</span>, availableZones);</span><br><span class="line">                <span class="keyword">if</span> (availableZones != <span class="literal">null</span> &amp;&amp; availableZones.size() &lt; zoneSnapshot.keySet().size()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">zone</span> <span class="operator">=</span> ZoneAvoidanceRule.randomChooseZone(zoneSnapshot, availableZones);</span><br><span class="line">                    logger.debug(<span class="string">&quot;Zone chosen: &#123;&#125;&quot;</span>, zone);</span><br><span class="line">                    <span class="keyword">if</span> (zone != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">BaseLoadBalancer</span> <span class="variable">zoneLoadBalancer</span> <span class="operator">=</span> <span class="built_in">this</span>.getLoadBalancer(zone);</span><br><span class="line">                        server = zoneLoadBalancer.chooseServer(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Error choosing server using zone aware logic for load balancer=&#123;&#125;&quot;</span>, <span class="built_in">this</span>.name, var8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> server;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Zone avoidance logic is not invoked.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.chooseServer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Zone aware logic disabled or there is only one zone&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.chooseServer(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取基本的负载均衡</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    BaseLoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">(String zone)</span> &#123;</span><br><span class="line">        zone = zone.toLowerCase();<span class="comment">//由外部传入的一个区域</span></span><br><span class="line">        <span class="type">BaseLoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> (BaseLoadBalancer)<span class="built_in">this</span>.balancers.get(zone);</span><br><span class="line">        <span class="keyword">if</span> (loadBalancer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">IRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="built_in">this</span>.cloneRule(<span class="built_in">this</span>.getRule());</span><br><span class="line">            loadBalancer = <span class="keyword">new</span> <span class="title class_">BaseLoadBalancer</span>(<span class="built_in">this</span>.getName() + <span class="string">&quot;_&quot;</span> + zone, rule, <span class="built_in">this</span>.getLoadBalancerStats());</span><br><span class="line">            <span class="type">BaseLoadBalancer</span> <span class="variable">prev</span> <span class="operator">=</span> (BaseLoadBalancer)<span class="built_in">this</span>.balancers.putIfAbsent(zone, loadBalancer);</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                loadBalancer = prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Ribbon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.LoadBalancerStats;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.Server;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.ZoneAwareLoadBalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动模拟注册中心数据，并自定义选择模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZoneAwareLoadBalancer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Server&gt; serverList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//注册中心里面的各个模块下的名称、端口等数据</span></span><br><span class="line">        serverList.add(createServer(<span class="string">&quot;xiaoer&quot;</span>,<span class="string">&quot;xiaoer-1&quot;</span>,<span class="number">8001</span>));</span><br><span class="line">        serverList.add(createServer(<span class="string">&quot;xiaoer&quot;</span>,<span class="string">&quot;xiaoer-1&quot;</span>,<span class="number">8002</span>));</span><br><span class="line">        serverList.add(createServer(<span class="string">&quot;er&quot;</span>,<span class="string">&quot;er-1&quot;</span>,<span class="number">8001</span>));</span><br><span class="line">        <span class="comment">//设置区域的数据后，进行负载均衡算法的配置</span></span><br><span class="line">        <span class="type">ZoneAwareLoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZoneAwareLoadBalancer</span>();</span><br><span class="line">        loadBalancer.addServers(serverList);<span class="comment">//添加服务集合。</span></span><br><span class="line">        <span class="type">LoadBalancerStats</span> <span class="variable">stats</span> <span class="operator">=</span> loadBalancer.getLoadBalancerStats();<span class="comment">//获取统计数据</span></span><br><span class="line">        stats.updateServerList(serverList);<span class="comment">//服务列表更新</span></span><br><span class="line">        stats.getServerStats().keySet().forEach(currentServer -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentServer.getZone().equals(<span class="string">&quot;er&quot;</span>)) &#123; <span class="comment">//设置的区域算法。此处就是 区域为er的下线了，所以下方打印不出来</span></span><br><span class="line">                loadBalancer.markServerDown(currentServer);<span class="comment">//服务下线</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loadBalancer.getServerCount(<span class="literal">true</span>); i++) &#123;</span><br><span class="line">            System.out.println(loadBalancer.chooseServer(<span class="literal">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title function_">createServer</span><span class="params">(String zone,String url,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Server</span>(url,index);</span><br><span class="line">        server.setZone(zone);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/10/13/Ribbon-1/result.png"></p><p>三个模块的数据，因自定义的下线算法而不能被检测出</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transient</title>
      <link href="/2022/10/10/transient/"/>
      <url>/2022/10/10/transient/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>对于transient修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。因此，<em><strong>transient变量不会贯穿对象的序列化和反序列化。生命周期仅存于调用者的内存中而不会也到磁盘进行持久化</strong></em></p><p>序列化：Java中对象序列化指的是将对象转为成以字节序列的形式表示，这些字节包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可以用于网络传输。一般使用cache或远程调用RPC的时候，经常实现Serializable接口，目的就是让其可序列化。序列化本身的目的就是为了可以反序列化，恢复成原本的Java对象的实例</p><p>小结</p><ul><li>一旦变量被transient修饰，变量就不再是对象持久化的一部分，该变量内容在序列化后无法被访问</li><li>transient关键字只能修饰变量，不能修饰方法和类。本地变量不能被transient修饰。变量若是用户自定义类变量，则该类需要实现serializable接口</li><li>一个静态变量不管是否被transient修饰，均不能序列化（若反序列化后类中static变量还有值，则值为当前JVM中对应static变量的值）序列化保存的是对象状态，静态变量保存的是类状态，所以序列化不能保存静态变量</li></ul><p>使用场景：</p><ul><li>类中字段值可以根据其他字段推导出</li><li>一些安全性的信息，一般情况是不能离开JVM的</li><li>若类中使用Logger实例，那么Logger实例不需要实例化</li></ul><p>例：在List接口下的ArrayList类中，底层的elementData就是被transient修饰，此处的目的不是为了不被实例化，而是不使用默认的serializable接口实例化，且实现自定义的实例化规则。它会复写writeObject和readObject方法，让实际真正写入的元素被实例化，剩余没有被写入元素的空间不被实例化，以免造成空间浪费</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> transient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty-IO</title>
      <link href="/2022/10/06/Netty-IO/"/>
      <url>/2022/10/06/Netty-IO/</url>
      
        <content type="html"><![CDATA[<h1 id="传统BIO"><a href="#传统BIO" class="headerlink" title="传统BIO"></a>传统BIO</h1><p>网络编程的基本模型是Client&#x2F;Server模型，就是两个进程之间相互通信，服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，若建立成功就通过网络套接字通信</p><p>同步阻塞I&#x2F;O服务端通信模型（一客户端一线程）：</p><p><img src="/2022/10/06/Netty-IO/BIO.png"></p><p>采用BIO通信模型的服务端，通常由一个Acceptor线程负责监听客户端的连接，它接收到客户端连接请求后给每个客户端创建一个新线程进行链路处理，处理完成后通过输出流返回应答给客户端，线程销毁。一请求一应答通信类型。</p><p>该模型最大的问题就是<strong>缺乏弹性伸缩力</strong>：当客户端并发量增加，服务端的线程个数和客户端并发访问量呈正比关系，线程数的膨胀会让系统性能下降，并发访问量的持续增大，系统也会线程堆栈溢出、创建新线程失败等问题，最终进程会宕机或僵死，不能提供服务。</p><p>综上：每当一个新的客户端请求接入时，服务端必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接。在实际中，却常常有成千上万个客户端的并发连接，该模型显然不能满足场景。</p><h1 id="伪异步I-x2F-O"><a href="#伪异步I-x2F-O" class="headerlink" title="伪异步I&#x2F;O"></a>伪异步I&#x2F;O</h1><p>同步阻塞I&#x2F;O的一个链路需要一个线程处理，所以可以通过一个线程池处理多个客户端的请求接入，形成客户端个数M，线程池最大线程数N，M可以远大于N。线程池可以灵活调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><p>伪异步I&#x2F;O服务端通信模型：</p><p><img src="/2022/10/06/Netty-IO/WIO.png"></p><p>当有新客户端接入，将客户端的socket封装成一个Task投递到后斗你的线程池中处理，JDK的线程池维护一个消息嘟列和N个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，所以它占用的资源可控，不会让资源耗尽或宕机。</p><p>伪异步I&#x2F;O实际上只是对之前的I&#x2F;O模型的一个简单优化，无法从根本上解决同步I&#x2F;O导致的通信线程阻塞问题；如果所有可用线程都被服务器阻塞，那么后续所有I&#x2F;O消息都会在消息队列中排队；因为线程池采用阻塞队列实现，当队列挤满，后续接入队列的操作也会被阻塞；因为前端只有一个Accptor线程接收客户端接入，它被阻塞在线程池的同步阻塞队列后，新客户端请求消息会被拒绝，客户端会发生大量的连接超时；</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>NIO提供了SocketChannel和ServerSocketChannel两种套接字通道实现，阻塞和非阻塞两种。</p><p>相关概念：</p><ul><li>缓冲区Buffer：一个对象，包含一些要写入或者要读出的数据。在面向流的I&#x2F;O中，可以将数据直接写入或者直接读到Stream对象中。NIO库中，<em><strong>所有数据都是用缓冲区处理</strong></em>。Buffer实质上是一个数组（最常见的就是ByteBuffer，所以它还提供了特有的一些操作），当然还提供了对数据的结构化访问以及维护读写位置等信息</li><li>通道Channel：就好比自来水管，网络数据通过Channel读取和写入；<strong>通道与流不同就在于通道是双向的，流只在一个方向上移动，而通道可用于读、写或同时进行</strong>；&#x3D;&#x3D;全双工&#x3D;&#x3D;，所以比流更好映射操作系统的API；可以分为两大类：对网略读写的SelectableChannel和对文件操作的FileChannel</li><li>多路复用器Selector：是NIO的基础，它会不断轮询注册在其上Channel，若某个Channel发生读或写，这个Channel就处于就绪状态，会被Selector轮询出来，再通过SelectionKey获取就绪Channel集合，进行后续的I&#x2F;O操作；</li></ul><p>NIO服务端通信序列图</p><p><img src="/2022/10/06/Netty-IO/NIOS.png"></p><p>NIO客户端序列图:</p><p><img src="/2022/10/06/Netty-IO/NIOC.png"></p><p>NIO优点：</p><ul><li>客户端发起的连接是异步，可通过在多路复用器注册OP_CONNECT等后续结果，不像之前的客户端被同步阻塞</li><li>SocketChannel的读写都是异步，没有可读写的数据可以直接返回，这样I&#x2F;O通信线程就可以处理其他的链路</li><li>线程模型的优化：因为JDK的Selector在Linux等操作系统上通过epoll实现，它没有连接句柄数的限制，这样一个Selector线程可以同时处理大量客户端连接，性能也不会因客户端增加而线性下降，所以非常适合高性能、高负载的网络服务器</li></ul><h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p>NIO2.0引入的新的异步通道，不需要通过多路复用器对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。提供了异步文件通道和异步套接字的实现，异步通道提供两种方式获取操作结果：java.util.concurrent.Future类来表示异步操作的结果；在执行异步操作的时候穿衣个Java.nio.channels。</p><h1 id="对比I-x2F-O"><a href="#对比I-x2F-O" class="headerlink" title="对比I&#x2F;O"></a>对比I&#x2F;O</h1><p>异步非阻塞I&#x2F;O：只能被称为非阻塞I&#x2F;O，不能交异步非阻塞I&#x2F;O。JDK1.4的Selector基于select&#x2F;poll模型实现，是基于I&#x2F;O复用技术的非阻塞I&#x2F;O；JDK1.5优化了Selector，在底层使用epoll替换了select&#x2F;poll，上层的API不变，没有改变I&#x2F;O的模型；JDK1.7提供NIO2.0新增了异步的套接字通道，才会真的异步I&#x2F;O，在异步I&#x2F;O操作的时候可以传递信号变量，当操作完成后会回调相关方法，异步I&#x2F;O才是AIO</p><p>多路复用器：NIO的关键是I&#x2F;O多路复用技术，技术核心就是通过Selector轮询注册在其上的Channel，当发现某个或多个Channel处于就绪状态，返回就绪态的Channel选择键集合，进行I&#x2F;O操作。</p><p>伪异步I&#x2F;O：NIO没有流行前，为了Tomcat通信线程同步I&#x2F;O导致业务线程被挂住的问题。所以就在通信线程和业务线程之前做个缓冲区，缓冲区用于隔离I&#x2F;O线程和业务线程间的直接访问</p><h1 id="不用Java-NIO而用Netty"><a href="#不用Java-NIO而用Netty" class="headerlink" title="不用Java NIO而用Netty"></a>不用Java NIO而用Netty</h1><p>不用NIO的原因</p><ul><li>NIO的类库和API繁杂，使用麻烦，要熟练使用相关API。Selector、ServerSocketChannel、SocketChannel、ByteBuffer</li><li>需要具备其他的额外技能。比如java多线程编程</li><li>可靠性能力补齐，工作量和难度都打</li><li>JDK NIO的BUG。比如：epoll 会导致Selector空轮序，而让CPU消耗100%，只是概率降低</li></ul><p>选Netty：</p><ul><li>API使用简单，开发门槛低</li><li>功能强大，预设置了多种编码解码功能，支持多种主流协议</li><li>定制能力强，可通过ChannelHandler对通信框架灵活的拓展</li><li>性能高，对比其他NIO框架，Netty综合性能优</li><li>社区活跃，版本迭代周期短，有BUG可及时修复</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap</title>
      <link href="/2022/10/03/LinkedHashMap/"/>
      <url>/2022/10/03/LinkedHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>实现是通过键值对维护一个双向链表，保证了<em><strong>元素迭代的顺序</strong></em>，该顺序可是插入顺序也可是访问顺序</p><p>可以认为是：HashMap+LinkedList</p><p>可以用作缓存</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部类，存储K-V键值对   </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//前驱指针和后驱指针</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">    <span class="comment">//next用于维护HashMap指定table位置上连接的Entry的顺序</span></span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//头尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">    <span class="comment">//指定LinkedHashMap的排序方式，true就为访问顺序排序，false就为插入顺序排序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在节点删除后，维护链表，传入删除的节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">//p指向待删除元素，b执行前驱，a执行后驱</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//这里执行双向链表删除p节点操作，很简单。</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在节点被访问后根据accessOrder判断是否需要调整链表顺序</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">      LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">      <span class="comment">//如果accessOrder为false，什么都不做</span></span><br><span class="line">      <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">          <span class="comment">//p指向待删除元素，b执行前驱，a执行后驱</span></span><br><span class="line">          LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">              (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">          <span class="comment">//这里执行双向链表删除操作</span></span><br><span class="line">          p.after = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">              head = a;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              b.after = a;</span><br><span class="line">          <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">              a.before = b;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              last = b;</span><br><span class="line">          <span class="comment">//这里执行将p放到尾部</span></span><br><span class="line">          <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">              head = p;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              p.before = last;</span><br><span class="line">              last.after = p;</span><br><span class="line">          &#125;</span><br><span class="line">          tail = p;</span><br><span class="line">          <span class="comment">//保证并发读安全。</span></span><br><span class="line">          ++modCount;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用hashmap的getNode方法获取到值之后，维护链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>就是HashMap的put方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//默认的传入的evict是true</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//如果e不为null，此时的e指向的就是在map中的那个插入点，所以这个时候来赋值。</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="comment">// onlyIfAbsent入口参数，为true，则不更新value。</span></span><br><span class="line">                <span class="comment">//这个地方的主要作用主要控制如果map中已经有那个key了，是否需要需要更新值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">//这里其实是插入成功后执行的，获得的效果就是将e放到了链表结尾。</span></span><br><span class="line">                <span class="comment">//所以afterNodeInsertion方法就算什么都不做也可以。</span></span><br><span class="line">                <span class="comment">//但是如果accessOrder为false，那么我们新插入的节点，都不会进入链表了</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast-fail机制的实现，为了保证并发读安全。</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//容器中的键值对数自增，如果大于了阈值，开始扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其中会在合适的地方对链表进行相应的维护</span></span><br></pre></td></tr></table></figure><h1 id="对比HashMap"><a href="#对比HashMap" class="headerlink" title="对比HashMap"></a>对比HashMap</h1><p>LinkedHshMap虽然继承了HashMap，但实现了双线链表，有固定的顺序，与插入entry的顺序一样，有序性的表现就是遍历输出的顺序与put进去的顺序一致；HashMap存储是无序的；因为LinkedHashMap是HashMap的子类，总之具备HashMap的所有特性，就多了一个双向链表维护内部数据的顺序关系</p><p>两者都是非线程安全、都实现了序列化接口等、都支持null键和值、都不同步</p><h1 id="实现LRU算法"><a href="#实现LRU算法" class="headerlink" title="实现LRU算法"></a>实现LRU算法</h1><p><img src="/2022/10/03/LinkedHashMap/LRU.png"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap</title>
      <link href="/2022/09/30/TreeMap/"/>
      <url>/2022/09/30/TreeMap/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>存储K-V键值对，通过<em><strong>红黑树</strong></em>实现。因为红黑树本身是一颗自平衡的排序二叉树，节点的值大于左节点而小于右节点的值。所以在一定程度上，遍历时比较高效的。</p><p>它是<em><strong>有序</strong></em>的集合（因为它实现了NavigableMap接口，该接口拓展了SortedMap接口，又拓展Map接口）。而且由红黑树实现的，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。</p><p>遍历分两步：通过entrySet()或keySet()或value获取相应的集合；再迭代器遍历该集合</p><p><img src="/2022/09/30/TreeMap/jiegou.png"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//内部结构，类似于HashMap的形式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//实际存储在实例的节点个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对树结构的修改次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      K key; <span class="comment">// key 值</span></span><br><span class="line">      V value; <span class="comment">// value 值</span></span><br><span class="line">      java.util.TreeMap.Entry&lt;K,V&gt; left;  <span class="comment">// 指向左边的子节点</span></span><br><span class="line">      java.util.TreeMap.Entry&lt;K,V&gt; right; <span class="comment">// 指向右边的子节点</span></span><br><span class="line">      java.util.TreeMap.Entry&lt;K,V&gt; parent; <span class="comment">// 指向父节点</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK; <span class="comment">// 默认节点颜色 黑</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化 Entry</span></span><br><span class="line">      Entry(K key, V value, java.util.TreeMap.Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.parent = parent;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">          <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个数据</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到红黑树的根节点</span></span><br><span class="line">        java.util.TreeMap.Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="comment">// 根节点为null, TreeMap中没有任何数据</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类型检查（可能为空）</span></span><br><span class="line">            compare(key, key);</span><br><span class="line">            <span class="comment">// 将当前的 key,value 生成根节点Entry</span></span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">java</span>.util.TreeMap.Entry&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 操作次数 +1</span></span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        <span class="comment">// 定义父节点</span></span><br><span class="line">        java.util.TreeMap.Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// 比较器</span></span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="comment">// 用户传入的比较器不为空</span></span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环查找 key在二叉树对应的位置【即找到一个父节点】</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                <span class="comment">// key与当前节点的key进行对比</span></span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="comment">// cmp &lt; 0 找到当前节点的左子节点再去对比</span></span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="comment">// cmp &gt; 0 找到当前节点的右子节点再去对比</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="comment">// cmp = 0 当前节点即是key的节点，用Value值替换掉旧值</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 key 数据类型中默认的比较器，后面逻辑相同</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的代码如果直接return了表示。TreeMap中原来存在 key=参数key的节点，直接覆盖返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的代码表示红黑树中不存在Key，需要为其创建节点， parent上面循环得到的二叉树的叶子及诶到哪</span></span><br><span class="line">        java.util.TreeMap.Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">java</span>.util.TreeMap.Entry&lt;&gt;(key, value, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cmp &lt; 0 表示当前key生成的Entry是parent的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="comment">// cmp &gt; 0 表示当前key生成的Entry是parent的右节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">        <span class="comment">// 插入新的节点后，红黑树进行修复【节点颜色变化,左右旋等】，保证其扔就满足红黑树的特性</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 key 获取到Value的值</span></span><br><span class="line">   <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       java.util.TreeMap.Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">       <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 key 值找到对应的 Entry</span></span><br><span class="line">   <span class="keyword">final</span> java.util.TreeMap.Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">       <span class="comment">// TreeMap 中key 不可以为空</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">       <span class="comment">// 得到TreeMap 中红黑树的 根节点</span></span><br><span class="line">       java.util.TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">       <span class="comment">// 循环遍历</span></span><br><span class="line">       <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// key和当前节点的key比较</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">           <span class="comment">// 根据二叉树的原理，</span></span><br><span class="line">           <span class="comment">// cmp &lt; 0 找左节点</span></span><br><span class="line">           <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">               p = p.left;</span><br><span class="line">           <span class="comment">// cmp &gt; 0 找右节点</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">               p = p.right;</span><br><span class="line">           <span class="comment">// 当前节点就是要查找的节点</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="对比HashMap"><a href="#对比HashMap" class="headerlink" title="对比HashMap"></a>对比HashMap</h1><table><thead><tr><th align="center">TreeMap</th><th align="center">HashMap</th></tr></thead><tbody><tr><td align="center">有序，实现了SortedMap接口</td><td align="center">无序的，因为直接实现了Map接口</td></tr><tr><td align="center">底层是红黑树实现，时间效率较低，需要对比遍历</td><td align="center">由哈希桶实现，哈希算法本身的优势所以时间效率较高</td></tr><tr><td align="center">只保存需要保持的节点，占用内存较小</td><td align="center">要保存一个node的数组，数组下又有链表或红黑树，于是内存占用较大</td></tr><tr><td align="center">不允许null key</td><td align="center">允许null key</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch简介</title>
      <link href="/2022/09/27/ElasticSearch%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/09/27/ElasticSearch%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-Lucene"><a href="#Apache-Lucene" class="headerlink" title="Apache Lucene"></a>Apache Lucene</h1><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><ul><li>文档：索引与搜索的主要数据载体，它包含一个或多个字段。存放将要写入索引或将从索引搜索出来的数据</li><li>字段：文档的一个片段，包括两个部分：字段的名称和内容</li><li>词项：搜索时的一个单位，代表文本中的某个词</li><li>词条：词项在字段中的一次出现，包括词项的文本、开始和结束的位移以及类型</li></ul><p>Lucene将写入索引的所有信息自支撑一种名为倒排索引的结构。该结构是一种将词项映射到文档的数据结构，工作方式与传统的关系型数据库不同，倒排索引是面向词项而不是文档。</p><p>索引存储了很多信息，比如词向量、各字段的原始信息、文档删除标记等。不用管存了什么，只需要了解索引中数据是如何组织的即可。</p><p>每个索引由多个段组成，每个段只会被创建一次但会被查询多次。索引期间，段在创建后就不会被修改。多个段会在<code>段合并</code>的的阶段合并在一起，而且是要么强制执行要么由Lucene的内在机制决定的某个时刻执行，合并后的段数量更少、更大。<em><strong>段合并很消耗I&#x2F;O</strong></em>，合并期间有些不会被使用的信息也会被清理</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析：文档中的数据是如何转化为倒排索引的，查询串又是怎么转换为可用于搜索的词项</p><p>文本分析由分析器执行，分析器由分词器、过滤器、字符映射器组成。</p><ul><li>分词器：分词器将文本切割成词条，其中有各种额外信息的词项，信息包括：词项在原始文本中的位置、词项的长度。分词器的工作成果称为词条流，因为这些词条会被一个一个推送给过滤器。</li><li>过滤器：Lucene提供了很多现成的，也可以自定义实现心得。比如：小写过滤器（所有词条转化为小写）、ASCII过滤器（移除词条中所有非ASCII字符）。会逐个经过过滤器处理</li><li>字符映射器：用于调用分词之前的文本预处理操作。</li></ul><p>在索引期，Lucene会使用我们选择的分析器来处理文档的内容，可以对不同的字段使用不同的分析器。</p><h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><p>是一个可用于构建搜索应用的成品软件。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>索引：将数据存储在一个或多个索引中。索引就好比数据库，可以向索引写入文档或者从索引读取文档，并通过在ES内部使用Lucene将数据写入索引或从索引中检索数据。ES中的索引可能由一个或多个Lucene索引构成，具体细节由ES的索引分片、复制机制及其配置决定</li><li>文档：是ES的主要实体，由字段组成，每个字段都有它的字段名以及一个或多个字段值（有多个同名字段）。文档之间可能有各自不同的字段集合，且文档没有固定的模式或强制的结构。</li><li>类型：每个文档都有阈值对应的类型定义。允许用户在一个索引中存储多种文档类型，并未不同的文档类型提供不同的映射</li><li>节点：单个ES服务实例称为节点。大多时候一个ES节点足矣应付大多数简单的应用，但考虑到荣凑性或在数据膨胀到单击无法应付，会倾向使用多节点的ES集群</li><li>集群：数据量或查询压力超过单击负载时，需要多个节点来协同处理，所有节点组成的系统就是集群。集群同时是无间断提供服务的一种解决方案</li><li>分片：集群允许系统存储的数据总量超过单击容量。为了满足该需求，ES将数据散步到多个物理Lucene索引上，这些Lucene索引就是分片，散步分片的过程就是分片处理。ES会自动完成分片处理，并让该分片呈现出一个大索引。</li><li>副本：分片处理允许用户向ES集群推送超过单击容量的数据。副本就解决了访问压力过大时单击无法处理所有请求的问题。思路就是 为每个分片创建冗余的副本，处理查询时可以把这些副本用作最初的主分片。即使某个分片所在的节点宕机，ES可以使用其副本，数据就不会丢失，且可以在任意时间添加或移除副本。</li><li>网关：ES工作中，关于集群的状态，索引设置的各种信息都会被收集器来，并在网关中被持久化。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>启动过程：当ES节点启动时，它使用广播（可配置为单播）来发现同一个集群中的其他节点并与他们连接。集群中会有一个节点选为管理节点（负载集群的状态管理以及在集群拓扑变化时做出变化，分发索引分片至集群的相应节点上），管理节点读取集群的状态信息，并在必要时恢复处理。该阶段，管理节点会检查所有索引分片并决定哪些分片将用于主分片，然后整个集群进入黄色状态；</p><p>故障检测：集群正常工作时，管理节点会检测所有可用节点，检测是否正在工作。若任何节点再预定义的超时时间内没有响应，则认为该节点断开，然后开始启动错误处理过程。这要在集群-分片之间重新做平衡，因为之前已断开节点上的那些分片不可用，剩下的节点要负相应的责任。</p><p>与ES通信：ES假设数据由URL携带或者以JSON，文档的形式由HTTP消息携带。ES在内部使用Java API进行节点间通信</p>]]></content>
      
      
      <categories>
          
          <category> 搜索引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK19</title>
      <link href="/2022/09/26/JDK19/"/>
      <url>/2022/09/26/JDK19/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JDK19于2022-09-20发布GA版本。是一个非LTS版本，将以结构化并发、虚拟线程、切换表达模式匹配、向量API和Linux&#x2F;RISC-V端口为特色</p><p>JDK 19的早期访问版本可以从JDK.java.net&#x2F;19访问。JDK 19功能包括：</p><ul><li>在孵化器阶段，结构化并发旨在通过结构化并发API简化多线程编程。这种并发性将在不同线程中运行的多个任务视为单个工作单元，以简化错误处理和取消。提高了可靠性和可观测性。</li><li>记录模式record的预览，用于解构record记录值。记录模式和类型模式可以嵌套，以实现声明性、强大且可组合的数据导航和处理形式。该提案的目标包括扩展模式匹配以表达更复杂、可组合的数据查询，同时不改变类型模式的语法或语义。该提案以 instanceof 的模式匹配为基础，于2021在JDK 16中交付。未来的计划可能要求使用阵列模式和 vararg 模式等功能扩展记录模式。记录模式是Amber项目的一部分，该项目旨在探索和培育更小的、面向生产力的Java特性。</li><li>一个外部函数和内存API的预览，它将引入一个API，通过该API，Java程序可以与Java运行时之外的代码和数据进行互操作。通过有效地调用外部函数（即JVM外部的代码）和安全地访问外部内存（即未由JVM管理的内存），API使Java程序能够调用本机库并处理本机数据，而不会出现Java本机接口（ JNI ）的危险和脆弱性。外部函数和内存API结合了两个早期的孵化API：外部内存访问API和外部链接器API。外部函数和内存API之前在JDK 17中孵化，并在JDK 18中重新计算。该提案的目标包括易用性、性能、通用性和安全性。</li><li>虚拟线程的预览，这是一种轻量级线程，可以显著减少编写、维护和观察高吞吐量并发应用程序的工作量。目标包括使以简单的请求线程风格编写的服务器应用程序能够以接近最佳的硬件利用率进行扩展，并启用使用java的现有代码java.lang Thread API以最小的变化采用虚拟线程，并使用现有JDK工具对虚拟线程进行故障排除、调试和评测。本提案的目标不是改变Java中的基本并发模型，也不是在Java语言或Java库中提供新的数据并行结构。删除线程的传统实现或静默地将现有应用程序迁移到虚拟线程也不是目标。</li><li>switch 表达式和语句模式匹配的第三个预览，将模式匹配扩展到 switch ，允许针对多个模式测试表达式，每个模式都有一个特定的操作，因此可以简洁安全地表达复杂的面向数据的查询。此功能以前在JDK 17和JDK 18中进行了预览。第三次预览将添加一些改进，包括在开关块中用when子句替换受保护的模式。此外，当选择器表达式的值为null时，模式开关的运行时语义与传统开关语义更加一致。该计划的目标包括通过允许模式出现在 case 标签中，扩展switch表达式和语句的表达能力和适用性。其他目标包括允许开发人员在需要时放松 switch 的历史性零敌意，提高 switch 语句的安全性，并确保现有的 switch 表达式和语句继续编译而不发生更改，并以相同的语义执行。</li><li>第四种是vector 矢量API，它将矢量计算表示为在运行时可靠编译为支持的CPU架构上的最优矢量指令，从而实现优于等效标量计算的性能。使用API的开发人员获得了一种用Java编写复杂向量算法的方法，使用了热点自动向量器，但用户模型使向量化更加可预测和健壮。之前将载体API培养到JDK 16、JDK 17和JDK 19中。</li><li>对JDK 19提出的API的改进包括增强了向MemorySegment加载和存储向量，这是由外部函数和内存API预览定义的。JDK 19还将添加两个交叉车道矢量操作，压缩和扩展，以及互补矢量掩码压缩操作。压缩向量操作将由掩码选择的源向量的车道按车道顺序映射到目标向量，而展开操作则相反。压缩操作在过滤查询结果时很有用。除了矢量API之外，还将扩展逐位积分lanewise操作，包括计算一位的数量、反转位的顺序以及压缩和扩展位等操作。API的目标包括简洁明了、不依赖平台、在x64和AArch64体系结构上具有可靠的运行时和编译性能，以及在向量计算无法在运行时完全表示为向量操作序列的情况下实现“优雅”降级。</li><li>通过Linux&#x2F;RISC-V端口，Java将获得对硬件指令集的支持，这种硬件指令集已经得到了各种语言工具链的支持。RISC-V实际上是一个相关ISA家族。Linux&#x2F;RISC-V端口将仅支持RISC-V的RV64GV配置，这是一种包含矢量指令的通用64位ISA。Java开发人员将来可能会考虑其他RISC-V配置。</li></ul><h1 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h1><h2 id="Java线程与虚拟线程"><a href="#Java线程与虚拟线程" class="headerlink" title="Java线程与虚拟线程"></a>Java线程与虚拟线程</h2><p>常用的java线程与系统内核线程是一一对应的，系统内核的线程调度程序负载调度java线程。为了增加应用程序的性能，我们会增加java线程，所以在调度java线程的时候会占据不少资源去处理线程的上下文切换。</p><p>提高系统的吞吐量，就增加线程数量，但机器的线程昂贵、可用线程有限，即使是使用了线程池来最大化线程的性价比，但CPU、网络或内存资源还是程序性能的瓶颈。于是JDK19引入了虚拟线程，在19中，之前常用的平台线程与系统内核线程还是一一对应。</p><h2 id="新增线程相关API"><a href="#新增线程相关API" class="headerlink" title="新增线程相关API"></a>新增线程相关API</h2><p><code>Thread.ofVirtual()和Thread.ofPlatform()</code>是创建虚拟和平台线程的新API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出线程ID 包括虚拟线程和系统线程 Thread.getId() 从jdk19废弃</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(Thread.currentThread().threadId());</span><br><span class="line"><span class="comment">//创建虚拟线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;testVT&quot;</span>).unstarted(runnable);</span><br><span class="line">testVT.start();</span><br><span class="line"><span class="comment">//创建虚平台线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">testPT</span> <span class="operator">=</span> Thread.ofPlatform().name(<span class="string">&quot;testPT&quot;</span>).unstarted(runnable);</span><br><span class="line">testPT.start();</span><br></pre></td></tr></table></figure><p><code>Thread.startVirtualThread(Runnable)</code>快速创建虚拟线程并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出线程ID 包括虚拟线程和系统线程</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(Thread.currentThread().threadId());</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.startVirtualThread(runnable);</span><br></pre></td></tr></table></figure><p><code>Thread.isVirtual()</code> 判断线程是否为虚拟线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出线程ID 包括虚拟线程和系统线程</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(Thread.currentThread().isVirtual());</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.startVirtualThread(runnable);</span><br></pre></td></tr></table></figure><p><code>Thread.join</code> 和 <code>Thread.sleep</code> 等待虚拟线程结束、使虚拟线程 sleep：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(Thread.sleep(<span class="number">10</span>));</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.startVirtualThread(runnable);</span><br><span class="line"><span class="comment">//等待虚拟线程结束</span></span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure><p><code>Executors.newVirtualThreadPerTaskExecutor()</code> 创建一个 ExecutorService，该 ExecutorService 为每个任务创建一个新的虚拟线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">  executor.submit(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持与使用线程池和ExecutorService 的现有代码互相替换、迁移。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka可靠性</title>
      <link href="/2022/09/25/Kafka%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
      <url>/2022/09/25/Kafka%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka可靠性简述"><a href="#Kafka可靠性简述" class="headerlink" title="Kafka可靠性简述"></a>Kafka可靠性简述</h1><p>Kafka<em><strong>采用了多副本的机制</strong></em>，也是大多分布式系统中惯用收发，以实现水平拓展、提供容灾能力、提升可用性和可靠性。</p><h1 id="副本剖析"><a href="#副本剖析" class="headerlink" title="副本剖析"></a>副本剖析</h1><p>副本是分布式系统常见的概念之一，是分布式系统对数据和服务提供的一种冗余方式。<em><strong>数据副本</strong></em>是在不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取该数据，是解决分布式系统数据源丢失问题的最有效的手段。另一类副本是<em><strong>服务副本</strong></em>，指多个节点提供同样的服务，每个节点都有能力接收来自外部请求并进行相应的处理。</p><p>Kafka引入多副本机制，增加副本数量提升数据容灾能力；多副本也实现故障自动转移，在某个broekr节点失效时候仍然保证服务可用。</p><ul><li>副本是相对于分区而言，副本是特定分区的副本。</li><li>一个分区中包含一个或多个副本，其中一个为leader副本，其余为follower副本，各个副本位于不同的broker节点。只有leader副本提供服务，follower副本只负责数据同步。</li><li>分区所有副本统称为AR，ISR是值与leader副本保持同步状态的副本集合，leader副本本身也是该集合中的一个。</li><li>LEO标识每个分区中最后一条消息的下一个位置，分区的每个副本都有自己的LEO，ISR中最小的LEO即为HW，俗称高水位，消费者只能拉取到HW之前的消息。</li></ul><p>从生产者发出的一条消息首先会被分区写入leader副本，不过需要等待ISR集合中的所有follower副本都同步完成后才能为认为是已提交，之后才会更新分区的HW，进而消费者可以消费到该消息</p><h2 id="副本失效"><a href="#副本失效" class="headerlink" title="副本失效"></a>副本失效</h2><p>正常情况下，分区的所有副本都是在ISR集合中，当出现异常情况某些副本就被剥离出ISR集合中。在ISR集合中，也就是处于同步失效或功能失效的副本称为失效副本，失效副本对应的分区称为同步失效分区。</p><p>失效副本不仅是指处于功能失效状态的副本，处于同步失效状态的副本也可看做失效副本。</p><p>典型情况：当leader副本中消息的流入速度比foloower副本拉取速度快，follower副本一直拉也不能与leader副本同步，若follower副本还在ISR集合中，那在leader副本下线而选取此follower副本为新的leader副本时会造成消息的严重丢失</p><p>会导致副本失效的一般情况：</p><ul><li>follower副本进程卡住，在一段时间内没有向leader副本发起同步请求。比如频繁的Full GC</li><li>follower副本进程同步太慢，在一段时间内无法追赶上leader副本。比如I&#x2F;O开销太大</li></ul><h2 id="ISR伸缩"><a href="#ISR伸缩" class="headerlink" title="ISR伸缩"></a>ISR伸缩</h2><p>Kafka启动的时候会开启两个与ISR相关的定时任务</p><ul><li>“isr-expiration”定时任务：会周期性地检测每个分区是否需要缩减其ISR集合。该周期为replica.lag.time.max.ms参数大小的一半，默认值是5000ms。当检测到ISR集合中有失效副本时，就会收缩ISR集合。若某个分区的ISR集合变更，就将变更后的数据记录到ZK中。</li><li>“isr-change-propagation”定时任务：会周期性的检查isrChangeSet，若发现其有ISR集合的变更记录，就会在ZK的路径下创建一个以isr_change_开头的持久顺序节点，并isrChangeSet中的信息保存到该节点中；Kafka为该定时任务添加了一个watcher，当该节点中有子节点发生变化时会触发watcher的动作，以此通知控制器更新相关元数据信息并向它管理的broker节点发送更新元数据的请求，最后删除已处理过的节点信息。当然，若频繁触发watcher会影响性能，所以添加了限定条件，当检测到分区的ISR集合发生变化时需要检测：上一次ISR集合发生变化的时间间隔已经超过5s、上一次写入ZK的时间间隔已超过60s，满足两者之一才可以将ISR集合写入目标节点；</li></ul><p>随着follower副本同步消息，follower副本的LEO会逐渐后移，并追赶上leader副本（追赶的标准是此副本的LEO是否不小于leader副本的HW），此时该follower副本就有资格进入ISR集合。</p><h2 id="LEO和HW"><a href="#LEO和HW" class="headerlink" title="LEO和HW"></a>LEO和HW</h2><p>本地副本：对应的Log分配在当前的broker节点上。远程副本：对应的Log分配在其他的broker节点上。</p><p>Kafka中，同一个分区的信息会存在多个broker节点上，并被其上的副本管理器所管理，在逻辑层面每个broker节点上的分区就有了多个副本，但唯有本地副本才有对应的日志</p><p>在一个分区中，leader副本所在的节点会记录所有副本的LEO，follower副本所在的节点只会记录自身的LEO。各个副本所在的节点都只记录自身的HW。</p><h2 id="不支持读写分离"><a href="#不支持读写分离" class="headerlink" title="不支持读写分离"></a>不支持读写分离</h2><p>Kafka中，生产者写入消息、消费者读取消息都是与leader副本进行交互，实现的是主写主读的生产消费模型，<em><strong>且不支持读写分离</strong></em>。而数据库、Redis都具备主写主读功能、也支持主写从读（读写分离）。</p><p>读写分离的缺点：</p><ul><li>数据一致性问题：数据从主节点到从节点必有一个延时的时间窗口，该窗口会导致主从节点之间的数据不一致。</li><li>延时问题：类似Redis该类的组件，数据从写入主节点到同步到从节点的过程都要经过 网络-主节点内存-网络-从节点内存，整个过程比较耗时。而Kafka中主从同步会更耗时，网络-主节点内存-主节点磁盘-网络-从节点内存-从节点内存-从节点磁盘。对延时敏感的情况，主从功能就不适用</li></ul><p>主读从写可以均摊一定的负载却不能做到完全的负载均衡。Kafka可以大程度负载均衡</p><p>主写主读的优点：</p><ul><li>简化代码的实现逻辑，减少出错的可能</li><li>负载粒度细化均摊，与主写从读相比，负载更好且对用户可控</li><li>没有延时的影响</li><li>副本稳定的情况下，不会出现数据不一致的情况</li></ul><h1 id="日志同步机制"><a href="#日志同步机制" class="headerlink" title="日志同步机制"></a>日志同步机制</h1><p>分布式系统中，日志同步机制<em><strong>需要保证数据一致性、数据的顺序性</strong></em>，最简单高效的方法是从集群中选出一个leader来负责处理数据写入的顺序性，只要leader活着，follower就根据leader写入顺序进行同步。</p><p>但是当leader宕机后，follower中就会选出一个新的leader。follower同步状态可能落后leader很多，甚至可能还是宕机的，所以要确保<em><strong>选择具有最新日志消息的follower作为新leader</strong></em>。</p><p>日志同步机制的一个基本原则：若告知客户端已成功提交某条消息，那么即使leader宕机，也要保证新选举出的leader中能包含这条消息。这里就有权衡的地方，若leader在消息被提交前需要等更多follower确认，那么在它宕机后就可以找到follower的替代，虽然这样性能会下降。</p><p>Kafka选举不采用常见的“少数服从多数”。采用该方式，系统的延迟取决于最快的几个节点，但是为了保证leader选举的正常运行那么能容忍的失败follower数也就少，也就是要保证较高的容错率，必须要有大量副本，也正因为大量性能就会下降。</p><p>Kafka使用的是PacificA算法。Kafka动态维护着一个ISR集合，处于ISR集合内的节点保持与leader相同的高水位，只有位列其中的副本才有资格成为leader。写入消息只有所有ISR集合中的副本都确认收到后才能被认为已提交；位于ISR集合的任何副本节点都有资格成为leader，选举过程简单，开销低。leader副本的均衡保证了整体负载的均衡</p><h1 id="可靠性分析"><a href="#可靠性分析" class="headerlink" title="可靠性分析"></a>可靠性分析</h1><p>就Kafka而言，越多的副本数（在创建主题时配置也可后期修改）能保证数据的可靠性，但太多也会引起磁盘、网络带宽的浪费，性能才会下降。</p><p>生产者客户端参数ack可以提高消息的可靠性。</p><ul><li>1（默认）：生产者发送消息后，分区的leader副本成功写入就可以收到来自服务端的成功响应。若无法写入leader副本，生产者就会收到错误响应，此时可以重发消息</li><li>0：生产者发完消息不需要等待服务端的响应。消息会丢失，但可以达到最大吞吐量</li><li>-1或all：生产者发送后，需要等待所有ISR集合中所有副本都成功写入消息后才能收到响应成功。能达到最强的可靠性，但不意味着消息一定可靠，因为ISR中可能只有leader副本。</li></ul><p>broker端有两个参数可以调整同步刷盘的策略。同步刷盘是增加可靠性的方式，但是及其消耗性能。</p><p>手动位移提交也是一种方式，但有一个原则：若消息没有被成功消息，那么久不能提交所对应的消费位移。宁愿重复消费也不能因异常而消息丢失</p><p>消费端，Kafka提供了<em><strong>回溯消费</strong></em>功能来兜底，有机会对漏掉的消息进行回补，提高可靠性</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka客户端</title>
      <link href="/2022/09/19/Kafka%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2022/09/19/Kafka%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>客户端是需要与服务端交互</p><h1 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h1><p>Kafka提供了消费者客户端参数partition.assignment.strategy设置消费者与订阅主题之间的分区分配策略。Kafka提供了三种分配策略</p><ul><li>RangeAssignor分配策略：按照消费者总数和分区总数进行整除运算来获得一个跨度，然后将分区按照跨度进行平均分配，以保证分区尽可能均匀的分配给所有的消费者。对于每个主题，该策略会将消费组内所有订阅这个主题的消费者按照名称的字典排序，然后每个消费者划分固定的分区范围，若不够平均，字典序考前的会被多分一个。该情况可能出现部分消费者过载的情况。</li><li>RoudRobinAssignor分配策略：将消费组内所有消费者及消费者订阅的所有主题的分区按照字典序排序，再以轮询方式逐个将分区依次分配给每个消费者。若同一个消费组内所有的消费者的订阅消息相同，那么该策略的分区分配是平均的；若同一消费组内消费者订阅的消息不同，那么在执行分区分配就不是完全的轮询分配，有可能导致分区分配不均匀。若某消费者没有订阅消费组内的某个主题，那在分配分区的时候该消费者就分配不到该主题的任何分区。</li><li>StickyAssignor分配策略：主要有两个目的：分区的分配要尽可能均匀；分区的分配尽可能与上次分配相同。前者优先级更高。优点就是可以让分区具备“黏性”，减少不必要的分区移动（即一个分区剥离之前的消费者，转而分配给另一个新的消费者）</li></ul><p>除了Kafka提供的，还可以自定义实现分配策略。</p><h1 id="消费者协调器和组协调器"><a href="#消费者协调器和组协调器" class="headerlink" title="消费者协调器和组协调器"></a>消费者协调器和组协调器</h1><p>消费者协调器和组协调器是针对新版的消费者客户端。旧版的消费者客户端是使用ZK的监听器实现功能。</p><p>每个消费组在ZK中维护了一个&#x2F;consumers&#x2F;<group>&#x2F;ids路径，该路径下的记录都是消费组中的消费者的唯一标识id，consumerIdString由消费者启动时创建。</group></p><p>每个broker、主题和分区在ZK中也都对应的一个路径，不同的路径下记录着不同的信息</p><p>每个消费者在启动时会在两个路径上主题一个监听器。当consumer&#x2F;<group>&#x2F;ids路径下的子节点变化，表示消费组中的消费者发生变化；当&#x2F;broker&#x2F;ids路径下的子节点发生变化，表示broker出现增减。这样通过ZK所提供的Watcher，每个消费者都可以监听减肥族和Kafka集群的状态。</group></p><p>该方式下每个消费者对ZK的相关路径分别进行监听，当触发再均衡操作时，一个消费组下所有消费者会同时再均衡，而消费者之间互相不了解彼此的操作，就可能导致Kafka工作在错误状态。</p><p>严重依赖ZK集群的后果：</p><ul><li>羊群效应：ZK中一个被监听的节点变化，大量Watcher通过被发送到客户端，导致通知期间的其他操作延迟，有可能死锁</li><li>脑裂问题：消费者再均衡操作时，每个消费者都与ZK进行通信以判断消费者或broker变化情况，由于ZK本身特性，可能让同一时刻各个消费者获取的状态不同，就会有异常</li></ul><h1 id="再均衡原理"><a href="#再均衡原理" class="headerlink" title="再均衡原理"></a>再均衡原理</h1><p>新版的消费者客户端对此进行了重新设计，将全部消费组分成多个子集，每个消费组的子集在服务端对应一个GroupCoordinator（Kafka服务端中管理消费组的组件）对其管理。</p><p>触发再均衡操作的场景：</p><ul><li>新的消费者加入消费组</li><li>有消费者宕机下线。消费者不一定真正下线，可能是长时间GC、网络延迟而未发送心跳等等</li><li>消费者主动退出消费组。比如：客户端调用了方法以取消对某些主题的订阅</li><li>消费组所对应的GroupCoorinator节点变更</li><li>消费组内所订阅的任一主题或主题的分区数量变化</li></ul><p> 举例：</p><ul><li>消费者确定它所属消费组对应的GroupCoordinator所在的broekr并创建与该broker相互通信的网络连接。若消费者保留了对应的GroupCoordinator节点信息且与它之间的网络连接正常，就下一步；反之，就需要向集群中的负载最小的节点发送请求查找对应的GroupCoordinator。</li><li>找到消费组对应的GroupCoordinator后，消费者向GroupCoordinator发送请求并处理响应。若是原有消费者重新加入消费组，则在发送请求前还要做一些准备（可能开启自动提交位移功能，所以要提交消费位移；可能添加自定义的再均衡监听器，那就要清楚一些状态；因为是重新加入消费组，所以加入前要禁止心跳检测的运行）；&#x3D;&#x3D;选举消费组的leader&#x3D;&#x3D;：总体很随意，若组内还没有就选第一个加入组的消费者，若leader退出就随机选（HashMap存储消费者信息，随机的形式取出一key选）；&#x3D;&#x3D;选举分区分配策略&#x3D;&#x3D;：每个消费者都可设自己的分区分配策略，所以整个组需要各个消费者的投票决定。大致过程：收集各个消费者支持的策略，组成候选集，每个消费者从候选集中找出支持的投一票，选票最多的；</li><li>实施上一阶段决定的分区策略，之后需要将分配方案同步给各个消费者</li><li>该阶段消费组中所有消费者就处于工作状态。正式消费前，消费者要确定拉取消息的起始位置。消费者向GroupCoordinator发送心跳维持它们与消费组的从属关系以及对分区的所有权关系（心跳线程独立，可以在轮询消息的空档发）。若一消费者崩溃并停止读消息，GroupCoordinator会等待一会儿以确认其死亡再触发再均衡，等待期间不会读取分区里的消息</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>消息中间件的传输消息传输保障</p><ul><li>at most once： 至多一次。消息可能会丢失，但绝对不会重复传输。</li><li>at least once：最少一次。消息绝对不会丢失，但可能会重复传输（Kafka）</li><li>exactly once：恰好一次。每条消息肯定会被传输一次且仅传输一次</li></ul><p>当生产者向Kafka发消息，一旦被成功提交日志文件，由于多副本机制存在，该消息就不会丢失。若发送到Kafka之后，因网络问题而通信中断，生产者就不能判断消息是否已提交，所以生产者可以多次重试以确保提交到Kafka，但也可能造成消息重复写入。</p><ul><li>对于消费者，消费者处理消息和提交消费位移的顺序在很大程度决定了消费者提供哪一种消息传输保障。若消费者拉取消息后，应用逻辑先处理消息后提交消费位移，那么在消费处理后且在位移提交前消费者宕机了，待它重新上限后，会从上一次位移提交的位置拉取，就出现了重复消费。对应at least once</li><li>对于消费者，若消费者在拉完消息后，应用逻辑先提交消费位移再进行消息处理，那么在位移提交后且在消息处理完成前消费者宕机，重新上线后，会从已经提交的位移处开始消费，但是之前有部分消息没有被消费，就造成消息丢失。对应at most once</li></ul><p>于是，Kafka引入幂等和事务两个特性</p><p>幂等：简单说就是<em><strong>对接口的多次调用所产生的结果和调用一次是一致的</strong></em>。生产者在进行重试的时候可能会重复写入消息，使用Kafka的幂等性功能后可以避免该情况。不能跨多个分区运作</p><p>事务：可以弥补跨多个分区运作的缺陷。<em><strong>保证对多个分区写入操作的原子性</strong></em>。为了实现事务，应用程序必须提供唯一的transactionalId，该值通过客户端参数transactional.id设置。能保证的语义相对偏弱。</p><p>Kafka不能保证已提交的事务中的所有消息都能被消费的原因：</p><ul><li>对采用日志压缩策略的主题，事务中的某些消息可能被清理。（相同的key，前写入的消息被后面的覆盖）</li><li>事务中消息可能分布在同一个分区的多个日志分段中，老的日志分段被删除时，对应的消息可能丢失</li><li>消费者可以通过seek()方法访问任意offset消息，从而可能遗漏事务中的部分消息</li><li>消费者在消费时可能没有分配到事务内的所有分区，就不能读取事务中的所有消息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka服务端</title>
      <link href="/2022/09/17/Kafka%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2022/09/17/Kafka%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h1><p>自定义了一组<em><strong>基于TCP的二进制</strong></em>协议，遵守该组协议的格式，就可以向Kafka发送消息、拉取消息。</p><p>在Kafka2.0中，共43种协议类型，每种协议类型都有对应的请求和响应，都遵守特定的协议模式。每种类型的Request都包含相同结构的协议请求头和不同结构的协议请求体。</p><ul><li>协议请求头</li></ul><p><img src="/2022/09/17/Kafka%E6%9C%8D%E5%8A%A1%E7%AB%AF/qingqiutou.png"></p><table><thead><tr><th align="center">域</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">api_key</td><td align="center">API标识，</td></tr><tr><td align="center">api_version</td><td align="center">API版本号</td></tr><tr><td align="center">correlation_id</td><td align="center">由客户端指定的一个数字来唯一标识此次请求的id，服务端在处理完请求后也把相同的coorelation_id写到Response中。如此，客户端就能把某个请求和响应对应</td></tr><tr><td align="center">client_id</td><td align="center">客户端id</td></tr></tbody></table><ul><li>协议响应头</li></ul><p>每种类型的Response也包含相同结构的协议响应头和不同结构的响应体</p><p><img src="/2022/09/17/Kafka%E6%9C%8D%E5%8A%A1%E7%AB%AF/xiangyingtou.png"></p><h1 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h1><p>Kafka中存在大量的延时操作（延时生产、延时拉取、延时删除等等），没有使用JDK自带的Timer或DelayQueue以实现延时功能，而是使用基于时间轮的概念实现了<em><strong>用于延时功能的定时器</strong></em>。</p><p>时间轮由多个时间格组成，每个时间格代表当前轮的基本时间跨度。时间格个数固定，整个时间轮的总体跨度不变</p><p><img src="/2022/09/17/Kafka%E6%9C%8D%E5%8A%A1%E7%AB%AF/shijianlun.png"></p><p>时间轮的轮转是靠“收割机”线程驱动，由延时操作管理器启动。“收割机”线程还会定期清理监听池中已完成的延时操作。</p><h1 id="延时操作"><a href="#延时操作" class="headerlink" title="延时操作"></a>延时操作</h1><p>若生产者客户端发消息时将acks参数设置为-1，那么久需要等待ISR集合中所有副本都确认收到消息后才能收到响应的结果或捕获超时异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：某个分区有三个副本leader1、follower1、follower2且都在ISR集合中，Kafka在收到客户端生产请求后，消息3和4写入leader副本的本地日志文件后，需要等到follower1和follower2两个副本都收到消息3和4后才能告知客户端正确地接收了所发送的消息，若超时则抛异常。此处，在消息写入leader副本的本地日志文件后，Kafka会创建一个延时的生产操作来处理消息正常写入所有副本或超时情况，以返回相应的响应结果给客户端。</span><br></pre></td></tr></table></figure><p>Kafka有多个延时操作，需要延时返回响应结果，首先就要有超时时间，超时就要强制完成以响应结果；其次延时不同于定时操作，定时操作是在特定时间后执行的操作，延时操作可以在设定的时间之前完成，于是&#x3D;&#x3D;延时操作能支持外部事件的触发&#x3D;&#x3D;。</p><p>延时操作创建后会被加入延时操作管理器做专门的处理，延时操作可能超时，每个延时操作管理器都会配备一个定时器做超时管理，定时器的底层就是用的时间轮。因为需要支持外部事件，所以还配备一个监听池来监听每个分区的外部事件（查看是否有分区的HW增长）</p><p>而对于延时拉取，Kafka会先读取一次日志文件，若收集不到足够多的消息，就会创建一个延时拉取操作以等待拉取到足够数量的消息。当延时拉取操作执行时，会再读一次日志文件，再将拉取结果返回给follower副本。延时拉取操作也会有专门的延时操作管理器负载，与上述相同。若拉取进度一直没有赶上leader副本，那么在拉取laeader副本的消息时一般拉取的消息大小会不小于某个值，这样Kafka不会创建延时操作，而是直接返回拉取结果。</p><h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><p>Kafka集群中会有一个或多个broker，其中一个 broker会被选为控制器，负责管理整个集群中所有分区和副本的状态。当某个leader副本有问题，由控制器负载该分区选举新的leader副本；当检测当某个分区的ISR集合发生变化，由控制器通知所有broker更新其元数据信息；为某个topic增加分区数量时负责分区的重新分配</p><p>Kafka中控制器选举依赖于ZooKeeper，成功竞选的broker会在ZK中创建&#x2F;controller这个临时节点。</p><p>具备控制器身份的broker会比其他普通的broker多一些作用</p><ul><li>监听分区的变化</li><li>监听主题相关的变化</li><li>监听broker相关的变化</li><li>从ZK中读取获取当前所有与主题、分区及broker有关信息并进行相应管理</li><li>启动并管理分区状态机和副本状态机</li><li>更新集群元数据信息</li><li>若参数auto.leader.rebalance.enable设置为true，则会开启一个定时任务维护分区的优先副本均衡</li></ul><p>控制器选举成功后会读取ZK中各节点的数据来初始化上下文信息，并管理。</p><p>控制器节点数据发生变化，每个broekr都会更新自身内存中保存的activeControllerId，若broker在数据变更前是控制器，在数据变更后自身的brokerid值与新的activeControllerId值不同，那就关闭相关的资源。</p><p>控制器节点被删除时，每个broekr会开始选举。</p><p>分区leader副本的选举由控制器负责。当创建分区或分区上线的时候都需要leader选举。对应的策略是按照AR集合中副本的顺序查找第一个存活的副本并且该副本在ISR集合中。</p><h1 id="两个参数"><a href="#两个参数" class="headerlink" title="两个参数"></a>两个参数</h1><table><thead><tr><th align="left">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">broker.id</td><td align="center">broekr启动之前就必须设定的，每个broker都有的唯一id值用来区分，启动时会在ZK中&#x2F;brokers&#x2F;ids路径下创建以brokerid为名称的节点。当broker下线，该虚节点会自动删除，其他节点或客户端就通过路径下是否有该brokerid来确定健康状态。</td></tr><tr><td align="left">bootstrap.servers</td><td align="center">生产者和消费者君必备的。一般可简单认为是指定将要连接的Kafka集群的broker地址列表。深层意义是Kafka集群元数据信息的服务地址</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka日志存储</title>
      <link href="/2022/09/13/Kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/"/>
      <url>/2022/09/13/Kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>若分区规则合理，那么所有的消息可以均匀的分布到不同的分区中，可以实现水平拓展。不考虑多副本的情况，一个分区对应一个日志。为防止log太大，所以Kafka引入了日志分段的概念：Log切分成多个LogSegment，相当于一个巨型文件被平均分配为多个较小的文件，这样也便于清理和维护。</p><p><img src="/2022/09/13/Kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/jiegou.png"></p><p>向Log中追加消息是顺序写入，只有最后一个LogSegment才能执行写操作，在此之前所有的LogSegment都不能写入数据。一直往最后一个LogSegment写入消息，当满足一定的条件后就需要创建新的LogSegment。</p><p><em><strong>为了便于消息的检索</strong></em>，每个LogSegment中的日志文件都有对应的两个索引文件：偏移量索引文件和时间戳索引文件。每个LogSegment都有一个基准偏移量baseOffset（表示当前LogSegment中第一条消息的offset），两个索引文件都是基于该偏移量命名。</p><p><strong>生产者发送的压缩数据在broker中也是压缩状态进行存储</strong>*</p><h1 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h1><ul><li>偏移量索引文件用来建立<em><strong>消息偏移量到物理地址之间的映射关系</strong></em>，方便快速定位消息所在的物理文件位置</li><li>时间戳索引文件是根据指定的<em><strong>时间戳来查找对应的偏移量信息</strong></em>。</li></ul><p>Kafka中的索引文件以<em><strong>稀疏索引</strong></em>的方式构造消息的索引，不保证每个消息在索引文件中都有对应的索引项。每写入一定量的消息，偏移量索引文件和时间戳索引文件分别增加一个偏移量索引项和时间戳索引项的。稀疏索引将索引索引文件映射到内存中，以加快查询的速度。偏移量索引文件中偏移量是单调递增，查询指定偏移量是使用二分查找法来定位偏移量的位置；时间戳索引文件中的时间戳也是单调递增，也是二分法查找不大于该时间戳的最大偏移量，但寻找相应的物理文件位置需要根据偏移量索引文件定位。</p><h2 id="偏移量索引"><a href="#偏移量索引" class="headerlink" title="偏移量索引"></a>偏移量索引</h2><p>偏移量索引文件格式，每项索引项占用8个字节</p><p><img src="/2022/09/13/Kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/pianyiliang.png"></p><ul><li>relativeOffset：相对偏移量，表示消息相对于baseOffset的偏移量，占4个字节，当前索引文件的文件名即为baseOffset的值</li><li>position：物理地址，也就是消息在日志分段文件中对应的物理位置，占4个字节</li></ul><p>消息的偏移量占8个字节，也就是绝对偏移量。索引项中没有直接使用绝对偏移量，而用相对偏移量，就减少索引文件占用的文件。</p><h2 id="时间戳索引"><a href="#时间戳索引" class="headerlink" title="时间戳索引"></a>时间戳索引</h2><p>时间戳索引项的格式</p><p><img src="/2022/09/13/Kafka%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/shijianchuo.png"></p><ul><li>timestamp：当前日志分段最大的时间戳</li><li>relativeOffset：时间戳所对应的消息的相对偏移量</li></ul><p>时间戳索引文件中包含若干时间戳索引项，每个追加的时间戳索引项中的timestamp必大于之前追加的索引项的timestamp，不然不追加。若broker端log.message.timestamp.type设置为LogAppendTime，那消息的时间戳必定能保持单调递增；反之，若是CreateTime类型就不能保证。生产者可以使用类似ProducerRecord的方法来指定时间戳的值。即使生产者客户端采用自动插入的时间戳也无法保证时间戳能单调递增，若两个不同时钟的生产者同时向一个分区插消息，也会造成当前分区的时间戳乱序。</p><p>与偏移量索引文件相似，时间戳索引文件大小必须是索引项大小的整数倍，不满足的会进行裁剪。</p><h1 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h1><p>Kafka将消息存储在磁盘，为了控制磁盘占用空间的不断增加就需要对消息做一定的清理操作。Kafka中每个分区副本都对应一个Log，而Log可以分为多个日志分段，这样便于日志的清理操作。</p><p>清理策略：</p><ul><li>日志删除：按照一定的保留策略直接删除不符合条件的日志分段。</li><li>日志压缩：针对每个消息的key进行整合，对于有相同key的不同value，只保留最后一个版本</li></ul><p>通过broker端参数log.cleanup.policy来设置日志清理策略，默认是‘delete’，即采用日志删除的清理策略。</p><p>日志清理的粒度可以控制到主题级别。</p><h2 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h2><p>在Kafka的日志管理器中会有一个专门的日志删除任务来周期性地检测和删除不符合保留条件的日志分段文件。默认是5分钟（broker端参数log.retention.check.interval.ms来配置）。</p><p>日志分段有三种保留策略。</p><ul><li>基于时间的保留策略：日志删除任务会检查当前日志文件中是否有保留时间超过设定的阈值来找删除的日志分段集合。</li></ul><p>​查找过期的日志分段文件是根据日志分段中最大的时间戳largestTimeStamp来计算的，因为该值可以被修改，所以不能反映日志分段在磁盘保留的时间。</p><p>​<em>若待删除的日志分段的总数比该日志文件中的所有的日志分段的数量大，那就是所有日志分段都过期了，但文件还要有一个日志分段用来接收消息的写入，该情况下会先切分出一个新的日志分段作为活跃的日志分段，然后再删除</em>。</p><p>​删除日志分段：先会从Log对象中所维护日志分段的跳跃表中移除待删除的日志分段，以保证没有线程对该分段读取；再将日志分段所对应的所有文件添加”.delete”的后缀；最后交由一个以”delete-file”命名的延迟任务去删除这些文件，延时时间默认为1分钟。</p><ul><li>基于日志大小保留策略：检查当前日志大小是否超过了设定的阈值来寻找可删除的日志分段的文件集合。阈值可通过broker参数log.retention.bytes配置<em><strong>所有日志文件的总大小</strong></em>，默认是-1表示无穷大；<em><strong>单个日志分段大小</strong></em>由broker端参数log.segment.bytes来限制，默认1GB。</li></ul><p>​删除日志分段：计算日志文件的总大小和总阈值的差值，即计算需要删除的日志总大小，再从日志文件中的第一个日志分段开始进行查找可删除的日志分段集合，找到后就删除。剩下的与时间保留策略的删除相同。</p><ul><li>基于日志起始偏移量的保留策略：某日志分段的下一个日志分段的起始的偏移量是否小于等于logStartOffset，若是则可以删除。</li></ul><p>​收集日志并删除：从头开始遍历每个日志分段，偏移量也随着增加，直到阈值。删除与上面基本相同</p><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>对于有相同key的不同value值，只保留最后一个版本。若只关心key对应的最新value值，则可以开启日志清理，Kafka会定期将相同key的消息合并，只保留最新的value值。</p><p>类比于Redis的RDB的持久化模式。若是日志删除，在系统异常崩溃后就要读取Kafka所有数据进行恢复；若是日志压缩，就可以<strong>减少数据的加载量而加快系统恢复速度</strong>*。日志压缩在某些情景下可以简化技术栈，提高系统整体质量。</p><p>删除key时：Kafka提供了<em><strong>墓碑消息</strong></em>，一条消息的key不为null，但是value为null。日志清理线程发现墓碑消息时会先进行常规的清理，并保留墓碑消息一段时间。</p><p>日志压缩执行后日志分段的大小会更小，为了防止出现太多小文件，所以在实际清理过程中不对单个日志分段进行单独清理，而是将偏移量从0到firstUncleannableOffset的所有日志分段分组，每个日志分段只属于一组。</p><h1 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h1><p>Kafka依赖于文件系统（更底层地说是磁盘）存储和缓存消息。在传统的RabbitMQ就使用内存默认为存储介质，磁盘为备选以实现高吞吐和低延迟。</p><p>Kafka用文件追加的方式写入消息，且不允许修改已写入的消息。</p><h2 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h2><p>页缓存是操作系统实现的一种主要的磁盘缓存，以较少磁盘I&#x2F;O操作。把磁盘的数据缓存到内存中，把对磁盘的访问变为对内存的访问。</p><p>当进程准备读取磁盘上的文件内容时，操作系统会先查看读取的数据所在的页是否在页缓存中，命中就返回数据，就避免磁盘I&#x2F;O操作；没命中，磁盘就向磁盘发起读取请求并将读取的数据也存入页缓存，之后再返回给进程。写数据时，也看是否命中，没命中就添加相应的页，将数据写入该页，操作系统再定时把脏页写入磁盘。</p><p><em><strong>Kafka使用了大量页缓存，即实现高吞吐的重要因素之一</strong></em>。消息先写入缓存，再操作系统负载刷盘任务，Kafka中也提供了同步刷盘（可提高消息的可靠性，但页缓存可能因机器异常而消息丢失）及间断性强制刷盘功能。刷盘最好就让操作系统负载，消息可靠性应该由多副本机制保证。</p><p>Linux会使用磁盘的一部分作文swap分区，可以进行进程调度：把当前不活跃的进程调入该分区，内存空出来的给活跃的进程用。对Kafka应该避免该内存的交换，因为其使用了大量系统页缓存，该方法性能影响很大</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>将数据直接从磁盘文件复制到网卡设备中，不用经过应用程序。提高了程序的性能，减少了内核和用户模式之间的上下切换。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka主题和分区</title>
      <link href="/2022/09/07/Kafka%E4%B8%BB%E9%A2%98%E5%92%8C%E5%88%86%E5%8C%BA/"/>
      <url>/2022/09/07/Kafka%E4%B8%BB%E9%A2%98%E5%92%8C%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>主题作为消息的归类，可以再细分为一个或多个分区，分区可以看做对消息的第二次归类。分区提高了Kafka可伸缩性、水平拓展的功能。</p><p>从Kafka底层实现看，主题和分区都是逻辑概念，分区可以有一至多个副本，每个副本对应一个日志文件，每个日志文件对应一至多个日志分段，每个日志分段还可以细分为索引文件、日志存储文件和快照文件。</p><h1 id="主题的管理"><a href="#主题的管理" class="headerlink" title="主题的管理"></a>主题的管理</h1><p>主题、分区、副本和Log的关系。主题和分区是提供给上层用户的抽象，副本层面或Log层面才是实际物理上的存在。同一个分区中的多个副本必须分布在不同的broker中，才能提供有效的数据冗余</p><p><img src="/2022/09/07/Kafka%E4%B8%BB%E9%A2%98%E5%92%8C%E5%88%86%E5%8C%BA/guanxi.png"></p><ul><li>创建主题：broker端配置了auto.create.topics.enable参数为true时，当生产者向一个尚未创建的主题发送消息时，会自动创建一个分区数位num.partitiions，副本因子为default.replication.factor的主题。当一个消费者开始从未知主题读取消息时或任意一个客户端向未知主题发送元数据都会根据这两个参数创建一对对应的主题。但因为行为非预期，不建议使用。</li><li>分区副本的分配：生产者的分区分配是每条消息指定其所要发往的分区，消费者的分区分配是值为消费者指定其可以消费信息的分区。此处的分区分配指为集群指定创建主题时分区副本分配方案，即在哪个broker中创建哪些分区的副本</li><li>修改主题：当一个主题被创建后，可能需要修改分区个数、修改配置等</li></ul><h1 id="分区的管理"><a href="#分区的管理" class="headerlink" title="分区的管理"></a>分区的管理</h1><p>分区使用多副本机制提升可靠性，但<em><strong>只有leader副本对外提供读写服务</strong></em>，而follower副本只负责在<em><strong>内部进行消息的同步</strong></em>。若一个分区的leader副本不可用，那么整个分区就不可用，此时Kafka会从follower副本选举一个新的leader副本来对外服务。创建主题的时候，该主题的分区及副本会尽可能均匀分布在各个broker节点上，对应的leader副本的分配也较均匀</p><p>为了治理负载失衡的情况，Kafka引入了优先副本的概念。优先副本是指在AR集合列表中的第一个副本，理想情况，优先副本就是该分区的leader副本。Kafka要确保所有主题的优先副本在Kafka集群中均匀分布，这样就保证了所有分区的leader均衡分布，若leader分布过于集中就会集群负载不均衡。</p><p>分区重分配：当集群中的一个节点宕机下线，若节点上的分区是单副本，那该分区就变得不可用，在恢复前，相应的数据是丢失的；若节点上的分区是多副本，那么位于该节点上的leader副本会转交到集群其他follower副本中。总之，该节点上的分区副本已功能失效，Kafka不会将这些失效的分区副本自动迁移到集群中升序的可用broker节点上，但不管会影响集群的均衡负载。当要对集群的一个节点下线时，需要将该节点上的分区副本迁移到其他可用节点上。本质：数据复制，先增加新副本，再数据同步，最后删除旧副本</p><p>复制限流：分区重分配过程中，数据复制会占用额外资源，若重分配的量太大会影响性能。所以，减少重分配粒度，以小批次的方式操作。若某个主题或某个分区的流量在某段时间过大，只靠减小粒度还是不行，这时就需要一个限流的机制</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka消费者</title>
      <link href="/2022/09/06/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>/2022/09/06/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>消费者<em><strong>负责订阅Kafka中的主题，并且从订阅的主题上拉取消息</strong></em>，与其他消息中间件不同的是，kafka的消费理念中有一层消费组的概念。<em><strong>每一个分区只能被同一个消费组中的一个消费者消费</strong></em></p><p>消费者和消费者组的模型可以让整体的消费能力具备横向伸缩性，可以改变消费者的个数而改变消费能力，过多或过少都不能改变能力。</p><p>消费组是一个<em><strong>逻辑上的概念</strong></em>，将里面的消费者归于一类，每个消费者只属于一个消费组（有固定名称），消费者在消费前需要指定所属组的名称；消费者是<em><strong>实际的应用实例</strong></em>，可以是一个线程或进程，同一个消费组内的消费者可部署在同一机器或不同机器</p><p>对于消息中间件一般由两种消息投递模式：</p><ul><li>点对点模式：基于队列，消息生产者发送消息到队列，消息消费者从队列中接收消息。</li><li>发布&#x2F;订阅模式：定义了如何向一个内容节点（主题）发布和订阅消息。主题相当于消息传递的中介。消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息，主题使得两者互相保持独立，不需要进行接触就可以保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li></ul><p>而Kafka同时支持以上两种消息投递模式：若所有消费者在同一个组，那么所有消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，就相当于点对点；若所有消费者在不同消费者，那么所有消息都会被广播给所有消费者，即每条消息都会被所有消费者处理，就相当于发布&#x2F;订阅模式的应用</p><p>正常的消费逻辑：订阅消费者客户端参数以及创建相应的消费者实例；订阅主题；拉取消息并消费；提交消费位移；关闭消费者实例</p><p>Kafka中的消费<em><strong>基于拉模式</strong></em>。消息的消费模式一般由两种模式：推模式（服务端主动将消息推送给消费者）和拉模式（消费者主动向服务端发起请求来拉取消息）。Kafka中的消息消费是一个不断轮询的过程，消费者就重复调用poll()方法，获取的就是所订阅的主题（分区）上的一组消息。</p><p>对于Kafka的分区，每条消息都有唯一的offset，消费偏移量，表示消息在分区中对应的位置。而消费者使用offset表示消费到分区中某个消息所在的位置，位移。在每次调用poll()方法，返回的是还没有被消费过的消息集，所以需要记录上一次消费时的消费位移，且该消费位移需要持久化保持（不能是保存在内存，不然重启后消费者就不知道位移了；若新的消费者加入，就会有均衡动作，对于同一分区，会可能在均衡后分配给新的消费者）</p><p><img src="/2022/09/06/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/next.png"></p><p>X就是某一次拉取操作中此分区消息的最大偏移量。所以当前消费者需要提交的消费位移就是X+1</p><p>消费者中也有控制消费速度的方法。pause()和resume()分别实现暂停某些分区在拉取操作时返回数据给客户端和恢复某些分区向客户端返回数据的操作</p><p>再均衡：分区的所属权从一个消费者转移到另一消费者的行为，它为消费者具备高可用性和伸缩性提供保障，我们能安全方便的删除或添加消费组内的消费者。但是在均衡发生时间内，消费组不可用；一个分区被重新分配给另一个消费者时，消费者当前状态也会丢失。</p><p>消费者拦截器<em><strong>主要在消费到消息或在提交消费位移时进行定制化的操作</strong></em></p><p>KafkaConsumer&#x3D;&#x3D;非线程安全&#x3D;&#x3D;。里有acquire()方法检测当前是否只有一个线程在操作，若有多个线程就抛异常，与锁不同，因为它不会造成阻塞等待，仅仅通过&#x3D;&#x3D;线程操作计算标记的方式来检测线程是否发生了并发操作&#x3D;&#x3D;。KafkaConsumer中的每个公用方法执行前都会调用该方法（除了wakeup()方法）。</p><p>KafkaConsumer的非线程安全不是意味着消费消息只能单线程方式执行。若生产者发送消息的速度比消费者的速度更快，就会有越来越多消息来不及消费而造成延迟。Kafka中消息由保留作用，有些消息可能在被消费前就被清理了，从而消息丢失。使用多线程消息消费可以提高整体消费能力。</p><p>多线程实现方式：</p><ul><li>线程封闭：即每个线程实例化一个KafkaConsumer对象，一个线程对应一个KafkaConsumer实例，消费线程。一个消费线程可以消费一个或多个分区中的消息，所有消费线程属于同一个消费组。该方法的并发度受限于分区的实际个数，消费线程更多，会有部分空闲</li><li>多个消费线程消费同一个分区，可提高消费能力，但位移提交和顺序控制的处理会很复杂，使用的极少。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka生产者</title>
      <link href="/2022/09/04/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
      <url>/2022/09/04/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><p>消息生产者，把消息投递到Kafka中</p><p>当创建真正的生产者实例前需要配置相应的参数。比如连接的Kafka集群地址。</p><p>&#x3D;&#x3D;producer线程安全&#x3D;&#x3D;，可以在多个线程中共享单个producer实例，也可以将实例进行池化来供其他线程调用</p><p>发送消息的三种模式：发后即忘（发送消息不管是否到达，在某些时候会造成消息丢失，性能最高可靠性最差）、同步、异步。</p><p>两种异常：可重试异常和不可重试的异常</p><p>生产者需要用序列化器把对象转成字节数组才能通过网络发给Kafka。相对的，消费者需要反序列化器把字节数组转换成相应的对象。两者需要一一对应。</p><p>消息通过send方法发往broker的过程，可能要拦截器（非必须）、序列化器（必须）、分区器的系列作用之后才能发往broker。若没有指定partition字段，就需要依赖分区器，根据key计算partition的值。</p><p>生产者拦截器：在消息发送前做一些准备工作，比如按某个规则过滤消息等等。producer在序列化和计算分区之前调用拦截器的onsend()方法对消息进行定制化操作</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>生产者客户端整体架构</p><p><img src="/2022/09/04/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/liucheng.png"></p><p>整个生产者客户端由两个线程协调运行（主线程和sender线程）。发送线程负责从RecordAccumulator中获取消息并将其发送到Kafka中。</p><p><em><strong>RecordAccumulator主要是用来缓存消息，让sender线程可以批量发送，以减少网络传输的资源消耗以提升性能</strong></em>。（默认32MB）。若生产者发送消息的速度超过发送到服务器的速度，生产者空间就会不足，此时的send()方法会被阻塞或抛异常。内部为每个分区都维护一个双端队列（producerBatch，一个消息批次）；消息在网络上是以字节的形式传输，发送前要创建一块内存区域来保存对应的消息，内部还有一个BufferPool，以实现ByteBuffer的复用，实现缓存高效利用。</p><p>主线程发送的消息会追加到RecordAccumulator的某个双端队列中，sender读取消息时从队列的头部读取消息，从缓存中获取消息，会改变原本的保存形式&lt;Node,List<ProducerBatch>&gt;，node就是Kafka集群中的broker节点。对于网络连接，生产者客户端是与具体的broker节点建立连接和发送消息，而不关心消息属于哪个分区；而producer的应用逻辑而言，只关注向哪个分区中发送哪些消息。</ProducerBatch></p><p>&lt;Node,List<ProducerBatch>&gt;还会封装成&lt;Node,Request&gt;，就可以将request请求发往各个node。Request是Kafka的各种协议请求。</ProducerBatch></p><p>请求从sender发往Kafka之前还会保存在InFlightRequests中。InFlightRequests中对象形式是Map&lt;NodeId,Deque<Request>&gt;就是<em><strong>缓存了已经发出去但没有收到响应的请求</strong></em>（NodeId是节点的id编号，String类型）；还提供了管理类的方法，可通过参数限制每个连接最多缓存的请求数</Request></p><h2 id="元数据更新"><a href="#元数据更新" class="headerlink" title="元数据更新"></a>元数据更新</h2><p>InFlightRequests可以获得leastLoadedNode，即所有Node节点中负载最小的（比如上图的node2）。选择该节点可以让它尽快发出，避免因网络阻塞等异常而影响整体的进度。</p><p>producer需要将消息追加到指定主题的某个分区所对应的leader副本之前，要知道主题的分区数量，再计算出目标分区，之后producer需要leader副本所在broker节点的地址、端口等信息才能建立连接，最终才能发送到Kafka。该过程中所需要的信息都是元数据信息。</p><p>元数据指Kafka集群的元数据，记录了集群中有哪些主题，主题有哪些分区，每个分区的leader副本、follow副本分配在哪个节点上，哪些副本在AR、ISR等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。元数据的更新操作是在客户端内部进行，对客户端的外部使用者不可见。需要更新时，先选leastLoadedNode，再向该Node发送请求获取具体的元数据信息（sender线程发起），请求同样会存入InFightRequests。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>as-if-serial和happens-before</title>
      <link href="/2022/08/31/as-if-serial%E5%92%8Chappens-before/"/>
      <url>/2022/08/31/as-if-serial%E5%92%8Chappens-before/</url>
      
        <content type="html"><![CDATA[<p>我们知道为了提高并行度，优化程序性能，编译器和处理器会对代码进行指令重排序。但为了不改变程序的执行结果，尽可能地提高程序执行的并行度，我们需要了解as-if-serial规则和happens-before规则。</p><h3 id="as-if-serial规则"><a href="#as-if-serial规则" class="headerlink" title="as-if-serial规则"></a>as-if-serial规则</h3><p>as-if-serial语义的意思指：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</strong> 编译器、runtime和处理器都必须遵守as-if-serial语义。<br>为了遵守as-if-serial语义，<strong>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。</strong> 但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYint a=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c=a+b;</span><br></pre></td></tr></table></figure><p>a和c之间存在数据依赖关系，同时b和c之间也存在数据依赖关系。因此在最终执行的指令序列中，c不能被重排序到A和B的前面（c排到a和b的前面，程序的结果将会被改变）。但a和b之间没有数据依赖关系，编译器和处理器可以重排序a和b之间的执行顺序。</p><h3 id="happens-before（先行发生）规则"><a href="#happens-before（先行发生）规则" class="headerlink" title="happens-before（先行发生）规则"></a>happens-before（先行发生）规则</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：</p><ol><li><strong>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong></li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。<strong>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM允许这种重排序。</strong></li></ol><h4 id="八大规则"><a href="#八大规则" class="headerlink" title="八大规则"></a>八大规则</h4><table><thead><tr><th>规则</th><th>解释</th></tr></thead><tbody><tr><td>程序次序规则</td><td>在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td>管程锁定规则</td><td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td>volatile 变量规则</td><td>volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td>线程启动规则</td><td>Thread 对象的 start() 方法先行发生于此线程的每一个动作</td></tr><tr><td>线程终止规则</td><td>线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td></tr><tr><td>线程中断规则</td><td>对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生 (通过 Thread.interrupted() 方法检测)</td></tr><tr><td>对象终结规则</td><td>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td>传递性</td><td>如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="as-if-serial规则和happens-before规则的区别"><a href="#as-if-serial规则和happens-before规则的区别" class="headerlink" title="as-if-serial规则和happens-before规则的区别"></a>as-if-serial规则和happens-before规则的区别</h3><ol><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证<strong>正确同步的多线程</strong>程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻觉：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻觉：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka部分源码</title>
      <link href="/2022/08/27/Eureka%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/"/>
      <url>/2022/08/27/Eureka%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>底层通过Jersey框架在AWS背景下实现，用过滤器做服务的拦截。核心就是把<em><strong>过滤器注册进Tomcat</strong></em></p><p>多个模块都会向eureka发送服务注册的请求（会有注册信息），eureka底层会有一个注册表，当各个模块间进行通信的时候会定期拉取注册表的信息。模块要向另一个模块通信的时候会看是否有注册信息，有就通过信息得到对应的地址，就可以访问。</p><p>会维护心跳连接&#x2F;服务下架&#x2F;服务剔除&#x2F;服务续约。自我保护机制、集群通讯。</p><p>模块包括：定期拉取注册表信息、全量拉取、增量拉取 </p><h1 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在启动类点击@EnableEurekaServer注解</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;EurekaServerMarkerConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableEurekaServer &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由Import注解可知，使用了动态代理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerMarkerConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EurekaServerMarkerConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EurekaServerMarkerConfiguration.Marker <span class="title function_">eurekaServerMarkerBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EurekaServerMarkerConfiguration</span>.Marker();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Marker</span> &#123;</span><br><span class="line">        Marker() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虽然逻辑是空的，但是由于自动装配，它会往容器里面装配开发人员所写的配置文件的内容。作用在后面</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/Eureka%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81/factories.png"></p><p>Spring.factories</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration<span class="comment">//该类才是eureka核心</span></span><br></pre></td></tr></table></figure><h2 id="EurekaServerAutoConfiguration"><a href="#EurekaServerAutoConfiguration" class="headerlink" title="EurekaServerAutoConfiguration"></a>EurekaServerAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明配置类</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//动态注入bean到容器</span></span><br><span class="line"><span class="meta">@Import(&#123;EurekaServerInitializerConfiguration.class&#125;)</span></span><br><span class="line"><span class="comment">//条件注入，判断当前Spring容器是否会有Marker的bean。</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(&#123;Marker.class&#125;)</span></span><br><span class="line"><span class="comment">//所以，到目前为止，当在启动类中加入EnableEurekaServer注解后，会将Marker注入到Spring容器里面，然后在配置eureka时，发现了有Marker就会把EurekaServerAutoConfiguration注入</span></span><br><span class="line"><span class="comment">//相应的配置文件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;EurekaDashboardProperties.class, InstanceRegistryProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:/eureka/server.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">......</span><br><span class="line">     <span class="comment">//核心，把过滤器注册进Tomcat</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;?&gt; jerseyFilterRegistration(Application eurekaJerseyApp) &#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; bean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> <span class="title class_">ServletContainer</span>(eurekaJerseyApp));</span><br><span class="line">        bean.setOrder(<span class="number">2147483647</span>);</span><br><span class="line">        bean.setUrlPatterns(Collections.singletonList(<span class="string">&quot;/eureka/*&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所定义的过滤器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Application <span class="title function_">jerseyApplication</span><span class="params">(Environment environment, ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathScanningCandidateComponentProvider</span>(<span class="literal">false</span>, environment);</span><br><span class="line">        provider.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Path.class));</span><br><span class="line">        provider.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Provider.class));</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        String[] var5 = EUREKA_PACKAGES;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var5.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> var5[var7];</span><br><span class="line">            Set&lt;BeanDefinition&gt; beans = provider.findCandidateComponents(basePackage);</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var10</span> <span class="operator">=</span> beans.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var10.hasNext()) &#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> (BeanDefinition)var10.next();</span><br><span class="line">                Class&lt;?&gt; cls = ClassUtils.resolveClassName(bd.getBeanClassName(), resourceLoader.getClassLoader());</span><br><span class="line">                classes.add(cls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; propsAndFeatures = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        propsAndFeatures.put(<span class="string">&quot;com.sun.jersey.config.property.WebPageContentRegex&quot;</span>, <span class="string">&quot;/eureka/(fonts|images|css|js)/.*&quot;</span>);</span><br><span class="line">        <span class="type">DefaultResourceConfig</span> <span class="variable">rc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResourceConfig</span>(classes);</span><br><span class="line">        rc.setPropertiesAndFeatures(propsAndFeatures);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端启动时会发送服务注册的请求就会进入该方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationResource</span> &#123;</span><br><span class="line"><span class="meta">@POST</span></span><br><span class="line">    <span class="meta">@Consumes(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//info里面就是相关的注册信息</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">addInstance</span><span class="params">(InstanceInfo info, <span class="meta">@HeaderParam(&quot;x-netflix-discovery-replication&quot;)</span> String isReplication)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Registering instance &#123;&#125; (replication=&#123;&#125;)&quot;</span>, info.getId(), isReplication);</span><br><span class="line">        <span class="comment">//必要的信息一定不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isBlank(info.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">&quot;Missing instanceId&quot;</span>).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isBlank(info.getHostName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">&quot;Missing hostname&quot;</span>).build();</span><br><span class="line">        &#125; </span><br><span class="line">        ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其他信息的处理</span></span><br><span class="line">           ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.registry.register(info, <span class="string">&quot;true&quot;</span>.equals(isReplication));</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发布监听</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title class_">PeerAwareInstanceRegistryImpl</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="type">boolean</span> isReplication)</span> &#123;</span><br><span class="line">         <span class="comment">//监听事件。（自己指定事件，在类上添加@Compoent，在方法上@EventListener，方法参数就是事件类型）</span></span><br><span class="line">        <span class="built_in">this</span>.handleRegistration(info, <span class="built_in">this</span>.resolveInstanceLeaseDuration(info), isReplication);</span><br><span class="line">        <span class="built_in">super</span>.register(info, isReplication);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//集群间的信息共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeerAwareInstanceRegistryImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title class_">PeerAwareInstanceRegistry</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(InstanceInfo info, <span class="type">boolean</span> isReplication)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leaseDuration</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">                <span class="keyword">if</span> (info.getLeaseInfo() != <span class="literal">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//完成注册。通过读写锁</span></span><br><span class="line">                <span class="built_in">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">               <span class="comment">//往其他euraka服务器发送数据</span></span><br><span class="line">                <span class="built_in">this</span>.replicateToPeers(PeerAwareInstanceRegistryImpl.Action.Register, info.getAppName(), info.getId(), info, (InstanceStatus)<span class="literal">null</span>, isReplication);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h1><p>Eureka Server进入自我保护机制后，会出现以下情况：Eureka不再从注册列表中剔除因为长时间没收到心跳而过期的服务；Eureka Server依然可以接受新服务的注册和查询请求，但不会同步到其他节点；网络稳定时，当前实例新的注册信息会被同步到其他节点中。</p><p>自我保护机制是为了<em><strong>防止误杀服务</strong></em>。当个别客户端出现心跳失联，则认为是客户端的问题，剔除客户端；当Eureka捕获到大量的心跳失败，则认为可能是网络问题，进入自我保护；当客户端心跳恢复，Eureka会退出自我保护；</p><p>若在保护期内该服务提供者非正常下线，服务消费者会拿到无效的服务实例，就调用失败。</p><h1 id="对等复制架构"><a href="#对等复制架构" class="headerlink" title="对等复制架构"></a>对等复制架构</h1><p>Eureka本身依赖了Eureka Client，每个Server是作为其他Server 的Client。在单个Eureka Server启动，会有一个syncUP操作，通过Client请求其他Server节点中的一个节点获取注册应用实例信息，再复制到其他peer节点</p><p>EurekaServer采用Peer to peer的复制模式，重点解决数据复制的冲突问题：lastDirtyTimestamp标识和heartbeat。</p><p>针对数据不一致，一般通过比较版本号机制，最后在不同副本之间只需要判断请求复制数据的版本号与本地数据的版本号高地，eureka本身没有版本号属性，所以采用叫做lastDirtyTimestamp字段对比。peer节点之间的相互复制不能保证所有操作都能成功，所以eureka还通过应用实例与Server之间的heatbeat进行数据的最终修复，即发现应用实例数据与某个Server的数据出现不一致，则Server返回404，应用程序重新register。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC和AOP</title>
      <link href="/2022/08/22/IOC%E5%92%8CAOP/"/>
      <url>/2022/08/22/IOC%E5%92%8CAOP/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>一种设计思想，控制反转，将设计好的对象交给容器控制。在调用某个类时，容器会实例化，即容器控制对象的创建。实际就是个BeanDefinitionMap，里面放的就是各种对象</p><p>IOC容器实例化过程中，一般不包含bean的依赖注入，bean的注册和依赖注入是两个过程，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xml中配置，在容器初始化的时候，这个bean就完成了初始化。</p><p>Bean是工厂模式创建；数据是通过反射注入，目的是降低耦合度</p><p><a href="https://xiaoerbutingbu.github.io/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">结合Bean的生命周期</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>类比于：我自己找女朋友和我通过婚介公司找女朋友</p><p>控制反转，把我们写好的对象的控制权交给Spring框架，由框架来控制对象的生命周期（创建、销毁，这些对象之间的依赖关系），开发人员不用主动去new这些对象，IOC就是一个容器去创建这些对象，把所有的类都放到容器里面去登记，需要某个对象的时候告诉容器就行。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>  面向切面编程基于IOC。简单说就是将部分重复的代码抽取出来，需要执行的时候用动态代理价技术。不修改代码进行功能增强。<em><strong>解耦</strong></em></p><p>  降低了耦合度，提高了程序的可重用性，同时提高了开发效率</p><p>  底层使用动态代理</p><p>  实现业务和切入类的解耦</p><p>  与OOP相比，一个是横向一个纵向在</p><p>面向切面编程，使用了动态代理，两种实现方式：cglib和JDKProxy</p><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><p>系统由不同的组件组成，不同组件负责不同的功能，会存在很多组件与业务无关（日志、事务、权限等等），而写组件经常融入具体的业务逻辑，若每个具体业务逻辑都添加这些代码，就代码冗余，所以需要将公共的代码逻辑抽象出来变成一个切面，然后注入到具体的业务中。</p><p>所以AOP基于该思路，采用动态代理的方式，将需要注入切面的对象进行代理，在进行调用时候只将公共逻辑添加进去，而不需要修改原有的逻辑代码，只需要在原来的业务逻辑基础上做一些增强功能即可。</p><h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>在bean进行初始化后，beanPostProcessor中有一个AnnotationAwareAspectjAutoProxyCreator的去生成bean对应的代理对象，然后通过getAdvicesAndAdvisorsForBean获取切面信息并返回所有通知的方法；再就是解析切面，通过beanName创建每个对应的Class，再通过遍历含有@Aspect注解类的每个方法，拿到含有@Before等标签的方法，方法即通知，为每个通知创建一个advisor对象并以List形式返回。再筛选作用域当前bean上的增强器；再通过ProxyFactory创建代理对象，返回的是AopProxy接口（cglib和JDK两个实现类）。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用模型</title>
      <link href="/2022/08/19/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2022/08/19/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>程通过告诉多路复用器（内核）所有的socket号，多路复用器再去获取每一个socket的状态，当程序获取到某个socket号有事件发生了，则去该socket号上进行处理对应的事件，read事件或者是recived事件。</p><p>一个线程监测多个IO操作</p><h1 id="Select模型"><a href="#Select模型" class="headerlink" title="Select模型"></a>Select模型</h1><p>属于linux下的标准函数。时间O(N)。</p><p>仅仅知道有几个I&#x2F;O事件发生，但不知道具体是哪几个socket连接有I&#x2F;O事件，还需要轮询去找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="comment">//需要监听和扫描最大fd个数</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> maxfd,</span></span><br><span class="line"><span class="params">    <span class="comment">//本身是fdset集合，文件描述符。分别为 读事件列表、写事件列表、异常事件列表</span></span></span><br><span class="line"><span class="params">    fd_set *readset,</span></span><br><span class="line"><span class="params">    fd_set *writeset,</span></span><br><span class="line"><span class="params">    fd_set *exceptset,</span></span><br><span class="line"><span class="params">    <span class="comment">//监听时间，超时返回0，错误返回1，正常有数据可读的话就返回fd的个数</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>   从用户空间拷贝fd_set到内核空间；再遍历所有fd文件，并将当前进程挂到每个fd的等待队列中，并将当前进程挂到每个fd的等待队列中，当某个fd文件收到消息后，会唤醒等待队列上睡眠的进程，那么当前进程就会被唤醒；若遍历完fd都没有I&#x2F;O事件，当前进程会睡眠直到某个fd文件有I&#x2F;O事件或睡眠超时</p><p>​    缺陷：&#x3D;&#x3D;对socket进行线性扫描（轮询）IO&#x3D;&#x3D;，效率低，程序不知道哪些socket收到数据，需要每次全部遍历，浪费CPU；限定大小，因为保存文件描述符的bitmaps32位是1024，64位2048；内核态与用户态频繁复制fd数据开销大；每次调用都要把fd从用户态拷贝到内核态；</p><p>交互流程：用户态监听socket，再调用select（然后用户态就开始线程阻塞），内核态执行准备数据，准备完毕后告诉用户态select可读，用户态就read请求，内核态数据拷贝到用户态，用户态read完成。就完成一个交互流程</p><h1 id="poll模型"><a href="#poll模型" class="headerlink" title="poll模型"></a>poll模型</h1><p>本质与select无区别；将用户给的数组拷贝进内核，查询每个fd对应设备的状态。时间O(N)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> pollfd *fds, <span class="comment">//需要监听的文件描述符列表</span></span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> nfds,<span class="comment">//文件描述符个数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout  <span class="comment">//超时时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;      <span class="comment">//需要监视的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;<span class="comment">//内核扫描的事件集合</span></span><br><span class="line">    <span class="type">short</span> revents;<span class="comment">//events扫描完派生出需要返回给用户态的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于select突破了1024的限制（因为采用了pollfd数据结构，是一个链表）；</p><p>标志准备就绪的，用户态只关心revents，内核态也不用重置原数据</p><p>若遍历fd都没有就绪设备就挂起当前线程，直到设备就绪或主动超时，被唤醒后再次遍历fd</p><p>​             没有最大连接次数（因为恢复revents）；大量fd数组复制进内核（有些无意义）；若报告的fd没处理，那下次poll会再次报告fd</p><p>​           有超时时间，5个FD拷贝到内核态并监听数据</p><p>​           有数据时内核会对revents字段置位，poll返回，遍历找置位读数据</p><h1 id="Epoll模型"><a href="#Epoll模型" class="headerlink" title="Epoll模型"></a>Epoll模型</h1><p>可水平触发（LT）和边缘触发（ET），默认是LT；<em><strong>不是轮询，是回调机制</strong></em>。O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内核态创建epoll实例。底层是红黑树和就绪链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//对红黑树操作，添加所有socket节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> op,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//线程阻塞，内核查找红黑树中ready的socket，放入就绪列表，就绪列表中内置内存到events</span></span><br><span class="line"><span class="comment">//算是事件通知，只把准备好的事件告诉用户态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events,</span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有最大并发连接的限制；效率提升；内存拷贝</p><p>​             连接数较多且很多的不活跃连接时，epoll效率更好；反之，epoll因需要回调，所以性能此时会低</p><p>每个文件描述符上都有一个callback函数，当socket有事件时会回调这个函数将该fd的引用放到列表中，且会指出哪些文件描述符就绪。所以，可以直接处理</p><p>LT（阻塞和非阻塞皆可）：当文件描述符上的事件就绪后，若事务没有处理完或没有处理，那epoll会在下次提醒应用程序。就是内核会持续通知文件描述符已经就绪，我就可以对就绪的FD执行I&#x2F;O操作。</p><p>ET（仅阻塞）：当文件描述符上的事件就绪后，若事务没有处理完或没有处理，下一次epoll就不会提醒应用程序</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis核心类</title>
      <link href="/2022/08/17/Mybatis%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
      <url>/2022/08/17/Mybatis%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h1><p>是利用XML或Java编码编码获得资源来构建SqlSessionFactory（可以构建多个），一旦构建完，作用就没了，就可以回收。它的生命周期只存在与方法的局部，<em><strong>作用就是生产SqlSessionFactory</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;</span><br><span class="line">    <span class="comment">//各种构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqlSessionFactoryBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, (String)<span class="literal">null</span>, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, environment, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((Reader)reader, (String)<span class="literal">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得XMLConfigBuilder，new出一个成员变量configuration</span></span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">            var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, (String)<span class="literal">null</span>, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, environment, (Properties)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.build((InputStream)inputStream, (String)<span class="literal">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">            var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h1><p>每个基于MyBatis的应用都是一个SqlSessionFactory的实例为中心的，该实例通过SqlSessionFactoryBuilder获得。而Builder可以从XML配置文件或通过java的方式构建SqlSessionFactory实例。</p><p><em><strong>作用就是去创建SqlSession</strong></em>。每次应用需要访问数据库，就要通过SqlSessionFactory创建SqlSession。若多次创建同一个数据库的SqlSessionFactory，则每次创建的都会打开更多数据库连接资源，所以连接资源会被消耗。所以<em><strong>SqlSessionFactory是唯一的</strong></em>，于是采用单例模式，若采用多例就对数据库连接消耗大且不利于管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSessionFactory</span> &#123;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">()</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(Connection var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, <span class="type">boolean</span> var2)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, TransactionIsolationLevel var2)</span>;</span><br><span class="line">    SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType var1, Connection var2)</span>;</span><br><span class="line">    Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个工厂，创建SqlSession对象，SqlSession是MyBatis面向数据库的高级接口，提供了执行查询sql、更新sql等</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>首先需要提供配置文件和相关的参数。采用<em><strong>构造模式</strong></em>去创建SqlSessionFactory，通过SqlSessionFactoryBuilder构建</p><p>分两步：</p><p>​解析XML文件，读出配置参数，将读取的数据存入Configuration（MyBatis基本所有的配置都是在这）</p><p>​使用Configurattion对象去创建SqlSessionFactory。因SqlSessionFactory本身是一个接口，一般情况使用其实现类之中的DefaultSqlSessionFactory。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>作用：读入配置文件，包括基础配置XML文件和映射器XML文件；初始化基础配置（别名啊、类的对象啊）；提供单例，为后续创建SessionFactory服务并提供配置的参数；执行一些重要的对象的方法，初始化配置信息；</p><p>configuration做的初始化信息：全局参数、设置、别名、插件、类型处理器等等</p><h1 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h1><p>MyBatis的顶层API接口，作为会话访问，完成CRUD，有两个实现类，通过内部存放的执行器来对数据进行CRUD操作，<em><strong>非线程安全</strong></em>，所以每次都要close关闭。</p><p>一个会话，相当于JDBC的一个Connection对象，长期的存在会让数据库连接池的活动资源减少</p><h2 id="四大对象"><a href="#四大对象" class="headerlink" title="四大对象"></a>四大对象</h2><p>映射器就是一个动态代理对象，进入到MapperMethod的executte方法。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>真正执行Java和数据库交互的东西。</p><p>有三种：</p><p>​SIMPLE：简易执行器，默认的</p><p>​REUSE：执行器重用预处理语句</p><p>​BATCH：执行器重用语句和批量更新，针对批量专用的执行器</p><p>三种都提供了查询和更新方法，以及相关的事务方法</p><h3 id="数据库会话器"><a href="#数据库会话器" class="headerlink" title="数据库会话器"></a>数据库会话器</h3><p>专门处理数据库会话的。</p><p>定义了一个对象的适配器delegate，根据配置来适配对应的StatementHandler对象。作用就是给实现类对象的使用提供一个同一、简易的使用适配器。可以使用现有的类和方法对外提供服务、可以根据实际的需求对外屏蔽一些方法甚至加入新服务。</p><h3 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h3><p>参数处理器对预编译语句进行参数设置</p><h3 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h3><p>组装结果集的返回。</p><p>MyBatis提供了DefaultResultSetHandler类，默认状况都是这个类进行处理</p><h2 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h2><p>SqlSession是通过Executor创建StatementHandler运行，statement需要经过：</p><ul><li>prepared预编译SQL</li><li>parameterize设置参数：调用paremeterHandler方法设置，参数类型根据类型处理器typeHandler处理</li><li>query&#x2F;update执行SQL：通过resultHandler进行处理结果的封装，若是update就返回整数，反之通过typeHandler处理结果类型，再用ObjectFactory提供的规则组装对象，返回调用者</li></ul><h1 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h1><p>一个接口，没有任何实现类，作用就是发送SQL，在一个SqlSession事务方法之内，是一个方法级别的东西。如果JDBC的一条SQL语句执行。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2022/08/13/MAC/"/>
      <url>/2022/08/13/MAC/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>MAC（数据链路层）是实现 直连 两个设备之间通信</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>该层是负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报</p><p>该层是在物理层提供服务的基础上向网络层提供服务，最基本的就是将原子网络层的数据可靠的传输到相邻节点的目标机网络层。作用是<em><strong>加强物理层传输原始比特流的功能</strong></em>，将物理层提供的可能出错的物理连续改造为***逻辑上无差错的数据</p><p>使用的信道有两种：点对点信道和广播信道</p><h1 id="三大特定"><a href="#三大特定" class="headerlink" title="三大特定"></a>三大特定</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>帧：链路层的协议数据单元，封装网络层数据报。<em><strong>只有数据链路层才能识别帧，物理层只是传输比特流</strong></em></p><p>因为物理层只是负责传输，无法控制和判断是否出错，且在传输过程中容易受到环境干扰，进行产生错误。于是数据链路层需要负责<em><strong>差错检测</strong></em>的工作</p><h3 id="帧的结构"><a href="#帧的结构" class="headerlink" title="帧的结构"></a>帧的结构</h3><p>网络层将IP数据报传送到数据链路层作为帧的数据部分，数据链表路层分别在前后增加了一个标记（SOH和EOT），作为数据开始和结束。帧在物理层就是一串01比特流。<em><strong>帧首部和尾部是特定的控制字符</strong></em></p><p>​||帧首部||帧数据部分||帧尾部||</p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>无论什么样的比特组合的数据能通过数据链路层。数据看不见链路层有什么阻碍数据传输的东西，所以对这些数据来说就是透明的。</p><p>解决：发送端的数据链路层在数据中出现控制字符（EOT或SOH）的前面插入一个转义字符（ESC）。字节填充或字符填充</p><p>方法有比特填充法和字符填充</p><p>&#x3D;&#x3D;帧采用零比特填充&#x3D;&#x3D;：发送端发现有连续的5个1，就填入1个0；接收端发现有5个连续的1就删除其后的0。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>在传输过程中可能出现比特差错：1和0可能变化。为了保证数据传输的可靠性，在计网传输数据时，必须采用各种差错检测措施。</p><p>奇偶校验码和循环冗余检验码CRC。</p><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><img src="/2022/08/13/MAC/data.png"></p><p>根据IP地址寻找MAC地址</p><p>源MAC地址就是发送数据的计算机的MAC地址，很轻易获取</p><h2 id="公理"><a href="#公理" class="headerlink" title="公理"></a>公理</h2><p>每一个计算机或路由器都有一个<em><strong>ARP高速缓存表</strong></em>，也就是IP地址与MAC地址的映射表</p><p>ARP高速缓存表中只会存储<em><strong>当前局域网</strong></em>内的设备信息，包括不限于连接此局域网接口所对应的<em><strong>IP与MAC映射信息</strong></em></p><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p>首先计算机判断目的IP地址是否是同网段的IP</p><h3 id="源主机和目标主机在同一局域网"><a href="#源主机和目标主机在同一局域网" class="headerlink" title="源主机和目标主机在同一局域网"></a>源主机和目标主机在同一局域网</h3><p>计算机在ARP地址表中查询目的IP地址</p><p>若ARP地址表能查到，就会获取IP地址对应的MAC地址，将信息发送到这个MAC地址对应的计算机中。</p><p>若ARP地址表查不到，就以<em><strong>单播</strong></em>的方式，将自己的IP地址和MAC地址根据请求中的源IP地址响应给计算机；计算机将接收到到IP地址和MAC地址添加到自己的ARP地址表中，再根据MAC地址将数据发送给对方</p><h4 id="源主机和目标主机在不同局域网"><a href="#源主机和目标主机在不同局域网" class="headerlink" title="源主机和目标主机在不同局域网"></a>源主机和目标主机在不同局域网</h4><p>计算机通过路由器与局域网的连接口，先将数据发送给路由器（路由器的每个接口都有对应的IP地址和MAC地址），路由器通过算法选择最优路线将信息发给<em><strong>目标主机所在局域网的路由器上</strong></em></p><p>目标主机的路由器收到信息后，先检查自己的ARP地址表：若有目标IP地址，就直接发；若没有，在局域网内&#x3D;&#x3D;广播&#x3D;&#x3D;，目标主机收到广播后会返回自己的IP和MAC地址，路由器将收到IP地址和MAC地址并存储到自己的ARP地址表中，然后发主机过去</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2022/08/13/MAC/liucheng.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构</title>
      <link href="/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>最基本的，动态可修改字符串，二进制安全，存数字时底层是int编码；长字符串（长度&gt;39字节）raw编码；短字符串（长度&lt;39字节）embstr编码。长度不能超过512MB。整体类似于ArrayList</p><p>​存储double类型的浮点数是先转换为字符串再存储。raw和embstr编码效果相同，不同于内存分配释放，raw一次，embstr两次；embstr内存快连续，能更好的利用缓存带来的优势；</p><p>利用key的生命周期做投票系统；String特点数据刷新；利用数值操作特征为分布式数据库自增。访问次数、点赞、转发量；计数器、限流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line">struct sdshdr&#123;</span><br><span class="line">    <span class="comment">//记录SDS所保存的字符串长度</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组未使用的空间数量</span></span><br><span class="line"><span class="type">int</span> free;</span><br><span class="line">    <span class="comment">//字符串数组，保存字符串</span></span><br><span class="line"><span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//综上：常数获取字符串长度；避免缓冲区移除；减少重分配次数：内存不足时，会触发自动扩容；SDS API会以处理二进制的方式处理存放的buf数组里的数据，程序不会对其中做任何限制、过滤、假设，二进制安全；</span></span><br></pre></td></tr></table></figure><p>del key,get key,set key value</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>简单的字符串列表，<em><strong>底层是linkedlist和ziplist</strong></em>（元素数量&lt;512，所有对象元素长度小于64字节就使用ziplist反之就linkedlist）。</p><p>​ziplist：将所有元素紧挨着一起存储，分配的是一块连续的内存</p><p>​linkedlist:会有前驱后驱指针</p><p>可用于消息队列；顺序特性实现朋友圈点赞；顺序特性进行分布式日志顺序性展示；发布和订阅；慢查询</p><p>  Lpush,lpop,rpop,rush,</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>是一个键值对集合，是一个String类型的key和value的映射表。相当于hashmap。存放对象类型的数据，可避免键名冲突。 用户的购物车；hash作为商品秒杀技术对象完成商品秒杀系统</p><p>底层：ziplist（元素数量&lt;512个，所有值&lt;64字节）和hashtable</p><p>redis为了提高性能，不能阻塞服务，采用了渐进式策略</p><p>hset,hgetall,hlen,hget</p><p>用来缓存作为用户信息</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>String类型的无序集合，底层哈希表和intset（所有元素是整数，元素数量小于512）</p><p>​intset：有序不重复的连续空间；</p><p>sadd key element[ ]</p><p>比如标签；黑白名单；获取所有业务的权限、用户标签</p><h1 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h1><p>组成：ziplist（元素数量小于128，所有元素长度&lt;64）和跳跃表+哈希结合，value保证唯一性，又可为每个value代表权重的值。</p><p>跳表：每一层都是一个有序链表，默认升序。跳表中有表头节点和表尾节点。zskiplistNode中包含层、后退指针、分值、成员对象。底层拥有所有元素，插入元素的时候会随机生成一个“层次数字”，然后元素插入达到这个层次的所有底层，直到原始链表层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;<span class="comment">//跳表，目的就是为了高效支持范围查找</span></span><br><span class="line">&#125; zset;</span><br><span class="line"><span class="comment">//跳表节点</span></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    <span class="comment">//保存数据</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//权重</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    level数组</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        <span class="comment">//前向指针</span></span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        <span class="comment">//跨度，记录跨越了level0上的几个结点</span></span><br><span class="line">        unsigned <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"><span class="comment">//跳表</span></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">   <span class="comment">//跳表的头结点和尾结点 </span></span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">   <span class="comment">//最大长度 </span></span><br><span class="line">    unsigned <span class="type">long</span> length;</span><br><span class="line">   <span class="comment">//最大层数 </span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳表会从头节点的最高层开始查找下一个节点，因为节点中有元素和权值，所以两者都要比较</span></span><br><span class="line"><span class="comment">//若当前定位的元素权值更小，就访问该层下一个节点</span></span><br><span class="line"><span class="comment">//若当前定位的元素权值与需要查询的权值相同，就比较元素值，若定位的元素值数据更小，还是访问该层下一个节点</span></span><br><span class="line"><span class="comment">//以上两个条件都不满足就会访问level数组的下一层指针，沿着下一层指针找</span></span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">           ...</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>跳表在创建节点的时候，采用了随机生成节点层数的方法。&lt;&#x3D;25%</p><p>排行榜系统；带权重任务队列；根据权重进行排序</p><p>zadd  key score member[]</p><p>搜索路径如图：要检索19</p><p><img src="/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/19.png"></p><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>Bitmaps:String类型上的一组面向bit操作的集合，不是真的数据结构，优点就是存储信息可节省大量空间。一般用于实时分析，存储对象ID关联的节省空间且高性能的布尔信息。底层是String</p><p>HyperLogLogs：用于计算唯一事物的概率数据结构。可用于计算用户每天在搜索框中执行唯一的搜索。底层是String</p><p>  GEO：存储用户给定的地理位置信息，并对这些信息操作。底层是zset</p><p>  Streams：内存版的kafka</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础题1</title>
      <link href="/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/"/>
      <url>/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h1 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h1><p>Java9之后就是通过byte[] value 实现</p><p><img src="/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/String.png"></p><h1 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h1><p>主要用在 变量、方法、类</p><p>修饰类对象的时候，属性值还是可以变化。</p><p>使用原因：把方法锁定，防止任何类修改它的含义；提升效率性能；多线程下保持了线程安全。</p><p>修饰基本类型值不变，<em><strong>修饰引用类型只是引用不可变，但是引用所指向的地址的内容可以改变</strong></em></p><p><strong>只被final修饰但是没给初始值的情况下的基本数据类型是可以通过反射改变值</strong></p><p>final修饰的属性的初始化可以在编译器、运行期，初始化后不能被改变</p><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><p>当变量被static final修饰时，该变量的值是不能被改变且必须给初始值；</p><p>只被final修饰的变量在定义时没给初始值是能通过反射改变代码运行期间所赋予的值，而在定义时就给了初始值的通过反射也不能改变值</p><h1 id="为什么重写equals要重写hashcode"><a href="#为什么重写equals要重写hashcode" class="headerlink" title="为什么重写equals要重写hashcode"></a>为什么重写equals要重写hashcode</h1><p><img src="/2022/08/09/%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E9%A2%981/hashcode.png"></p><p>首先hashCode是一个本地方法，不同虚拟机有不同实现，主要是为了给HashMap这样的哈希表的使用。</p><p>设计该方法的重要因素：对同一个对象调用该方法应该产生相同的值，所以需要快、不需要唯一性。</p><p>equals相等，hashcode一定相等：</p><p>equals不等，hashcode不一定不等：这是为了尽量减少哈希冲突，因为hashcode是int类型，有范围，难免冲突，此时hashmap通过拉链法解决冲突</p><p>hashcode不等，equals一定不等</p><p>hashcode相等，equals不一定相等</p><p>综上：</p><p>若重写equals，就一定要重写hashCode</p><p>提高效率：先进行hashcode比较，若不同就不用再比较，就提高了效率</p><h1 id="抽象类（JDK8）"><a href="#抽象类（JDK8）" class="headerlink" title="抽象类（JDK8）"></a>抽象类（JDK8）</h1><p>不一定要有抽象方法</p><p>不能用final修饰，因为final修饰了就不能被修改和继承了</p><h2 id="与接口的区别"><a href="#与接口的区别" class="headerlink" title="与接口的区别"></a>与接口的区别</h2><ul><li>抽象类可以提供成员方法的实现细节，而接口只能包含抽象方法、普通方法。</li><li>抽象类的成员变量可以是各种类型，接口中的成员变量只能是public static final</li><li>抽象类可有静态代码和静态静态方法，接口不能含有静态代码块和静态方法</li><li>抽象类可有构造器，接口不能有有构造器</li><li>一个子类只存在一个父类，一个子类可以存在多个接口</li></ul><h2 id="与普通类"><a href="#与普通类" class="headerlink" title="与普通类"></a>与普通类</h2><p>普通类：不能含有抽象方法，可以直接实例化</p><p>抽象类：可以有抽象方法，不能直接实例化</p><h1 id="x3D-x3D-和equals"><a href="#x3D-x3D-和equals" class="headerlink" title="&#x3D;&#x3D;和equals"></a>&#x3D;&#x3D;和equals</h1><table><thead><tr><th align="center">&#x3D;&#x3D;</th><th align="center">Equals</th></tr></thead><tbody><tr><td align="center">运算符</td><td align="center">方法</td></tr><tr><td align="center">若比较基本类型，则比较数值（即使数据类型不同，比如 int  i&#x3D;1,double k &#x3D;1.0）；若是引用数据类型，则比较内存地址值</td><td align="center">比较方法的两个对象内容是否相等  不能比较基本数据类型的变量；  若没有重写（也是默认情况），则比较的是引用数据类型的变量所指向的对象的地址</td></tr><tr><td align="center">比较浮点型数据时导致数据精度丢失</td><td align="center"></td></tr></tbody></table><h1 id="解决Hash冲突"><a href="#解决Hash冲突" class="headerlink" title="解决Hash冲突"></a>解决Hash冲突</h1><p>开放地址法：一旦发生了冲突，就寻找下一个空的散列地址。 H<del>i</del>&#x3D; (H(key) + d<del>i</del>)%m;  m为哈希表长，d<del>i</del>为增量序列</p><p>再哈希算法：一直调用哈希函数，计算地址，直到没有冲突。不易发生聚集，但增加了计算时间</p><p>链地址（HashMap所用）：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接。</p><p>建立公共溢出区：将哈希表分为基本表和溢出表两个部分，凡是和基本表发生冲突的元素都填入溢出表</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集系统</title>
      <link href="/2022/08/04/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/08/04/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>运行过程中，会产生大量内存垃圾，为确保程序运行时的性能，虚拟机在程序执行过程中药不断进行自动的垃圾回收</p><p> 收集 三个内存区域</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>历史最悠久的，单线程工作，垃圾收集时会暂停其他所有工程线程，直到收集结束（用户不可知）</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial收集器的多线程并发版本</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>一款以<em><strong>最短回收停顿时间为目标</strong></em>的收集器。</p><p>基于标记-清除算法实现。四个步骤：初始标记、并发标记、重新标记、并发清除</p><p>优点：并发收集、低停顿</p><p>缺点：对处理器资源敏感、无法处理“浮动垃圾”、大量空间碎片</p><h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>低延迟的，<em><strong>染色指针技术</strong></em>：将少量额外的信息存储在指针上的技术。</p><p>步骤：并发标记、并发预备重分配、并发重分配、并发重映射</p><h1 id="判断是否可以回收"><a href="#判断是否可以回收" class="headerlink" title="判断是否可以回收"></a>判断是否可以回收</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p> 引用计数法：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。原理简单，效率也很高。已被淘汰，它不能解决循环引用。</p><p>  可达性分析算法：从GC Roots作为根对象开始向下搜索，搜索所走过的路径被称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收</p><p>可作为GC roots：栈帧中的本地变量表中引用的对象（比如：堆栈中用到的参数、局部变量、临时变量）；方法区中静态属性引用的对象（java类的引用类型静态变量）；方法区中常量引用的对象（字符串常量池的引用）；本地方法栈中native方法引用的对象；所有同步锁（synchronized）持有的对象</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>当经过可达性分析算法判定为可以删除后，就只是对其进行一次标记，之后还要筛选，看该对象是否有必要执行finalize方法，如果没有覆盖finalize方法或者已经被虚拟机调用那就视为“没有必要执行”。</p><p>如果该对象判定为有必要执行方法，那该对象就被放置一个名为F-Queue的队列之中，之后在由虚拟机自动建立的、低调度优先级的Finalizer线程执行finalize方法（但虚拟机不一定会等待它运行结束），稍后收集器对F-Queue中的对象进行第二次标记，第二次标记成功就代表要被回收了。</p><p>如果对象要从F-Queue中逃脱，就要重新与引用链上的任一对象关联。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记无用对象，然后进行清除回收。效率不高，无法清理出垃圾碎片；执行效率不稳定。因为标记和清除的效率随着需清理对象的增长而降低</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>按容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，再把已使用的内存空间一次清理。适合对象较少的时候，即使用年轻代；会产生大量的内存间复制的开销</p><p>但对于多数对象要回收的情况，需要复制的对象就较少，也不用考虑空间碎片，只要移动堆顶的指针，按顺序分配即可。但因为内存对半分开，空间浪费</p><h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><p>标记无用对象，让所有存活的对象向一端移动，然后直接清除掉边界外的内存</p><p>分代收集算法：根据对象存活周期的不同将内存划分几块，一般是新生代（复制算法清除）和老年代（标记整理算法清除）</p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>Minor GC(Young GC):只是新生代的垃圾收集</p><p>​年轻代空间不足时，就触发，即Eden代满了，survivor满不会引发gc</p><p>​非常频繁，回收速度也快</p><p>Major GC(old gc)：只是老年代的垃圾收集，执行速度比Minor GC慢10倍以上</p><p>​只有CMS GC会有单独收集老年代的行为</p><p>Mixed GC：收集整个新生代以及部分老年代的垃圾收集</p><p>Full gc：回收这个堆和方法区的垃圾收集</p><h1 id="频繁发生Full-GC"><a href="#频繁发生Full-GC" class="headerlink" title="频繁发生Full GC"></a>频繁发生Full GC</h1><p>发生在system.gc()调用，老年代空间不足，永生区空间不足，堆分配了大对象</p><p>注意两种数据结构：linkedBlockingQueue：当数据量很大，就会无限放数据，就导致full gc；所以要使用有参构造函数并合理设置节点数量</p><p>线程池：消息量大造成内存消耗过快，是因为队列无限存放数据</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/2022/08/01/LinkedList/"/>
      <url>/2022/08/01/LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>基于双向链表实现，可作为双向队列，随机访问集合元素较能较差，因为需要在双向链表中招待index位置再返回。底层是Node数据结构，有两个指针first和last分贝指向头和尾。</p><p>更适合删除添加</p><p>但查询最链表的第一个和最后一个元素也很快，不用遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">876323262645176354L</span>;</span><br><span class="line">    <span class="comment">// LinkedList的大小，其实就是其内部维护的双向链表存储元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 头结点，指向第一个节点的指针或引用，默认为 null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">// 尾节点，指向最后一个节点的指针或引用，默认为 null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 因为LinkedList是双向链表，所以node需要前驱和后驱指针</span></span><br><span class="line"><span class="comment">    * 一定要是static的：若不用static修饰，那node就是一个普通的内部类，java中一个普通的内部类在实例化后，默认会有外部类的引用，所以就有可能会内存泄露</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">            <span class="comment">// 存储的元素</span></span><br><span class="line">            E item;</span><br><span class="line">            <span class="comment">// 指向下一个节点</span></span><br><span class="line">            Node&lt;E&gt; next;</span><br><span class="line">            <span class="comment">// 指向上一个节点</span></span><br><span class="line">            Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">                <span class="built_in">this</span>.item = element;</span><br><span class="line">                <span class="built_in">this</span>.next = next;</span><br><span class="line">                <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造函数</span></span><br><span class="line"><span class="comment">     * 构造包含指定元素的列表集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 如果 c 为 null，则会抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">// 指向无参的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素添加到指定的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引角标不合法，则抛出索引越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 index 是否合法，不合法则抛出索引越界异常</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 判断要添加的是否是最后一个索引位置</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素 e 添加到链表最后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果当前链表还没有元素，则将当前元素赋值为 first</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 用来记录 LinkedList 结构性变化的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素 e 插入到指定的 index 索引位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取原本 index 索引位置的元素的前节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 用来记录 LinkedList 结构性变化的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素索引处的(非空)节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 它对 index 与集合长度的一半做比较，来确定是在集合的前半段还是后半段进行查找，</span></span><br><span class="line">    <span class="comment">// 从而达到节省一半的时间。</span></span><br><span class="line">    <span class="comment">// size&gt;&gt;1 相当于 size/2，这里的意思就是判断 index 的位置在前半段还是后半段</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS-ReentrantLock</title>
      <link href="/2022/07/29/AQS-ReentrantLock/"/>
      <url>/2022/07/29/AQS-ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>用来构建锁和同步器的框架，AQS能简单且高效的构造出应用广泛的大量的同步器</p><p>是JDK提供的一个同步框架，内部维护着FIFO双向队列，即CLH同步队列</p><p><img src="/2022/07/29/AQS-ReentrantLock/FIFO.png"></p><p>AQS依赖它来完成同步状态管理（Volaile修饰的static，用于标志是否持有锁）。如果获取<em><strong>同步状态state</strong></em>失败时，会将当前线程及等待信息封装成一个Node，将Node放到FIFO队列里，同步阻塞当前线程，当线程将同步状态state释放时，会把FIFO队列中的首节唤醒，</p><p>队列中的头部有一个为空的线程，占位的，称呼为傀儡节点或哨兵节点。一开始没有，往队列中插入第一次线程（Node）时插入</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>CountDownLatch(计时器)：允许count个线程阻塞在一个地方，直至所有线程的任务都执行完</p><p>Semaphore(信号量)、CyclicBarrier（循环栅栏）、ReentrantLock、ReetrantReadWriteLock（读写锁）</p><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>抢到资源的线程直接使用处理业务逻辑，若请求的共享资源被占用即没抢到资源，那就需要一套线程阻塞等待以及被唤醒时锁分配的机制（AQS是用CLH队列锁实现），将暂时获取不到的锁的线程加入队列。队列就是AQS的抽象表现。将请求共享资源的线程封装成队列的结点node，通过CAS、自旋以及LockSupport.park()维护state变量的状态，使并发达到同步效果</p><p><img src="/2022/07/29/AQS-ReentrantLock/zhuangtai.png"></p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>里面会有一个volatile修饰的int同步状态变量state，通过CAS去修改这个变量值，若修改成功，线程就会表示获取到了锁，没有成功或state已经是一个加锁的状态了，就通过一个waiter这个对象封装线程添加到FIFO等待队列里面，再把它挂起等待被唤醒。</p><h1 id="AQS部分源码"><a href="#AQS部分源码" class="headerlink" title="AQS部分源码"></a>AQS部分源码</h1><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractQueuedSynchronizer</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//同步器指向队列的头节点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">//同步器指向队列的尾巴节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">//当前锁的状态</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock部分源码"><a href="#ReentrantLock部分源码" class="headerlink" title="ReentrantLock部分源码"></a>ReentrantLock部分源码</h1><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node队列"><a href="#Node队列" class="headerlink" title="Node队列"></a>Node队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//指示节点在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">//指示节点以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//各种状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//node处于上述状态的标志位</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">//前驱、后驱指针</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//封装到node的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//连接到等待条件的下一个节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，默认创造非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// true和false创造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//看state是否是0，即判断是否有人占用</span></span><br><span class="line">            <span class="comment">//若没有人占用锁，就让当前线程持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//非公平锁相比与公平锁相比，少了一个判断!hasQueuePredecessors()</span></span><br><span class="line"><span class="comment">//后面没有抢到锁的线程   此时的arg=1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">//将该节点放入队列</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//模板方法设计模式，必须有这个实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用非公平锁的尝试获取</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">     <span class="comment">//获取state状态变量</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">     <span class="comment">//=0,锁就没有线程获取</span></span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//该线程是否抢到了锁</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//把当前线程放入持有者</span></span><br><span class="line">             setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//当前线程是否是持有锁的线程.可重入锁</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//enq：准备进入队列。让该线程的头结点就指向队列中的最后一个线程（若队列没线程，就加一个傀儡节点），最后一个线程的next指针指向该线程，同步器的尾指针指向该线程。</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReentrantLock </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList部分解析</title>
      <link href="/2022/07/26/ArrayList/"/>
      <url>/2022/07/26/ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>基于数组实现容量大小动态变化，基于索引的数据结构，随机访问集合元素上有较好的性能，<em><strong>扩容机制是1.5倍</strong></em>。底层是Object数组实现，地址连续，动态扩容，允许包括null在内的任何元素插入；非线程安全，异步；</p><p>创建对象时，若用的无参构造器，初始elementData容量为0，第一次添加则扩容到10，再扩容就是1.5倍；构造器也可以指定大小</p><p>更适合随机查找，查询块，也可以根据下标查询</p><p>扩容有两个部分：确定最小容量的值，调用grow方法。Arrays.copyOf完成扩容</p><p>把传入集合转换为数组，再通过Arrays.copyOf()拷贝到elementData</p><p>add方法需要先确定是否要扩容再进行赋值操作</p><h1 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">//初始化的容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空数组（用于空实例）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认大小空实例的共享空数组实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//保存ArrayList数据的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">//所含有的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）      </span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="add"><a href="#add" class="headerlink" title="add"></a>add</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">// 扩容</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">       <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">       <span class="comment">//是否越界</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       <span class="comment">//保证此时的容量大小</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//arraycopy()实现数组之间复制的方法，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以最小容量进行扩容</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组. 若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间（newCapacity的连续空间）</span></span><br><span class="line">        <span class="comment">// 并将elementData的数据复制到新的内存空间</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比较 minCapacity 和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2022/07/24/CAS/"/>
      <url>/2022/07/24/CAS/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>比较并交换</p><p>  比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比直到主内存和工作内存中的值一致</p><p>  多个线程使用CAS操作一个变量，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试（自旋）或挂起</p><p>  <em><strong>是一条CPU并发原语，原子指令</strong></em>，不会造成数据不一致的问题</p><p>  乐观锁</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>先从地址V地区值A：2；根据A计算目标值B：3；通过CAS以原子的方式将地址V的值从A修改为B</p><p>1：调用unsafe类，分别专递主物理内存的值，原子类对象本身的值，当前对象内存地址的值，需要加上的值</p><p>2：拷贝主物理内存的值到当前线程内存</p><p>3：while循环，一直修改</p><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p>  Unsafe类：CAS的核心类，来自JVM的rt.jar下。因为java不能直接访问底层系统，需要本地（native）方法访问，基于该类可以直接操作特定内存的数据，类似于c语言的指针直接操作内存。Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务</p><p>  变量valueOffset，表示变量值在内存中的偏移地址</p><p>  变量value被volatile修饰，保证多线程之间的可见性</p><p> unsafe类：compareAndSwapObject(Object var1, long var2, Object var4, Object var5)</p><p>​第一个：要修改的对象</p><p>​第二个：对象中要修改变量的偏移量</p><p>​   第三个：修改之前的值</p><p>​   第四个：预想修改之后的值</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>循环时间开销很大：因为通常配合着循环使用，若失败则会一直尝试</p><p>只能保证一个共享变量的原子操作（多个共享变量，循环CAS就不能保证原子性，要用锁）</p><p><em><strong>引来ABA问题</strong></em></p><h2 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h2><p>线程1从内存位置V读取数据A，线程2也从地址V出读取A，线程2经过了一些操作将值别成了B，然后线程2又将V位置的数据变成A，此时，线程2进行CAS操作发现内存中仍然是A，进程1操作成功。但是整个过程中，地址V其实是已经被修改过的</p><p><em><strong>带有标记的原子引用类</strong></em>可以<em><strong>控制变量值的版本</strong></em>来保证CAS正确性。所以，解决ABA的话改用传统的互斥同步</p><p>原子类：某个线程进入方法，执行其中的指令时，不会被其他线程打断，别的线程一直等到该方法执行完成才由JVM从等待队列中选择一个另一个线程进入</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL简单优化</title>
      <link href="/2022/07/21/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/"/>
      <url>/2022/07/21/MySQL%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><p>对于所执行的SQL语句，通过“explain”查看相关信息进行调节</p><p>可以获取表的读取顺序，数据读取操作的操作类型，哪些索引可用，哪些索引实际被使用，表之间的引用，每张表有多少行被优化器查询</p><p>使用方法： EXPLCAIN + SQL语句</p><p>Id：id相同：执行顺序由上至下</p><p>​    Id不同：若是子查询，id的序号会递增，id的值越大优先级越高，越先执行</p><p>​    id不同，同时存在，可以认为从上往下顺序执行。</p><p>Select_type：</p><p>​    SIMPLE：简单的select查询，查询中不包含子查询或UNION</p><p>​    PRIMARY：若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</p><p>​    SUBQUERY：在select或where列表中包含子查询</p><p>​    DERIVEN：在from列表中包含的子查询被标记为DERIVER（衍生），mysql会递归执行这些子查询，把结果放在临时表中</p><p>​    UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在from子句的子查询中，外层select将被标记为：DERIVED</p><p>​    UNION RESULT：从UNION表获取结果的SELECT</p><p>Table：就是执行的表</p><p><em><strong>Type</strong></em>:显示查询使用了哪些类型</p><p>​    包含：ALL、index、range、ref、eq_ref、const&#x2F;system、NULL</p><p>从好到差：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</p><p>​    System:表里只有一行记录，const的特例</p><p>​    Const：通过索引，一次就找到，用于比较primary key或者union索引</p><p>​    Eq_ref：唯一索引扫描，对每个索引键，表中只有一条记录匹配。主键或唯一索引扫描</p><p>​    Ref：非唯一性索引扫描，返回某个单独值的所有行</p><p>​    Reange：值检索给定范围的行</p><p>​    Index：与all的区别是index只遍历索引树。通常比all块</p><p>​    All：将遍历全表以找到匹配的行</p><p>Possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定被查询实际使用</p><p>Key_len：表示索引中使用的字节数，通过该列计算查询中使用的索引长度</p><p>Ref：显示索引的那一列被使用了</p><p>row： 根据表统计信息及索引选用情况，大致估算出找到所需要读取的行数</p><p>Extra：包含不适合在其他列中显示但很重要的额外信息</p><h1 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h1><p>查询尽量不用select * ，而是具体字段：只取需要的，节省资源、减少开销；select * 时很可能不会用到索引，就会造成全表扫描 </p><p>​    避免在where子句中用or连接条件（用union all，或两条sql）：or可能让索引失效，而全局扫描；</p><p>​         Select * from student where id&#x3D;1 or salary&#x3D;3000</p><p>​         Select * from student where id&#x3D;1 union all select * from student where salary</p><p>​    Varchar代替char：因为是根据实际长度存储，存储空间小，节省空间；char按声明大小存储，不足补空格；在一个相对小的字段内搜索，效率更高</p><p>​    尽量使用数值代替字符串</p><p>​    查询时尽量避免返回大量数据：若返回的数据量大，就查询时间过长，网络传输时间过长。太多了也没意义，用户不好看。通常采用分页的形式</p><p>​    创建name字段的索引：提高查询速度的最简单最佳方式</p><p>​         Alter table student add index index_name(NAME)</p><p>​    优化like语句：like可能让索引失效</p><p>​    Where限定查询的数据</p><p>尽量避免全表的扫描，在where、order by等列上建立索引。在字句中尽量避免使用 !&#x3D; &gt; &lt; 等操作符，否则引擎会放弃使用索引去全表扫描了</p><p>尽量使用数字型的字段，不然会降低连接的性能，也会增加存储开销（因为引擎在处理查询和连接的时候会逐个去比较字符串中的每个字符），数字就只需要比较一次</p><h2 id="大表"><a href="#大表" class="headerlink" title="大表"></a>大表</h2><p>限定数据范围：比如将查看订单历史记录，控制在一定的时间范围</p><p>读写分离：数据库拆分，主库负责写，从库负责读</p><p>垂直分区：根据数据库里面数据表的相关性拆分。简单说，就是把一张列较多的表拆分成多个表</p><p>水平分区：将一片数据分散到不同表或者库中</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http1.0-3.0</title>
      <link href="/2022/07/17/Http1-0-3-0/"/>
      <url>/2022/07/17/Http1-0-3-0/</url>
      
        <content type="html"><![CDATA[<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="HTTP1-0和1-1"><a href="#HTTP1-0和1-1" class="headerlink" title="HTTP1.0和1.1"></a>HTTP1.0和1.1</h4><p>HTTP&#x2F;1.0性能上，每发起一个请求都要新建一次TCP连接（三次握手），而且是串行，做了没有用TCP连接和断开</p><p>长连接：HTTP&#x2F;1.1采取的，只要任意一端没有明确的提出断开连接，则保持TCP连接状态</p><p>错误状态响应码：1.1中新增加了24个错误状态响应码</p><p>缓存处理：1.1引用了更多缓存控制策略</p><p> 1.1的性能：<em><strong>长连接、管道网络传输、队头阻塞</strong></em></p><p>管道网络传输：在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不用等其回来，就可以发第二个请求出去</p><p>队头阻塞：顺序发送的请求序列中，一个请求因为某种原因被阻塞时，后面排队的所有请求都阻塞了</p><p><img src="/http1-0-3-0/1.0-1.1.png" alt="image-20220709114337819"></p><p>HTTP1.1的瓶颈：</p><p>最大的问题就是高延迟：因为延迟难以下降；并发连接优先；队头阻塞；HTTP头部巨大且重复；不支持服务器推送消息</p><ul><li>请求&#x2F;响应头部未经压缩就发送，首部信息越多，延迟越大。只能压缩body部分</li><li>发送冗长的首部。每次都发送相同的首部浪费较多</li><li>没有请求优先级</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h5 id="HTTP1-1-优化"><a href="#HTTP1-1-优化" class="headerlink" title="HTTP1.1 优化"></a>HTTP1.1 优化</h5><p>尽量避免HTTP请求（缓存技术）</p><p>在需要发HTTP请求，减少次数（减少重定向，合并请求，延迟发送）</p><p>​收到合并请求就是合并资源，以一个大资源的请求替换多个小资源的请求；当大资源中的小资源发生变化，客户端就要重新下载整个完整的大资源</p><p>​     延迟发送：只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源</p><p>减少服务器的HTTP响应大小</p><h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h4><p>通过<em><strong>静态表和哈夫曼编码</strong></em>的方式，将体积压缩了近一半，针对后续的请求头部也可建立动态表（会占用内存而影响并发能力）</p><p>  <em><strong>实现了Stream并发，多个Stream只需复用一个TCP连接，节约了TCP和TLS握手时间，以及减少了TCP慢启动阶段对流量的影响。</strong></em></p><p>  服务器支持主动推送资源，大大提升了消息的传输信息</p><p>  HTTP&#x2F;2是基于TCP协议来传输数据，TCP层必须保证收到的字节数据是完成且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用。有队头阻塞问题，TCP和TLS的握手时延迟，网络迁移需要重新连接</p><h5 id="相比于HTTP-x2F-1-1的改进"><a href="#相比于HTTP-x2F-1-1的改进" class="headerlink" title="相比于HTTP&#x2F;1.1的改进"></a>相比于HTTP&#x2F;1.1的改进</h5><p>&#x3D;&#x3D;头部压缩&#x3D;&#x3D;：会压缩头，若头一样，会消除重复的部分</p><p>&#x3D;&#x3D;二进制格式&#x3D;&#x3D;：全面采用二进制格式并同城为帧（头信息帧，数据帧）。对计算机友好，提高传输效率</p><p><img src="/http1-0-3-0/1.0-1.1-2.png" alt="image-20220709152032970"></p><p>&#x3D;&#x3D;数据流&#x3D;&#x3D;：数据包不是按顺序发送，每个请求或回应的所有数据包称为数据流。每个数据流里面有独一无二的编号，客户端发送的编号为奇数，服务器端发送的为偶数。多个stream复用一个TCP达到并发效果</p><p>&#x3D;&#x3D;多路复用&#x3D;&#x3D;：2.0是可以在一个连接中并发多个请求或回应，而不用按顺序对应</p><p>&#x3D;&#x3D;服务器推送&#x3D;&#x3D;：服务器也可以主动向客户端发</p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>因为多个HTTP都在复用一个TCP链接，所以一旦发生丢包，都会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求就必须这个丢的包被传回来</p><h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><p>传输层的TCP换成UDP，并在UDP协议开发了QUIC协议保证了数据的可靠传输。</p><p>QUIC</p><p>  无队头阻塞</p><p>  建立连接速度块</p><p>  连接迁移</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2022/07/16/IP/"/>
      <url>/2022/07/16/IP/</url>
      
        <content type="html"><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><p>网络层，<em><strong>实现主机与主机之间的通信，点对点通信</strong></em></p><p>MAC（数据链路层）是实现 直连 两个设备之间通信，IP是在没有直连的两个网络之间进行通信传输。个人理解：计划和实施的区别。IP是整个旅游行程表，MAC是行程表里的交通工具。</p><p>&#x3D;&#x3D;源IP地址和目标IP地址不会变化，只有源MAC地址和目标MAC一直在变化&#x3D;&#x3D;</p><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><p>IP地址（IPv4地址）32位，在计算机中二进制方式处理。点分十进制的标记方式处理</p><p>分类：A,B,C,D,E类</p><p>A（0<del>127.255.255.255）,B（128</del>191.255.255.255）,C（192~223）主要两部分，网络号和主机号（比如：A小区1栋101号和B小区1栋101号）</p><p>A,B,C类中有私有IP和公有IP区分</p><p>解析IP地址，看第一个0出现在哪一位。在第一位是A类，第二为是B类，依次类推</p><p>广播地址</p><p>用于在同一个链路中互相连接的主机之间发送的数据包</p><p>​    分为：本地广播（本网络内广播）和直接广播（不同网络间的广播）</p><p>D类和E类地址没有主机号，不可用于主机IP。</p><p>D类常用于多播，E类是预留的分类，暂未使用</p><p>多播地址</p><p>​    用于将包发送给特定组内的所有主机</p><h3 id="IPV4分类的优缺点"><a href="#IPV4分类的优缺点" class="headerlink" title="IPV4分类的优缺点"></a>IPV4分类的优缺点</h3><p>优点：简单明了、选路（基于网络地址）简单</p><p>缺点：同一网络下没有地址层次，就缺少地址的灵活性；不能很好与现实网路匹配</p><p>两个缺点都可在CIDR无分类地址解决：前面是网络号，后面是主机号</p><p>​    以a.b.c.d&#x2F;x形式表示，比如10.100.122.2&#x2F;24: &#x2F;24表示前24位是网络号，剩余是主机号。</p><h2 id="问点"><a href="#问点" class="headerlink" title="问点"></a>问点</h2><p>为什么要分离网络号和主机号：两台计算机要通讯，首先判断是否处于同一个广播域内，即网络地址是否相同。若相同，表名接收方在本网络上，数据包就可以发送到目标主机</p><p>怎么划分子网：子网掩码的作用之一就是划分子网，将主机地址分为 子网网络地址和子网主机地址</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>是128位，与v4比，可分配的地址变多；可自动装配；包头包首部长度固定的40字节，去掉包头检验和，简化了首部结构，减轻了路由器符合，提高传输的性能；可伪造IP地址的网络安全，防止窃听，提升了安全性</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>单播地址：一对一通信；</p><p>组播地址：一对多通信；</p><p>任播地址：通信最近的节点，最近的节点由路由协议决定</p><p>没有广播地址</p><h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS：可将域名网址自动转换成具体的IP地址。越靠右，层级越高</p><p>层级关系：根DNS服务器，顶级域DNS服务器，权威DNS服务器</p><p>解析流程：</p><p>客户端发送DNS请求，并发给本地DNS解析器；本地域名解析器收到请求后，若缓存中能找到就直接返回IP地址，反之本地DNS会去问它的根域名服务器；根DNS收到请求后，发现后置是.com，就给本地DNS关于顶级域名服务器的地址；本地DNS收到后再发请求给顶级域名服务器，顶级域名服务器就返回权威域名服务器的地址；本地收到后，发送权威域名服务器请求，权威域名查询后将IP地址告诉给本地DNS。本地DNS将得到的IP地址返回给客户端，客户端建立连接</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在传输IP数据包的时候，确定了源IP和目标IP后，就通过路由表确定IP数据包下一跳、因为网络层下面是数据链路层，所以要知道下一跳的MAC地址。</p><p>因为主机路由表可找到下一跳的IP地址，所以可通过ARP协议，求下一跳MAC地址</p><p>即已知IP地址求MAC地址</p><p>ARP就是借助ARP请求域ARP响应两种类型确定MAC地址</p><p>主机通过广播发送ARP请求（里面有想知道的MAC地址的主机IP地址）；同个链路中所有设备收到ARP请求时，会自动拆开ARP里的内容，若里面的IP地址与自己的一致就将自己MAC地址放入ARP响应包返回给主机</p><p>操作系统会把第一次获取的MAC地址缓存起来（有期限）。</p><p>RARP：已知MAC地址求IP地址。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态获取IP地址，省去了配IP信息繁琐过程</p><p>步骤：</p><p>​    客户端发起DHCP发现报文的IP数据报（用的UDP广播通信，因IP地址、DHCP服务器地址都不知道），并用0.0.0.0作为源IP地址，255.255.255.255为广播目的地址。DHCP客户端将该IP数据包传给MAC，MAC再将帧广播到所有网络设备中</p><p>​    DHCP服务器收到DHCP报文时向客户端响应，里面包含IP地址、子网掩码等信息。客户端收到一个或多个服务器的DHCP提供报文后，选择一个服务器，并对其发送DHCP请求报文进行响应，回显配置的参数。服务端用DHCP ACK报文进行响应，回应其要求的参数</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>网络地址转换NAT，缓解IPV4地址耗尽的问题</p><p>简单说就是在主机对外通信时，把私有IP地址转换成公有IP地址</p><p>缺点：外部无法主动与NAT内部服务器建立连接，因NAPT转换表没有转换记录；转换表的生成与转换操作会产生性能开销；通信过程中，若NAT路由器重启了，所有TCP链接将重置</p><p>解决：改用IPV6；NAT穿透技术</p><h3 id="ICMP（互联网控制报文协议）"><a href="#ICMP（互联网控制报文协议）" class="headerlink" title="ICMP（互联网控制报文协议）"></a>ICMP（互联网控制报文协议）</h3><p>主要功能：确认IP包是否到达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置</p><p>分类</p><p>​    查询报文类型：诊断查询信息</p><p>​    差错报文类型：通知出错原因的错误信息</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四次挥手</title>
      <link href="/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；</p><p>当服务器端收到FIN后，发送ACK应答报文，服务端就进入close_wait状态，</p><p>客户端收到ACK应答报文后，进入FIN_WAIT_2状态</p><p>服务端做最后的数据处理（读到结束符EOF）已发送完成，则向客户端发FIN报文，服务端就进入LAST_ACK状态 ；</p><p>客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传），就进入TIME_WAIT状态；</p><p>服务器端收到ACK就关闭（CLOASE状态），客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/guocheng.png"></p><h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><p>关闭连接时，客户端向服务端发送FIN后，表示客户端不再发数据，但是能接收数据</p><p>服务端收到FIN后，先回ACK应答，但可能还有数据处理和发送不能立马关闭socket，等不再发数据后，才发FIN表示同意现在关闭连接。</p><p>所以，服务端需要等待完成数据的发送和处理，ACK和FIN一般都会分开发送，所以多一次</p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么TIME_WAIT等待时间是2MSL：是报文最大生存时间，超过这个时间报文将被丢弃。因为TCP报文基于IP协议的，IP头部中有一个TTL字段，是IP数据报可以经过最大路由数，<em><strong>MSL要  &amp;ge; TTL消耗为0的时间</strong></em>。2MSL是从<em><strong>客户端收到FIN后发送ACK开始计时的</strong></em>，若客户端的ACK没有传到服务端，客户端就又会收到来自服务端的FIN报文，那么2MSL将重新计时</p><p>为什么需要TIME_WAIT：主动发起关闭连接的一方才会有TIME-WAIT状态。需要TIME-WAIT状态，是<em><strong>防止接收到具有相同的四元组出现的旧数据包</strong></em>，2MSL足以上两个方向上数据包都被丢掉，保证出现的数据包一定是建立连接时所产生的；保证连接能正确关闭：给出足够的时间确保最后的ACK能让被动关闭方接收</p><p>TIME_WAIT过多的危害：内存资源占用；端口资源的占用，一个TCP连接至少消耗一个本地端口，若沾满了所有端口，就不能创建新链接</p><p>若已建立了链接，但客户端突然故障：</p><p>​TCP的&#x3D;&#x3D;保活机制&#x3D;&#x3D;：定义一个时间段，该时间段内，若没有任何连接相关的活动，TCP保活机制就会开始作用，每隔一个时间段就发探测报文（数据很少），若连续几个探测报文没有回应，则认为当前TCP连接已死亡，系统内核就将错误信息通知给上层应用</p><p>​对端程序工作正常：TCP保活的探测报文，对端会正常响应，TCP保活时间会被重置</p><p>​对端程序崩溃并重启：发探测报文，对端可响应，但是没有该连接的有效信息，会产生一个RST报文，就很块发现TCP连接已被重置</p><p>​对端程序崩溃或其他原因让报文能不到达：探测报文不能得到响应，TCP会报告该TCP连接已死亡</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>四次挥手优化</p><p>​    主动方优化：发FIN报文的方式有close和shutdown，所以发送更改方式。调整FIN重传次数。调整状态时间和孤儿连接的上限个数。</p><p>   被动方优化：复用time_wait状态的连接（只使用于客户端）</p><p>Close：断开后，不能传输数据也不能发数据。</p><p>Shutdown：控制只关闭一个方向的连接</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP怎么保证可靠传输</title>
      <link href="/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
      <url>/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="普通处理"><a href="#普通处理" class="headerlink" title="普通处理"></a>普通处理</h1><p>应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传送</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；</p><p>TCP会在<strong>数据包丢失和确认应答丢失后发生超时重传</strong></p><p>设置的时间RTO：RTO太大，重发慢，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时。所以，设置的RTO应该略大于报文忘返RTT的值</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>以<em><strong>数据驱动重传</strong></em>。收到三个相同ACK报文时，会在定时器过期之前，重传文段。</p><p>只解决了超时时间的问题，有另一个问题：重传的时候，是重传一个，还是重传之前的所有，所以就有了SACK方法</p><h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p>在TCP头部的“选项”字段中添加一个SACK，<em><strong>将缓存的地图发送给发送方</strong></em>，发送方就知道哪些数据收到了，哪些没有，就可以<em><strong>只传丢失的数据</strong></em>、</p><h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p>使用了SACK告诉 发送方，有哪些数据被重复接收了。</p><p>可以让发送方知道，是发出去的包丢了；可以知道是不是发送方的数据包被网略延时了；可以知道网络中是不是把发送方的数据包给复制了</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>TCP是每发一个数据，收到回应后再发下一个，数据包忘返时间长，通信效率低。</p><p>发送方会定时发送窗口大小探测报文，及时知道接收方窗口大小辩护</p><p>窗口大小就是指<em><strong>无需等待确认应答，可以继续发送数据的最大值</strong></em></p><p>大小在TCP头部，该字段是接收端告诉发送端自己有多少缓冲区可接收数据，发送端根据这个发送数据</p><p>接收窗口和发送窗口大小不完全相等：接收窗口大小约等于发送窗口大小。因为滑动窗口大小不是一成不变，若接收方的程序读取数据很快，接收的滑动窗口就会空出来。那么新的接收窗口大小，是通过TCP头部的窗口大小字段告诉发送方，传输存在时延，所以两者是约等于的关系</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率，根据接收方的实际接收能力变化</p><p>窗口关闭：窗口大小为0，就会阻止发送方传递数据，直到窗口非0。当窗口关闭时，接收方处理完数据后会发送一个窗口非0的ACK报文，若该报文丢失，那会出现问题</p><p>​解决窗口关闭时潜在的死锁现象：TCP为每一个连接设置定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器。该计时器若超时，就发送窗口探测报文，对方在确认该探测报文时会给出自己的窗口大小</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>目的是<em><strong>避免发送方的数据填满整个网络</strong></em></p><p>拥塞窗口是发送方维护的一个状态变量，根据网络的拥塞程度动画变化。</p><p>发送了超时重传，就认为网络出现拥塞</p><h2 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h2><p>慢启动：当发送方每收到一个ACK，拥塞窗口CWND的大小就加1。当没启动到ssthresh就使用拥塞避免算法</p><p>拥塞避免：每收到一个ACK时，CWND增加1&#x2F;CWND</p><p>拥塞发生：就出现数据包重传</p><p>​超时重传：ssthresh设为CWND&#x2F;2，CWND重置为1</p><p>​快速重传：CWND为原来的一半，ssthresh&#x3D;CWND，进入快速恢复算法</p><p>快速恢复：拥塞窗口CWND&#x3D;ssthresh+1；重传丢失的数据包；若重复收到ACK，CWND+1；收到新的ACK后，CWND就设置为第一步中的ssthresh的值，恢复到之前的状态</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手</title>
      <link href="/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
      <url>/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="三次握手简述"><a href="#三次握手简述" class="headerlink" title="三次握手简述"></a>三次握手简述</h1><p>目的是建立可靠的通信信道，也就是双方确认自己与对方发送与接收是正常的</p><p>TCP连接：用于保证可靠性和流浪控制维护的某些状态信息，包括socket、序列号和窗口大小</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><img src="/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/guocheng.png"></p><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端<strong>随机初始化序号</strong>，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以<em><strong>阻止重复历史连接的初始化</strong></em>（最主要，若是两次握手就不能判断，防止旧的重复连接初始化造成混乱，因为在网络拥塞下，旧的SYN比新的SYN先到服务端，那服务端就会回SYN+ACK）：若是历史连接，客户端发送的报文就是RST报文，表示终止这一次连接，反之则是ACK报文。先发的数据包不一定先到，所以客户端会通过上下文比较实际收到的ACK与期望收到的ACK。</p><p><em><strong>同步双方的初始序列号</strong></em>：</p><p>​序列号的作用：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发出去的数据包，哪些已被对方收到。</p><p>​两次握手只保证一方的初始化序列号能被对方成功接收，没办法保证双方</p><p>避免资源浪费：若服务端阻塞，客户端没有收到ACK就会发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：<strong>无法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立</strong>，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p><em><strong>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</strong></em></p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么客户端和服务端和初始序列号ICN是不同的若一个已经失效的连接被重用了，但旧连接的历史报文还残留在网络中，若序列号相同究就不能判断该报文是不是历史报文，历史报文被接收就会发生数据混乱。所以每次建立连接前重新初始化序列号是为了<em><strong>通信双方能根据序号将不属于本连接的报文丢弃</strong></em></p><p>SYN攻击：攻击者短时间伪造不同的IP地址的SYN报文，服务端每收到一个SYN报文，就进入下一个状态，但服务端发送的ACK+SYN报文无法得到IP的ACK应答，久而久之就沾满SYN接收队列（未连接队列），服务器就不能为正常的用户服务。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>​     客户端优化：修改SYN重传次数、调整客户端的三次握手时间上限。</p><p>​     服务端优化：调整SYN半连接队列大小，增大accept全连接队列大小</p><p>​     绕开三次握手：客户端从第二次向服务器建立连接之后。就减少了1个RTT时间的（客户端到服务器端的忘返时间）消耗。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度算法</title>
      <link href="/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>无论是在批处理系统还是分时系统中，用户进程数一般都多用于处理机数，这将导致它们互相争夺处理。另外，系统进程也同样需要使用处理机。<br>这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><h1 id="7种调度算法"><a href="#7种调度算法" class="headerlink" title="7种调度算法"></a>7种调度算法</h1><h2 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h2><p>最简单的一种调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><p>算法思想：主要从“公平的角度考虑”</p><p>规则：按照作业&#x2F;进程到达的先后顺序进行服务</p><p>用于作业&#x2F;进程调度：用于作业调度时，考虑的是哪个作业先到达后备<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>；用于进程调度时，考虑的是哪个进程先到达就绪队列</p><p><strong>非抢占式的算法</strong></p><p><strong>优缺：</strong> 公平、算法实现简单<br><strong>缺点：</strong> 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利<br><strong>不会导致饥饿</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">周转时间=作业完成时间-作业提交时间</span><br><span class="line">平均周转时间=各作业周转时间之和 / 作业数</span><br><span class="line">带权周转时间=作业周转时间 / 作业实际运行的时间=（作业完成时间-作业提交时间）/ 作业实际运行的时间</span><br></pre></td></tr></table></figure><h2 id="短作业优先的调度算法（SJF）"><a href="#短作业优先的调度算法（SJF）" class="headerlink" title="短作业优先的调度算法（SJF）"></a>短作业优先的调度算法（SJF）</h2><p>从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。</p><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级</p><h2 id="时间⽚轮转调度算法-RR"><a href="#时间⽚轮转调度算法-RR" class="headerlink" title="时间⽚轮转调度算法(RR)"></a>时间⽚轮转调度算法(RR)</h2><p>时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许运⾏的时间。</p><h2 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h2><p>最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p><h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>根据比率：<em><strong>R&#x3D;(w+s)&#x2F;s</strong></em> （R为响应比，w为等待处理的时间，s为预计的服务时间）</p><p>如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p><p> 高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p><strong>根据公式可知：</strong></p><ul><li>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</li><li>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</li></ul><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</p><p>多级反馈队列调度算法的实现思想如下：</p><ol><li>应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</li><li>赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。</li><li>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</li><li>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWiteArrayList</title>
      <link href="/2022/07/04/CopyOnWiteAayList/"/>
      <url>/2022/07/04/CopyOnWiteAayList/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>写数组的拷贝，<em><strong>支持高效率并发且是线程安全</strong></em>，读操作无锁的ArrayList。所有操作都是通过对底层进行一次新的复制实现</p><p>适用于读操作远远大于写操作的场景里。</p><p>存在扩容的概念，因为每次写操作都要复制一个副本，在副本的基础上修改后改变Aray引用。写操作需要大面积复制数组，所以性能很差</p><p><em><strong>读多写少</strong></em>的场景</p><h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><p>核心：创建新副本，读写分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;<span class="comment">//内部维护的数组</span></span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (E) a[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>直接通过下标访问数组，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有CAS操作。因为只是读，不会进行任何修改</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局的锁的状态</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当下（旧）的数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">//创建新的数组，并将旧的数组所有数据赋值到新的数组中</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//在末尾添加新的数据</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//将旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                    <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">            Object[] newElements;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index;</span><br><span class="line">            <span class="comment">//如果就是插入到末尾</span></span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//旧数组里的所有数据都赋值到新的数组</span></span><br><span class="line">                newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//声明新长度的数组</span></span><br><span class="line">                newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//以要插入的位置为分界线，把插入的下标的数据空出来</span></span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                 numMoved);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往index插入数据</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">//旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add方法采用ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份数据被复制的数组；因为一开始的数组引用时被volatile修饰，根据happens-beffore规则，写线程对数组引用的修改对读线程是可见的；</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="comment">//获取的数组中下标为index的数据值</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">            <span class="comment">//如果数组里该下标本身的值与需要设定的值不一样</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">                <span class="comment">//旧数组的值复制到新数组里</span></span><br><span class="line">                Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">                <span class="comment">//在下标为index处赋值</span></span><br><span class="line">                newElements[index] = element;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一样就不需要更改，直接修改旧数组的引用即可</span></span><br><span class="line">                <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove、removeRange与上面都类似</p><h2 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h2><p>读读共享、其他都互斥</p><p>读写锁规则的升级：读取时完全不用加锁的，并且更厉害的是，<em><strong>写入也不会阻塞读操作</strong></em></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>读多写少的场景，写即使慢一些也行</p><p>场景：黑名单、每日更新；监听看；迭代操作远多余修改操作</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>数据一致性问题：CopyOnWite容器只能<em><strong>保证数据的最终一致性</strong></em>，不能保证数据<em><strong>实时</strong></em>的一致性。所以，一旦写入不会马上就可以被读到</p><p>内容占用：因为通过复制机制开辟出一个新的副本，进行写操作时，内存里会同时驻扎两个对象的内存</p>]]></content>
      
      
      
        <tags>
            
            <tag> List </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程安全的集合类</title>
      <link href="/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全的，它给几乎所有的public方法都加上了synchronized关键字，也正因为如此，加锁导致性能降低，在不需要并发访问同一对象时，这种强制性的同步机制就显得多余，所以现在Vector已被弃用。</p><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>HashTable和HashMap类似，不同点是HashTable是线程安全的，它给几乎所有public方法都加上了synchronized关键字，还有一个不同点是HashTable的K，V都不能是null，但HashMap可以，它现在也因为性能原因被弃用了。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Vector和HashTable被弃用后，它们被ArrayList和HashMap代替，但它们不是线程安全的，所以Collections工具类中提供了相应的包装方法把它们包装成线程安全的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Set&lt;E&gt; synHashSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Map&lt;K,V&gt; synHashMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K,V&gt;());</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步。</p><h1 id="Java-util-concurrent包中的集合"><a href="#Java-util-concurrent包中的集合" class="headerlink" title="Java.util.concurrent包中的集合"></a>Java.util.concurrent包中的集合</h1><h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h4><p>ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而ConcurrentHashMap是更细粒度的加锁。</p><p>在JDK1.8之前，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment含有整个table的一部分，这样不同分段之间的并发操作就互不影响。</p><p>JDK1.8对此做了进一步的改进，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</p><h4 id="2-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#2-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="2.CopyOnWriteArrayList和CopyOnWriteArraySet"></a>2.CopyOnWriteArrayList和CopyOnWriteArraySet</h4><p>它们是加了写锁的ArrayList和ArraySet，锁住的是整个对象，但读操作可以并发执行。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autowired和Resource</title>
      <link href="/2022/06/25/Autowired%E5%92%8CResource/"/>
      <url>/2022/06/25/Autowired%E5%92%8CResource/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>@Autowired：</p><p>对成员变量、方法及构造函数进行标注，完成自动装配的工作</p><p>@Resource：</p><p>​官方定义：在语义上被定义为通过其唯一的名称来标识特定的目标组件，其中声明的类型与匹配过程无关</p><p>​若没有明确指定名称，则默认名称是从字段名称或设置方法（get、set方法）派生的。若用在字段上，则采用字段名称；如果用在setter方法，它采用其属性名称（例如setProperty()方法，取property作为属性名称）    </p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>包含的属性不同：</p><p>​Autowired只包含一个参数：required，表示是否开启自动注入，默认是true</p><p>​Resource有七个参数，其中最重要的两个参数：name和type</p><p>注解使用的地方不同：</p><p>​Autowired可以用在构造方法、方法、参数、成员变量和注解上</p><p>​Resource可以用在类、成员变量、方法上</p><p>出处不同：</p><p>​Autowired是Spring定义的注解，所以只能用在Spring框架下</p><p>​Resource是JSR-250定义的注解，所以可以与其他框架一起使用</p><p>自动装配的方式不同：</p><p>​Autowired默认按byType，如果要使用byName，需要结合@Qualifier注解配合使用</p><p>​Resource默认byName自动装配，如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配</p><p>自动装配的顺序：</p><p>​Autowired：默认先按byTpe进行匹配，若发现找到多个bean则又按照byName方式进行匹配，如果还有多个，则抛出异常</p><p>​<img src="/2022/06/25/Autowired%E5%92%8CResource/A.png" alt="image-20220625222414253"></p><p>​Resource：</p><p>​若同时指定了name和type：会从容器中查找name和type唯一匹配bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了name：则按name后的名字去bean元素里查找有与之相等的name属性的bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了type：则从上下文汇总找到类型匹配的<em><strong>唯一</strong></em>bean进行装配，找不到或者找到多个，都会抛出异常</p><p>​都没有指定：自动按照byName方式找，若没有找到符合的bean，则回退为一个原始类型进行查找，如果找到就注入，没找到或者找到多个则抛出异常</p><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro</title>
      <link href="/2022/06/16/Shiro/"/>
      <url>/2022/06/16/Shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/06/16/Shiro/jiegou1.png" alt="image-20220616152612753"></p><p><strong>Subject</strong>：主体，外部应用与subject进行交互，subject记录当前的用户。外部程序通过subject进行认证权限，subject通过Security Manager安全管理进行认证</p><p><strong>Security Manager</strong>：对全部subject进行安全管理，核心。可以对subjectManager完成subject的认证、授权，实质上是通过Authenticator</p><p>本身是一个接口，继承了Authenticator、Authorizer、SessionManager三个接口</p><p><strong>Authenticator</strong>：认证器，对用户身份进行认证，本身是一个接口，shiro提供ModularRealmAuthenticator的实现类，可以满足大部分需求</p><p><strong>Authorizer</strong>：授权器，用户通过授权器，用户通过认证器通过，在访问功能时需要通过授权器判断用户是否能操作的权限</p><p><strong>Realm</strong>：就相当于datasource数据源，subjectManager进行安全认证需要通过Realm获取用户权限数据</p><p><strong>SessionManager</strong>：会话管理，shiro定义了一套会话管理，不依赖web容器的session</p><p><strong>CacheManager</strong>：缓存管理，将用户的权限数据存储在缓存</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>即身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确</p><p>Subject：访问系统的用户，主体可以是用户、程序等</p><p>Principal：身份信息，是主体进行身份认证的标识，标识必须具有唯一性，一个主体可以有多个身份，但必须有一个主身份</p><p>credential：凭证信息，是只有主体自己知道的安全信息</p><h1 id="权限字符串"><a href="#权限字符串" class="headerlink" title="权限字符串"></a>权限字符串</h1><p>资源标识符：操作：资源实例标识符    对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用*通配符。</p><p>比如：用户创建权限   user:create  或 user:create:*</p><p>​用户实例001的所有权限 user:*:001</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><em><strong>以下所有代码来源于“编程不良人”</strong></em></p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 授权</span></span><br><span class="line"><span class="comment">     * @param principals</span></span><br><span class="line"><span class="comment">     * @return AuthorizationInfo</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">//获取身份信息 内容根据实际情况(看源码了解)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">primaryPrincipal</span> <span class="operator">=</span> (String) principals.getPrimaryPrincipal();</span><br><span class="line">        System.out.println(<span class="string">&quot;PrincipalCollection      &quot;</span>+primaryPrincipal);</span><br><span class="line">        <span class="comment">//从工厂中获取service对象</span></span><br><span class="line">        <span class="comment">//根据主身份信息获取角色 和 权限信息</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils</span><br><span class="line">                .getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="comment">//根据userService找到用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findRolesByUserName(primaryPrincipal);</span><br><span class="line">        <span class="comment">//授权角色信息</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(user.getRoles()))&#123;</span><br><span class="line">            <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">            user.getRoles().forEach(role-&gt;&#123;</span><br><span class="line">                <span class="comment">//从数据库中查出来的权限给该对象</span></span><br><span class="line">                simpleAuthorizationInfo.addRole(role.getName());</span><br><span class="line">                <span class="comment">//从数据库中角色具备的权限信息</span></span><br><span class="line">                List&lt;Perms&gt; perms = userService.findPermsByRoleId(role.getId());</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(perms))&#123;</span><br><span class="line">                    perms.forEach(perm-&gt;&#123;</span><br><span class="line">                        <span class="comment">//对该角色赋予相应的权限</span></span><br><span class="line">                        simpleAuthorizationInfo.addStringPermission(perm.getName());</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 身份认证,主体调用用户登录时，会调用该方法</span></span><br><span class="line"><span class="comment">     * @param token</span></span><br><span class="line"><span class="comment">     * @return AuthenticationInfo 里面收集用户提交的身份（比如：用户名）和凭据（比如：密码）</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取身份信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> (String) token.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">credentials</span> <span class="operator">=</span> (String) token.getCredentials();</span><br><span class="line">        <span class="comment">//在工厂中获取service对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUserName(principal);</span><br><span class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(user))&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   用户名</span></span><br><span class="line"><span class="comment">            *   加密的密码</span></span><br><span class="line"><span class="comment">            *   随机盐</span></span><br><span class="line"><span class="comment">            *   当前realm的名称</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user.getUsername(),user.getPassword(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MyByteSource</span>(user.getSalt()),</span><br><span class="line">                    <span class="built_in">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="doGetAuthenticationInfo中的principal和credentials的来源"><a href="#doGetAuthenticationInfo中的principal和credentials的来源" class="headerlink" title="doGetAuthenticationInfo中的principal和credentials的来源"></a>doGetAuthenticationInfo中的principal和credentials的来源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password,String code,HttpSession session)</span> &#123;</span><br><span class="line">       <span class="comment">//比较验证码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">codes</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (codes.equalsIgnoreCase(code))&#123;</span><br><span class="line">               <span class="comment">//获取主体对象</span></span><br><span class="line">               <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">               <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">               <span class="comment">//  重点  重点</span></span><br><span class="line">               <span class="comment">//将该UsernamePasswordToken类对象作为token专递给doGetAuthenticationInfo</span></span><br><span class="line">               subject.login(token);</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码错误!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;用户名错误!&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;密码错误!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/user/loginview&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="UsernamePasswordToken源码"><a href="#UsernamePasswordToken源码" class="headerlink" title="UsernamePasswordToken源码"></a>UsernamePasswordToken源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordToken</span> <span class="keyword">implements</span> <span class="title class_">HostAuthenticationToken</span>, RememberMeAuthenticationToken &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> rememberMe;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"><span class="comment">//省去了所有构造方法以及所有set方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] getPassword() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过该方法得到的username</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRememberMe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rememberMe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.host = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.rememberMe = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.password != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.password.length; ++i) &#123;</span><br><span class="line">                <span class="built_in">this</span>.password[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.password = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义的realm进行操作的配置"><a href="#自定义的realm进行操作的配置" class="headerlink" title="自定义的realm进行操作的配置"></a>自定义的realm进行操作的配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroDialect&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建shiroFilter  //负责拦截所有请求</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager defaultWebSecurityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//给filter设置安全管理器</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   可以实现权限相关的拦截器</span></span><br><span class="line"><span class="comment">         *       常用:</span></span><br><span class="line"><span class="comment">         *           anon:无需认证(登录)也已访问</span></span><br><span class="line"><span class="comment">         *           authc:必须认证和授权才可以访问</span></span><br><span class="line"><span class="comment">         *           user:若使用rememberMe的功能可以直接访问</span></span><br><span class="line"><span class="comment">         *           perms:该资源必须资源权限才可以访问</span></span><br><span class="line"><span class="comment">         *           role：该资源必须得到角色权限</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//配置系统受限资源</span></span><br><span class="line">        <span class="comment">//配置系统公共资源</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/getImage&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/register&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/registerview&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);<span class="comment">//authc 请求这个资源需要认证和授权</span></span><br><span class="line">        <span class="comment">//默认认证界面路径,没有登录的用户就都可以访问的</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/user/loginview&quot;</span>);</span><br><span class="line">        <span class="comment">//放在过滤链里面</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="comment">//未授权的</span></span><br><span class="line">        <span class="comment">//shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建安全管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(Realm realm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//给安全管理器设置</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建自定义realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Realm <span class="title function_">getRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CustomerRealm</span> <span class="variable">customerRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerRealm</span>();</span><br><span class="line">        <span class="comment">//修改凭证校验匹配器</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//设置加密算法为md5</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">//设置散列次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//放入realm</span></span><br><span class="line">        customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="comment">//开启缓存管理，用redis缓存信息</span></span><br><span class="line">        customerRealm.setCacheManager(<span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>());</span><br><span class="line">        customerRealm.setCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启全局缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCachingEnabled(<span class="literal">true</span>);<span class="comment">//认证认证缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCacheName(<span class="string">&quot;authenticationCache&quot;</span>);</span><br><span class="line">        customerRealm.setAuthorizationCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启授权缓存</span></span><br><span class="line">        customerRealm.setAuthorizationCacheName(<span class="string">&quot;authorizationCache&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customerRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的RediscacheManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title class_">CacheManager</span> &#123;</span><br><span class="line">    <span class="comment">//参数1:认证或者是授权缓存的统一名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; Cache&lt;K, V&gt; <span class="title function_">getCache</span><span class="params">(String cacheName)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;redis Cache      &quot;</span>+cacheName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCache</span>&lt;K,V&gt;(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现redis作为缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span>&lt;k,v&gt; <span class="keyword">implements</span> <span class="title class_">Cache</span>&lt;k,v&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cacheName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">(String cacheName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheName = cacheName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get              &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;get key:&quot;</span>+k);</span><br><span class="line">        System.out.println( <span class="string">&quot;redis  get value     &quot;</span>+getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString()));</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">put</span><span class="params">(k k, v v)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;put           &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;put key: &quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;put value:&quot;</span>+v);</span><br><span class="line">        getRedisTemplate().opsForHash().put(<span class="built_in">this</span>.cacheName,k.toString(),v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">remove</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============remove=============&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().delete(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;=============clear==============&quot;</span>);</span><br><span class="line">        getRedisTemplate().delete(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().size(<span class="built_in">this</span>.cacheName).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;k&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().keys(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;v&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().values(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate <span class="title function_">getRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用于接口（接口式）"><a href="#作用于接口（接口式）" class="headerlink" title="作用于接口（接口式）"></a>作用于接口（接口式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@RequiresRoles(value=&#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span><span class="comment">//用来判断角色  Logical.OR:满足其中一个就行   logical = Logical.AND:要同时满足</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;user:update:01&quot;)</span> <span class="comment">//用来判断权限字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入方法多个&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用于接口（编程式）"><a href="#作用于接口（编程式）" class="headerlink" title="作用于接口（编程式）"></a>作用于接口（编程式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">save1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">       <span class="keyword">if</span> (subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">           <span class="comment">//有权限</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有权限</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外还有标签式，因采用前后端分离，便不再展示</p>]]></content>
      
      
      <categories>
          
          <category> 权限框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud简单阐述</title>
      <link href="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
      <url>/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Spring社区有大一统java的趋势，快速构建一个单体单元SpringBoot，分布式微服务解决方案，SpringCloud和SpringFrameWork和各种组件等等</p><p>SpringCloud是一个分布式的微服务解决方案。区别于Dubbo，Dubbo只是一个远程RPC框架，而前者则是一整套的解决方案，包括<strong>服务注册、服务调用、负载均衡、服务网关、服务降级与熔断、分布式配置管理、消息总线</strong>等等技术。</p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou3.png" alt="1"></p><p>SpringCloud 是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。</p><p>通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p><p>SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix</p><h2 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h2><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/eureka.png" alt="1"></p><p>作用：实现服务治理（服务注册与发现）</p><p>简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</p><p>由两个组件组成：Eureka服务端和Eureka客户端。</p><p>Eureka服务端用作服务注册中心。支持集群部署。</p><p>Eureka客户端是一个java客户端，用来处理服务注册与发现。</p><p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个组件可实现自动拼接服务地址</p><ul><li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li><li>接着你要是调用那个接口，<strong>本质就是会调用 Feign创建的动态代理</strong></li><li>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来<strong>动态构造出你要请求的服务的地址</strong></li><li>最后针对这个地址，发起请求、解析响应</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>主要提供客户侧的软件<strong>负载均衡</strong>算法。</p><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p><ul><li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</li><li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li><li>Feign就会针对这台机器，构造并发起请求。</li></ul><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>可以在调用服务的时候，在服务出现异常时进行服务熔断和降级避免一直长时间等待服务返回结果而出现雪崩效应</li><li>它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</li></ul><p>熔断：当发现有服务卡死不能工作的时候，熔断器会对他进行熔断，比如这5分钟对这个服务的请求就直接返回了，不要去走网络请求卡几秒钟，这个过程就是溶断！</p><p>降级：就是当服务被熔断后，每次调用这个服务，你就写到单独的数据库中，等这个服务修复后，你手工的添加到业务的数据库中。这个过程就是降级！</p><p>雪崩：如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><h1 id="为什么还要SpringCloudAlibaba？"><a href="#为什么还要SpringCloudAlibaba？" class="headerlink" title="为什么还要SpringCloudAlibaba？"></a>为什么还要SpringCloudAlibaba？</h1><p>因为SpringCloud版本迭代非常快，每次发布一个realease之后又会马上发布下一个版本，所以可能会积累很多bug，而若是进入到了维护阶段，意味着不会再有新的组件技术出现，只是在原来的技术上修改。</p><h1 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title="SpringCloudAlibaba"></a>SpringCloudAlibaba</h1><p>是Spring cloud的子项目，符合SpringCloud的标准，致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li></ul><h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><p>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。<br>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。<br>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。<br>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。<br>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。<br>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。<br>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。<br><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou1.png" alt="1"></p><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou2.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean的一生</title>
      <link href="/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="配置Bean"><a href="#配置Bean" class="headerlink" title="配置Bean"></a>配置Bean</h1><p>两种方式：在xml中写<bean>标签，用@Bean注解</bean></p><p>两个方法都在sping的refresh方法中都会用loadBeanDefinitions加载到容器里面，通过BeanDefinitionRegistry.register方法，会包括一些后置处理</p><h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><p>配置bean之后就拿到了BeanDefinition，是配置bean的加载结果，也是下面步骤的原始数据。</p><p>Spring在启动时，会扫描到类的信息，将相关信息封装为BeanDefinition存入到beanDefinitionMap中，根据里面的扫描信息生成bean                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><p>注意：beanName、ClassType。</p><p>提前初始化：把那个没有配置的懒加载bean开始初始化</p><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>入参实际上只有一个beanName，与beanDefinition的两个属性相对应，通过beanName然后找到beanType，找到type之后调用&#x3D;&#x3D;反射&#x3D;&#x3D;返回了一object。</p><p>反射的大致：获取class对象得到一个构造器，Constructor ctor&#x3D;clazz.getDeclaredConstructor()，Object obj &#x3D; ctor.newInstance()。</p><p>容器中按照使用者来分，可以把bean对象分为用户自定义对象、容器对象（比如：ApplicationContext、BeanFactory等等）</p><p>注意：InstantiationAwareBeanPostProcessor去生成代理类回来</p><h1 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h1><p>此处就需要解决循环依赖-三级缓存</p><p>给自定义属性赋值：核心在于populateBean里面的autowireByName、autowireByType两个方法（@Autowire，@Resource）</p><p>给容器对象属性赋值：invokeAwareMethods</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>对象的拓展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220614145857358.png" alt="image-20220614145857358"></p><p>在属性赋值阶段后，postProcessBeforeInitialization方法之前，会执行很多Aware类型的接口，这种接口类型作用就是加载到Spring容器中，Aware前面的名字就是对应哪种资源</p><p>aware：如果实现了某些接口，比如BeanNameAware、BeanFactoryAware、ApplicationContextAware，就把这些实例给set进去。</p><p>初始化的方式有三个：分别是Initialization的afterPropertiesSet方法；PostConstruct注解标注方法；配置的init-method</p><p>BeanPostProcessor实现了AOP，AOP就是在整个IOC处理流程中某一个拓展点的实现</p><p>执行完就是一个完成的对象</p><h1 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h1><p>要么去实现DisposableBean接口，要么去定义destory-method方法 </p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环依赖</title>
      <link href="/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h1 id="循环依赖问题简述"><a href="#循环依赖问题简述" class="headerlink" title="循环依赖问题简述"></a>循环依赖问题简述</h1><p><img src="/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/question.png" alt="image-20220613223428341"></p><p>如图所示，在创建对象A的时候，需要依赖注入对象B，但此时容器里面并没有B，所以去创建B，B在创建的过程中又需要A的注入，而此时A在等待B的创建，所以就造成了双方都在等待，类似的“死锁”的情况，导致两者都无法创建成功。</p><p>创建Spring Bean对象到初始化的大致流程</p><p>getSingleton：从单例池中获取bean对象，若没有就创建</p><p>doCreateBean：创建bean对象</p><p>populateBean：填充依赖，若被填充的对象不存在于单例池中，则进行创建</p><p>addSingleton：将初始化完成的对象加入到单例池</p><h1 id="三级循环"><a href="#三级循环" class="headerlink" title="三级循环"></a>三级循环</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">//一级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一级缓存：是成品，里面是完成生命周期的对象，是完成的bean，可以被任意使用</p><p>二级缓存：是半成品，不完整，里面是刚刚实例化但是没有全部实例化的原始对象</p><p>三级缓存：里面的bean是构造器反射创建出来的bean，没有任何的填充属性，单例工程的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">        <span class="comment">//从singletonObjects（一级缓存）尝试获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//如果一次缓存中获取不到并且对象正在创建中，就在二级缓存中查找</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//二级缓存中也查找不到且允许从三级缓存中经过getObject获取</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">               <span class="comment">//对一级缓存进行加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">//一级缓存获取不到</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//二级缓存还是获取不到</span></span><br><span class="line">                        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//获取工厂</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//就从三级缓存中得到bean</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">//若是获取到了，就将singletonObject放入到二级缓存中，并移除三级缓存中的实例</span></span><br><span class="line">                                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isSingletonCurrentlyInCreation（）：判断当前的单例bean是否正在创建的过程中，即没有执行初始化方法</span><br><span class="line">allowEarlyReference：是否允许从三级缓存中经过getObject()方法获取bean对象</span><br></pre></td></tr></table></figure><p>大致：</p><p>Spring会先从一级缓存中去获取bean对象</p><p>获取不到而且对象正在建立中，就会尝试从二级缓存中获取bean</p><p>若还是获取不到，且允许从第三次缓存中的getObject()获取对象，就尝试从三级缓存中获取</p><p>若是三级缓存中获取到了bean，就会将bean放入二级缓存中</p><p>如上图A、B在三级缓存中的迁移过程：</p><p>1创建对象A，完成生命周期第一步（实例化），在调用createBeanInstance方法后，会调用addSingletonFactory方法，将已实例化但未属性赋值未初始化的对象放入三级缓存中。即将对象A提早曝光给IOC容器</p><p>2执行对象A生命周期第二步（属性赋值）。此时，发现对象A依赖对象B，所以就会尝试去获取对象B</p><p>3发现B没有被创建，所以会执行创建对象B的过程</p><p>4创建对象B的过程中，执行实例化和属性赋值操作，此时发生对象B依赖对象A</p><p>5 尝试去缓存中查找对象A。从一级缓存开始找，没有对象A（因为对象A此时还没有初始化完成）；再找二级缓存，也没有对象A（此时的对象A还没有进行属性赋值）；转而查找三级缓存，对象B通过singletonFactory.getObject();拿到对象A</p><p>6对象B获取到对象A后，继续执行生命周期，属性赋值、初始化操作。对象B完成初始化操作后，会被存到一级缓存中</p><p>7转到【对象A执行属性赋值过程并发现依赖了对象B】的阶段，此时对象已经可以从一级缓存中获取到对象B。所以可以顺利执行属性赋值操作</p><p>8对象A执行初始化操作，完成后，对象A也会放到一级缓存中</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>Spring进行扫描-&gt;反射后封装成beanDefinition对象-&gt;放入beanDefinitionMap-&gt;遍历map-&gt;验证（是否单例、是否延迟加载、是否抽象）-&gt;推断构造方法-&gt;准备开始进行实例-&gt;去单例池中查，没有-&gt;去二级缓存中找，没有提前暴露-&gt;生成一个objectFactory对象暴露到二级缓存中-&gt;属性注入，发现依赖Y-&gt;此时Y开始它的生命周期直到属性注入，发现依赖X-&gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;完成循环依赖。</p><h1 id="Spring为什么不能解决非单例Bean的循环依赖"><a href="#Spring为什么不能解决非单例Bean的循环依赖" class="headerlink" title="Spring为什么不能解决非单例Bean的循环依赖"></a>Spring为什么不能解决非单例Bean的循环依赖</h1><p>该问题可以分为：</p><p>Spring为什么不能解决构造器的循环依赖？</p><p>​因为对象的构造函数实在实例化阶段调用。因为在对象实例化后，会将对象放到三级缓存中。在调用对象的构造函数时，对象还没有初始化，所以不能把对象放入三级缓存中。在构造函数注入时，两个对象都没在三级缓存中，所以两个bean都不能实例化</p><p>Spring为什么不能解决prototype作用域循环依赖？</p><p>​IOC只会管理Bean的生命周期，并将单例Bean存放到缓存池中（三级缓存）。Spring不会管理prototype作用域的bean</p><p>Spring为什么不能解决多例的循环依赖?</p><p>​多实例Bean每次调用getBean都会创建一个新的Bean对象，该对象不能缓存。而解决循环依赖是通过缓存实现</p><h1 id="非单实例对象怎么解决？"><a href="#非单实例对象怎么解决？" class="headerlink" title="非单实例对象怎么解决？"></a>非单实例对象怎么解决？</h1><p>对于构造器注入产生的循环依赖，使用@Lazy注解，延迟加载</p><p>对于多例bean和prototype作用域产生的循环依赖，可以尝试改为单例Bean</p><h1 id="为什么一定要三级缓存"><a href="#为什么一定要三级缓存" class="headerlink" title="为什么一定要三级缓存"></a>为什么一定要三级缓存</h1><p><strong>如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理</strong></p><p>使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于 IOC 的考虑，而是出于 AOP 的考虑，即若使用二级缓存，在 AOP 情形注入到其他 Bean的，不是最终的代理对象，而是原始对象。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap部分解析</title>
      <link href="/2022/06/09/concurrentHashMap/"/>
      <url>/2022/06/09/concurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><img src="/2022/06/09/concurrentHashMap/jiegou.png" alt="image-20220609111027013"></p><p>JDK1.7：本质上是一个16个Segment对象的数组，每个Segment都是HashEntry&lt;K,V&gt;[] table，每个table包含若干个HashEntry对象连接起来的链表。get、put等操作只锁当前需要用的桶。即分段数组+链表。</p><p>实现上与hashMap类似，只是采用了分段锁，每个分段锁维护着几个桶（hashEntry），&#x3D;&#x3D;多个线程可以同时访问不同分段锁上的桶&#x3D;&#x3D;</p><p>concurrentHashMap中含有几个segment数组 ，每个segment又含有几个hashEntry数组</p><p>JDK1.8：没有使用段锁，而是采用了Node数组+链表+红黑树的方式</p><h4 id="构造方法（1-8）"><a href="#构造方法（1-8）" class="headerlink" title="构造方法（1.8）"></a>构造方法（1.8）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量              扩容因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, </span></span><br><span class="line"><span class="params">     //并发级别（当前concurrentHashMap对象，最多同时支持多少线程同时操作）segment数组的长度。但是不会随着扩容长度发生变化（因为有了最大的限制）</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//以上均是防止传非法数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Put（1-8）"><a href="#Put（1-8）" class="headerlink" title="Put（1.8）"></a>Put（1.8）</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="comment">//首先就是不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());<span class="comment">//基于key进行计算，一定是正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录某个桶上元素的个数，若&gt;8就转变为红黑树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//是否要初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//根据下标计算，若f为空，数组的这个位置就没有元素，所以加进去就可以退出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//CAS操作，防止多个线程同时进行</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出值判断hash值，判断是否是forwar节点（代表是否正在扩容）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//锁这个节点，保证该节点的元素插入是安全的（不影响其他节点）。即保证安全又保证效率</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//为什么还要判断？ 防止变成树后节点发生了变化</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//fh&gt;0就代表是一个链表结构</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//遍历依次比对</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//原数组里面没有，就需要添加新的节点</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//不是&gt;0就不是链表结构，就是树结构</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以上就添加结束，就开始维护</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//泊松分布</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)  <span class="comment">//TREEIFY_THRESHOLD=8</span></span><br><span class="line">                        <span class="comment">//触发变成树的可能函数</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护集合长度，是否扩容</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Get（1-8）"><a href="#Get（1-8）" class="headerlink" title="Get（1.8）"></a>Get（1.8）</h4><p>  计算hash值</p><p>根据hash值计算得到数组相应的位置</p><p>在该位置进行针对性的查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">//计算值，将保存数据的table赋值给tab，且判断数组是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//该数组下标所对应的值</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组上的值就是所要查找的值</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//就表示正在进行扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//直接遍历链表需要所要查找的值</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现高效并发机制的保证：</p><p>通过不加锁和加锁的两种方案控制跨段操作的安全性</p><p>通过HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作</p><p>（理想操作）可以支持16个线程执行并发写操作，及任意数量线程的读操作</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>微服务是一种架构风格，即将单体应用划分为小型的服务单元，微服务之间使用 HTTP 的 API 进行资源访问与操作。</p><p>在笔者看来，微服务架构的演变更像是一个公司的发展过程，从最开始的小公司，到后来的大集团。大集团可拆分出多个子公司，每个子公司的都有自己独立的业务、员工，各自发展，互不影响，合起来则是威力无穷。</p><p>臃肿的系统、重复的代码、超长的启动时间带给开发人员的只有无限的埋怨，丝毫没有那种很舒服的、很流畅的写代码的感觉。他们把大部分时间都花在解决问题和项目启动上面了。</p><h3 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h3><p>使用微服务架构能够为我们带来如下好处：</p><h4 id="1）服务的独立部署"><a href="#1）服务的独立部署" class="headerlink" title="1）服务的独立部署"></a>1）服务的独立部署</h4><p>每个服务都是一个独立的项目，可以独立部署，不依赖于其他服务，耦合性低。</p><h4 id="2）服务的快速启动"><a href="#2）服务的快速启动" class="headerlink" title="2）服务的快速启动"></a>2）服务的快速启动</h4><p>拆分之后服务启动的速度必然要比拆分之前快很多，因为依赖的库少了，代码量也少了。</p><h4 id="3）更加适合敏捷开发"><a href="#3）更加适合敏捷开发" class="headerlink" title="3）更加适合敏捷开发"></a>3）更加适合敏捷开发</h4><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行。服务拆分可以快速发布新版本，修改哪个服务只需要发布对应的服务即可，不用整体重新发布。</p><h4 id="4）职责专一，由专门的团队负责专门的服务"><a href="#4）职责专一，由专门的团队负责专门的服务" class="headerlink" title="4）职责专一，由专门的团队负责专门的服务"></a>4）职责专一，由专门的团队负责专门的服务</h4><p>业务发展迅速时，研发人员也会越来越多，每个团队可以负责对应的业务线，服务的拆分有利于团队之间的分工。</p><h4 id="5）服务可以按需动态扩容"><a href="#5）服务可以按需动态扩容" class="headerlink" title="5）服务可以按需动态扩容"></a>5）服务可以按需动态扩容</h4><p>当某个服务的访问量较大时，我们只需要将这个服务扩容即可。</p><h4 id="6）代码的复用"><a href="#6）代码的复用" class="headerlink" title="6）代码的复用"></a>6）代码的复用</h4><p>每个服务都提供 REST API，所有的基础服务都必须抽出来，很多的底层实现都可以以接口方式提供。</p><h3 id="微服务架构的劣势"><a href="#微服务架构的劣势" class="headerlink" title="微服务架构的劣势"></a>微服务架构的劣势</h3><p>微服务其实是一把双刃剑，有利有弊。下面我们来谈谈微服务有哪些弊端，以及能采取什么办法避免。</p><h4 id="1）分布式部署，调用的复杂性高"><a href="#1）分布式部署，调用的复杂性高" class="headerlink" title="1）分布式部署，调用的复杂性高"></a>1）分布式部署，调用的复杂性高</h4><p>单体应用的时候，所有模块之前的调用都是在本地进行的，在微服务中，每个模块都是独立部署的，通过 HTTP 来进行通信，这当中会产生很多问题，比如网络问题、容错问题、调用关系等。</p><h4 id="2）独立的数据库，分布式事务的挑战"><a href="#2）独立的数据库，分布式事务的挑战" class="headerlink" title="2）独立的数据库，分布式事务的挑战"></a>2）独立的数据库，分布式事务的挑战</h4><p>每个微服务都有自己的数据库，这就是所谓的去中心化的数据管理。这种模式的优点在于不同的服务，可以选择适合自身业务的数据，比如订单服务可以用 MySQL、评论服务可以用 MongoDB、商品搜索服务可以用 ElasticSearch。</p><p>缺点就是事务的问题了，目前最理想的解决方案就是柔性事务中的最终一致性，后面的章节会给大家做具体介绍。</p><h4 id="3）测试的难度提升"><a href="#3）测试的难度提升" class="headerlink" title="3）测试的难度提升"></a>3）测试的难度提升</h4><p>服务和服务之间通过接口来交互，当接口有改变的时候，对所有的调用方都是有影响的，这时自动化测试就显得非常重要了，如果要靠人工一个个接口去测试，那工作量就太大了。这里要强调一点，就是 API 文档的管理尤为重要。</p><h4 id="4）运维难度的提升"><a href="#4）运维难度的提升" class="headerlink" title="4）运维难度的提升"></a>4）运维难度的提升</h4><p>在采用传统的单体应用时，我们可能只需要关注一个 Tomcat 的集群、一个 MySQL 的集群就可以了，但这在微服务架构下是行不通的。当业务增加时，服务也将越来越多，服务的部署、监控将变得非常复杂，这个时候对于运维的要求就高了。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父类子类加载顺序</title>
      <link href="/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
      <url>/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><p>父类静态属性（成员变量） &gt; 父类静态代码块 &gt; 子类静态属性 &gt; 子类静态代码块 &gt; 父类非静态属性 &gt; 父类非静态代码块 &gt; 父类构造器 &gt; 子类非静态属性 &gt; 子类非静态代码块 &gt; 子类构造器</p><p>简而言之就是先静态后非静态，先父类后子类</p><ol><li>父类静态变量</li><li>父类静态代码块（若有多个按代码先后顺序执行）</li><li>子类静态变量</li><li>子类静态代码块（若有多个按代码先后顺序执行）</li><li>父类非静态变量</li><li>父类非静态代码块（若有多个按代码先后顺序执行）</li><li>父类构造函数</li><li>子类非静态变量</li><li>子类非静态代码块（若有多个按代码先后顺序执行）</li><li>子类构造函数</li></ol><p><em><strong>所有的静态资源都只会被加载一次，非静态资源可以被重复加载</strong></em></p><h1 id="类初始化和实例初始化"><a href="#类初始化和实例初始化" class="headerlink" title="类初始化和实例初始化"></a>类初始化和实例初始化</h1><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>一个类要创建实例需要先加载并初始化该类</p><p>  Main方法所在的类需要先加载和初始化</p><p>子类要初始化需要先初始化父类</p><p>一个类初始化就是执行<clinit>()方法 类初始化方法</clinit></p><p>  <clinit>()方法由静态类变量显示赋值代码和静态代码块组成</clinit></p><p>  类变量显示赋值代码和静态代码块代码从上到下顺序执行</p><h2 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h2><p>就是执行<init>()方法</init></p><p>  <init>()方法可能重载有多个，有几个构造器就有几个<init>方法</init></init></p><p>  <init>()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成</init></p><p>  非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应的构造器的代码最后执行</p><p>  每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法</init></p><p>  <init>方法的首行就是super()或super（实参列表），即对应父类的<init>方法</init></init></p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>不能被重写的方法</p><p>Final方法</p><p>  静态方法</p><p>  Private等子类中不可见的方法</p><p>多态性</p><p>  子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码</p><p>  非静态方法默认的调用对象是this</p><p>  This对象在构造器或者说<init>方法中就是正在创建的对象</init></p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法被子类重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Son()&#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//写或不写都在，一定会会调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="小结特点"><a href="#小结特点" class="headerlink" title="小结特点"></a>小结特点</h1><ol><li>静态属性和代码块，当且仅当该类在程序中第一次被 new 或者第一次被类加载器调用时才会触发（不考虑永久代的回收）。也正是因为上述原因，<strong>类优先于对象</strong> 加载&#x2F;new，即 <strong>静态优先于非静态</strong>。</li><li>属性（成员变量）优先于构造方法，可以这么理解，加载这整个类，需要先知道类具有哪些属性，并且这些属性初始化完毕之后，这个类的对象才算是<strong>完整的</strong>。另外，非静态代码块其实就是对象 new 的准备工作之一，算是一个不接受任何外来参数的构造方法。因此，<strong>属性 &gt; 非静态代码块 &gt; 构造方法。</strong></li><li>有趣的是，<strong>静态部分（前4个）是父类 &gt; 子类</strong>，而 <strong>非静态部分也是父类 &gt; 子类。</strong></li><li>另外容易忽略的是，非静态代码块在每次 new 对象时都会运行，可以理解：<strong>非静态代码块是正式构造方法前的准备工作</strong>（非静态代码块 &gt; 构造方法）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>实现单例模式三个主要特点：</p><p>1、构造方法私有化；</p><p>2、实例化的变量引用私有化；</p><p>3、获取实例的方法共有。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>静态化实例对象</p><p>私有化构造方法，禁止通过构造方法创建实例</p><p>提供一个公共的静态方法，用来返回唯一的实例</p><h1 id="单例的好处"><a href="#单例的好处" class="headerlink" title="单例的好处"></a>单例的好处</h1><p>整个系统只存在一个对象，内存开始少，性能好</p><p>避免对资源的多重占用</p><p>在系统设置全局访问点，优化和共享资源访问</p><h1 id="不同创建方式"><a href="#不同创建方式" class="headerlink" title="不同创建方式"></a>不同创建方式</h1><p>饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//向外提供   自行创建   不能更改(单例)</span></span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">static</span>    <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的懒汉式：线程不安全，不可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内部类加载：静态内部类不会随着外部类的加载和初始化而初始化。因为是在内部类加载和初始化时创建的。所以线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h1><p>反射</p><p>常见的单例模式实现中，往往有一个私有的构造函数，防止外部程序的调用，但是通过反射可以轻而易举的破坏这个限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> singleton.getSingleton();</span><br><span class="line">            Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">reflectInstance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">            System.out.println(S\singleton == reflectInstance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：false，单例被破坏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>序列化</p><p>其中 Singleton 实现了 Serializable 接口，才有可能通过序列化破坏单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>克隆</p><p>实现 Cloneable 接口重写 clone 方法</p><h1 id="枚举类详解"><a href="#枚举类详解" class="headerlink" title="枚举类详解"></a>枚举类详解</h1><p>Joshua Bloch大神在《Effective Java》中明确表达过的观点：使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法</p><p>枚举类型单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">public</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类的单例模式优点</p><p>写法简单</p><p>枚举会自己处理序列化：<em><strong>传统的单例存在一个问题，一旦实现了序列化接口，那么就不再保持单例</strong></em>，因为readObject()方法一直返回一个新的对象，就像java的构造方法一样</p><p>枚举类创建的是thread-safe</p><p>面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点</p><p>在序列化的过程中Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。</p><p>如上，序列化的时候只将 INSTANCE这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。</p><h1 id="不会被破坏单例的原因"><a href="#不会被破坏单例的原因" class="headerlink" title="不会被破坏单例的原因"></a>不会被破坏单例的原因</h1><p>通过枚举实现的单例模式，利用反射构造新的对象，由于 <a href="https://so.csdn.net/so/search?q=enum&spm=1001.2101.3001.7020">enum</a> 没有无参构造器，结果会抛出 NoSuchMethodException 异常;</p><p>枚举类不实现 Serializable 接口，都可以进行序列化，并且返回原来的单例;</p><p>Enum 类中 clone 的方法是 final 类型，无法重写，也就不能通过克隆破坏单例。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础</title>
      <link href="/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>是管理计算机硬件与软件资源的程序</p><p>本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件的资源</p><p>屏蔽了硬件层的复杂性</p><p>内核是操作系统核心，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</p><h2 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h2><p>处理器的执行状态分为内核态和用户态，就是为了避免操作系统和关键字数据被用户程序破坏</p><p>内核态：是操作系统管理程序执行时所处状态，能执行包含特权指令在内的所有指令，能访问系统内所有的存储空间</p><p>用户态：用户态运行的进程或可以直接遁去用户程序的数据</p><h2 id="实现内核态和用户态的切换"><a href="#实现内核态和用户态的切换" class="headerlink" title="实现内核态和用户态的切换"></a>实现内核态和用户态的切换</h2><p>系统调用：是操作系统的最小功能单位，操作系统提供的用户接口，本身是一种软中断。</p><p>异常：也叫内中断，由错误引起</p><p>外中断: 通过两根信号线来通知处理器外设的状态变化，是硬中断</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配的基本单位，独立运行的基本单位</p><p>由以下组成：</p><p>  进程控制块PCB，进程唯一存在标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级，CPU现场保护区（用户进程切换），占有的资源清单</p><p>  程序段</p><p>  数据段</p><p>状态：</p><p>  创建态（进程正在被创建）</p><p>就绪态（除了CPU，其他资源都有，一个系统中可有多个进程处于该状态）、</p><p>运行态（占有处理器正在运行）、</p><p>阻塞态（不具备运行条件，在等待某个时间完成）</p><p>  结束态（进程正在从系统中消失）</p><p>孤儿进程：父进程退出，子进程还在运行。将被init进程收养</p><p>僵尸进程：进程使用fork创建子进程，若子进程退出，而父进程没有调用wait或waitpid获取子进程状态信息，那子进程的进程描述符仍然保存在系统中</p><h3 id="进程间的通信方法"><a href="#进程间的通信方法" class="headerlink" title="进程间的通信方法"></a>进程间的通信方法</h3><p>  每个进程各有不同的用户地址空间，任何一个进程的全局变量在另一个进程看不见。所以，进程间的交换数据必须在内核：在内核中开辟出一块缓冲区，进程A把数据从用户空间拷贝到内核缓冲区，进程B再从内核缓冲区把数据读走。</p><p>不同进程间的通信本质：进程间可以看到一份公共资源；提供这资源的形式或提供者不同，通信方式也就不同</p><p>主要包括：管道&#x2F;匿名管道，消息队列、信号量、信号、共享内存、套接字socket</p><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>互斥量：互斥对象机制</p><p>信号量：允许同一时刻多线程访问同一资源，但要控制同一时刻最大线程数</p><p>事件：通过通知操作的方式来保持多线程同步</p><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><p>当前运行的进程运行结束、当前运行进程阻塞、执行完系统调用等系统程序后返回用户进程、抢占式调度中有更高优先级的进行就绪、分时系统中，分给当前进程的时间片用完</p><h3 id="不能进行调度的时候"><a href="#不能进行调度的时候" class="headerlink" title="不能进行调度的时候"></a>不能进行调度的时候</h3><p>中断处理程序执行时，操作系统的内核程序临界区内、其他需要完全屏蔽中断的原子操作过程中</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>某个函数、数据库在并发环境中被调用时，能够正确的处理多个线程之间的共享变量，让程序功能正确完成</p><p>上下文就是这样的过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作</p><h3 id="进程同步的方法"><a href="#进程同步的方法" class="headerlink" title="进程同步的方法"></a>进程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程划分的任务，是一个进程内可调度的实体，CPU调度的基本单位，来保证程序的实时性，实现进程内部的并发</p><p>是操作系统可识别的最小执行和调度单位</p><h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p>用Volatile关键字，就是多个线程同时监听一个变量</p><p>Object类的wait和notify</p><p>JUC工具类CountDownLatch</p><h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>比线程更轻量级，不被操作系统管理，完全由程序控制（用户态执行）。这样能提升性能，不会像线程那样切换而消耗资源</p><p>单线程下的并发 </p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2022/05/24/MySQL-1/"/>
      <url>/2022/05/24/MySQL-1/</url>
      
        <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p> 连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、缓冲组件、优化器组件、插件式存储引擎、物理文件</p><h2 id="三大范式和反模式"><a href="#三大范式和反模式" class="headerlink" title="三大范式和反模式"></a>三大范式和反模式</h2><p>第一：属性不可分割，原子项</p><p>第二：原子性，即非主属性必完全依赖主属性</p><p>第三：原子性，非主属性必完全主属性，且不存在传递依赖</p><p>反模式：解决了旧问题，又产生了新问题。实际开发中，不会严格遵守三范式</p><h2 id="三种引擎"><a href="#三种引擎" class="headerlink" title="三种引擎"></a>三种引擎</h2><p><img src="/2022/05/24/MySQL-1/yinqin.png" alt="引擎"></p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><a href="https://xiaoerbutingbu.github.io/2022/05/11/InnoDB-1/">详情请看</a></p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存存放，hash索引（默认）</p><p>所有数据存在内存汇总，数据的处理速度快，但安全性不高，因对表的大小有要求，不能建太大的表。适用于需要很快的读写速度、安全性要求较低的</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快</p><p>若主要用于插入新记录和读出记录，该引擎就能实现处理的高效率。若应用的完整性、并发性要求较低，也可</p><p>每次查询具有原子性</p><p>B+树的索引结构</p><p>非聚集性索引，存储会有两个文件，一个索引文件，一个数据文件，其中索引文件的索引指向数据文件中的表数据</p><p>用一个变量保存了整个表的行数，而innodb是全表扫描</p><p>支持全文索引，innodb不支持全文索引（5.7以前）</p><p>可以被压缩后查询</p><p>所以MYISAM只缓存索引块，记录的直接是文件的OFFSET，定位比INNODB块。多以查询比较快</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制，是一种并发控制的方法，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p><em><strong>就是为了实现读写冲突不加锁。</strong></em></p><p>MVCC多版本并发控制：维持一个数据的多个版本，让读写操作没有冲突</p><p>在InnoDB中的实现主要是为了提高数据库并发性能</p><p>使用RC和RR隔离级别的事务，在执行普通selsect操作时，访问记录版本链的过程；让不同事务的读写、写操作并发执行，提高体统性能</p><h3 id="益处"><a href="#益处" class="headerlink" title="益处"></a>益处</h3><p>解决读写冲突的无锁并发控制</p><p>在并发读写时，可在读操作时不用阻塞写操作，写操作不用阻塞读操作，提供读写性能；解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>第一种：将数据记录的多个版本保存在数据库中，当这些版本数据不再需要时，垃圾回收器就回收这些记录</p><p>第二种：只在数据库中保存最新版本的数据，但是在使用undo时动态重构旧版本数据</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>3个隐式字段：分别记录</p><p>​                 最近修改事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</p><p>​                 指向这条记录的上一个版本；</p><p>​                 隐含自增ID，若数据表没有主键，就自动产生一个聚集索引</p><p>Undo日志：</p><p>​        Insert undo log：事务在insert新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>​        Update undo log：在update或delete时产生；事务回滚需要，快照读也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该该日志，才会被统一清除</p><p>Read View：</p><p>​         事务进行快照读操作的时候生产的读视图</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>适合索引的列是出现在where字句中的列或连接子句中指定的列</p><p>基础较小的类，索引效果差。</p><p>使用短索引：若对长字符串进行索引，应该指定要前缀长度，这样能够节省大量索引空间</p><p>不能过度索引，因为索引需要额外的磁盘空间，并降低写操作的性能。修改表的内容时，索引会进行更新甚至重构，索引的列越多，时间就越长。所以，只保持需要的索引有利于查询即可</p><p>存储引擎层实现，索引：帮助mysql高效获取数据的数据结构</p><p>提高数据库的性能，不用加内存，不用该程序，不同调sql</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>​每张表的主键构成一棵B+树，同时叶子节点存放的即为整张表的行记录数据，叶子节点也就是数据页</p><p>​将数据存储与索引放到一块，索引的叶子节点保存了行数据，&#x3D;&#x3D;必有且只有一个聚集索引&#x3D;&#x3D;。若有主键，主键即是；无主键用第一个唯一索引；若都没，会自动生成一个rowid作为隐藏的聚集索引。</p><p>​        结构：B+树：&#x3D;&#x3D;将所有数据都放在叶子节点&#x3D;&#x3D;，叶子节点形成一个列表；非叶子只存放键值，每个数据叶中的有效数据就多了，可以减少IO次数。按键值的大小顺序存放在同一层的叶子节点上</p><p>​    因为相对于二叉树（会有左倾右倾的情况），B+树层级更少，搜索效率高</p><p>​    因为B树：无论叶子节点还是非叶子，都保存数据，所以存储值减少，指针就减少，要同样保存大量数据，只能增加树的高度，导致性能降低，要查找就要遍历整个树</p><p>​    Hash索引只支持等值匹配，不支持排序操作</p><h4 id="辅助索引（非聚集索引）"><a href="#辅助索引（非聚集索引）" class="headerlink" title="辅助索引（非聚集索引）"></a>辅助索引（非聚集索引）</h4><p>与聚集索引不同的是，叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点索引行中还包含一个书签（用来让Innodb知道哪里可以找到与之对应的行数据）</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>把无序的数据变成有序的查询</p><p>创建了索引的列的内容进行排序</p><p>对排序结果倒排索引</p><p>在倒排表内容上拼上数据地址链</p><p>查询时，先拿倒排表内容，再取出数据地址链，从而拿到数据</p><h3 id="主要分类"><a href="#主要分类" class="headerlink" title="主要分类"></a>主要分类</h3><p>普通索引、唯一索引（hash）、主键索引、组合索引、全文索引（full text），BTREE，RTREE</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka常见问题</title>
      <link href="/2022/05/23/kafka-1/"/>
      <url>/2022/05/23/kafka-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka比RocketMQ吞吐量高的原因"><a href="#Kafka比RocketMQ吞吐量高的原因" class="headerlink" title="Kafka比RocketMQ吞吐量高的原因"></a>Kafka比RocketMQ吞吐量高的原因</h3><p>kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息没有发送到Broker而是<em><strong>在生产者缓存起来</strong></em>，然后直接向业务返回成功。当缓存的消息达到了一定的数量时再分批量发送给Broker。这样就减少了网络IO，从而提高了消息发送的吞吐量，但若消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用该机制提高了性能却降低了可靠性</p><h3 id="Kafka的pull和Push的优缺点"><a href="#Kafka的pull和Push的优缺点" class="headerlink" title="Kafka的pull和Push的优缺点"></a>Kafka的pull和Push的优缺点</h3><p>pull表示消费者主动拉取，可批量拉也可单条拉，所有pull可由消费者自己控制，根据自己的消息处理能力来进行控制，但消费者不能及时知道是否有消息，拉的消息可能为空</p><p>push表示broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就消费多少消息，可能会造成网络堵塞，消费者压力大等问题</p><h3 id="kafka的rebalance机制"><a href="#kafka的rebalance机制" class="headerlink" title="kafka的rebalance机制"></a>kafka的rebalance机制</h3><p>consumer group中的消费者与topic下的partion重新匹配的过程</p><p>产生rebalance的时间： consumer group 中的成员个数发生变化， consumer消费超时，group订阅的topic个数发生变化，group订阅的topic的分区数发生变化</p><p>coordinator（协调者）：是partition的leader节点所在的broker，负责监控group中的consumer的存活，consumer维持到coordinator的心跳，判断consumer的消费超时。    通过心跳返回通知consumer进行rebalance；consumer请求coordinator加入组，coordinator选举产生leader consumer；leader consuemr从coordinator获取所有的consumer，发送syncGroup（分配信息）给到coordinator；coordinator通过心跳机制将syncGroup下发给consumer</p><p>leader consumer监控topic的变化，通知coordinator触发rebalance</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="/2022/05/23/kafka-1/jiagou.png" alt="image-20220501201317495"></p><p>consumer group：消费者组，消费者组内每个消费者负责消费不同分区的数据，提供消费能力。逻辑上的一个订阅者</p><p>topic：理解为一个队列，topic将消息分类，生产者和消费者面向同一个topic</p><p>partition：为了实现拓展性，提供并发能力，一个topic以多个partition的方式分布到多个broker上，每个partition是一个有序的队列。一个topic的每个partition都有若干个副本，一个leader和若干个follower。生产者发送数据的对象，以及消费者消费数据的对象都是leader。follower负责实时从leader中同步数据，保证和leader数据的同步。leader故障，某个follower会成为新的leader</p><h3 id="zookeeper作用"><a href="#zookeeper作用" class="headerlink" title="zookeeper作用"></a>zookeeper作用</h3><p>&#x2F;brokers&#x2F;ids：临时节点，保存所有broker节点信息，存储broker的物理地址、版本信息、启动时间等，节点名称为brokerID，broker定时发送心跳到zk，若断开该brokerID会被删除</p><p>&#x2F;brokers&#x2F;topic：临时节点，节点保存broker节点下所有的topic信息，每一个topic节点下包含一个固定的partition节点，partitions的子节点就是topic的分区，每个分区下保存一个state节点，保存着当前leader分区和ISR的brokerID，leader创建state节点，若leader宕机，该节点会被删除，直到新的leader产生，重新生成state节点</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;owners&#x2F;[topic]&#x2F;[broker_id-partition_id]：维护消费者和分区的注册关系。 比如：consumer下有c1，c2，c3分别与topic下的p1，p2，p3相连，该节点就是记录消费者消费的哪个分区关系。若c1宕机了，p1就没有消费端，就触发rebalance</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;offsets&#x2F;[topic]&#x2F;[broker_id-partition_id]：分区消息的消费进度offset。partition第一次拉取了consumer的第一条消息，第二次就拉取第二条，该节点就记录这个信息  </p><p>client通过topic找到topic树下的state节点，获取leader的brokerID，到broker树找到broker的物理地址，但是client不会直连zk，而是通过配置的broker获取到zk中的信息</p><h3 id="高性能的原因"><a href="#高性能的原因" class="headerlink" title="高性能的原因"></a>高性能的原因</h3><p>指读写性能</p><p>kafka<em><strong>不基于内存</strong></em>，而是硬盘存储，因此消息堆积能力更强，硬盘容量大。文件系统</p><p>顺序写：利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的，节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition物理上分为多个segment存储方便删除</p><p>传统：读取磁盘文件数据到内核缓冲区；将内核缓冲区的数据copy到用户缓冲区；将用户缓冲区的数据copy到socket的发送缓冲区；将socket发送缓冲区的数据发送到网卡，进行传输</p><p>零拷贝：直接将内核缓冲区的数据发送到网卡传输；使用的是操作系统的指令支持</p><p>kafka不太依赖jvm，主要理由操作系统的pageCache，由操作系统决定把数据从pageCache刷到磁盘，若生产消费速率相当，则直接用pageCache交换数据，不需要经过磁盘IO</p><h3 id="消息高可靠的解决方案"><a href="#消息高可靠的解决方案" class="headerlink" title="消息高可靠的解决方案"></a>消息高可靠的解决方案</h3><p>消息发送：</p><p>​ack：0、不重试；1、leader写入成功就返回了；all&#x2F;-1、等待ISR同步完再返回（ISR列表中的follow全部同步完成）</p><p>​unclean.leader.election.enable：false，禁止选举ISR以外的follower为leader。若为true，即允许leader从OSR中选举，即使ack为all，消息也可能丢失，因为leader从OSR中选的话，该follow与之前的leader相比已经差了很大了 </p><p>​tries&gt;1，重试次数</p><p>​min.insync.replicas&gt;1：最小同步副本数，没满足该值前，不提供读写服务、写操作异常</p><p>消费：</p><p>​手工提交offset；</p><p>broker：</p><p>​减少刷盘间隔；事务消息</p><h3 id="消息丢失的场景和解决"><a href="#消息丢失的场景和解决" class="headerlink" title="消息丢失的场景和解决"></a>消息丢失的场景和解决</h3><p>场景：</p><p>​ack&#x3D;0：即producer发送消息完后，不管发送结果了，若发送失败数据也就丢失了</p><p>​ack&#x3D;1，leader crash：producer发送消息后，只等待lead写入成功就返回了，leader crash了，这时follow没来得及同步，消息就丢失了</p><p>​unclean.leader.election.enable 配置为true：即允许OSR节点作为leader，producer发送完消息，只等待leader写入成功就返回了，但leader crash而ISR没有follower，leader就会从OSR选举，而OSR的信息本来就落后于leader，就造成信息发生丢失</p><p>解决：</p><p>发送端</p><p>​ack&#x3D;all&#x2F;-1，tries&gt;1,unclean.leader.election.enable配置为false ：producer发送完消息，等待follower同步完再返回，若异常则重试，副本的数量可能影响吞吐量</p><p>​不允许选举ISR以外的副本作为leader</p><p>​配置：min.insync.replicas&gt;1：<em><strong>副本指定必须确认写操作成功的最小副本数量</strong></em>。若不能满足这个最小值，则生产者将引发一个异常</p><p>​min.insync.relicas和ack跟搭嘎的持久性保证，确保如果大多数副本没有收到写操作，则生产者将引发异常</p><p>​失败的offset单独记录：producer发送消息，会自动重试，遇到不可恢复异常会抛出，这时可以捕获异常记录到数据库或缓存，进行单独处理</p><p>消费端</p><p>​先commit再处理消息，如果在处理消息的时候异常了，但是offset已经提交了，该消息对于该消费者就是丢失了，再也不会被消费到</p><p>​<em><strong>而若先处理，没来得及commit就宕机了，消息就会被重复消费</strong></em></p><p>broker</p><p>​减少刷盘间隔</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="/2022/05/22/IO/"/>
      <url>/2022/05/22/IO/</url>
      
        <content type="html"><![CDATA[<h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><h3 id="阻塞式I-x2F-O"><a href="#阻塞式I-x2F-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h3><p>用户线程发出IO请求后，内核会查看数据是否就绪，若没有就绪，就会等待数据就绪，而一直处于阻塞状态并交出CPU资源</p><h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><p>用户线程发出一个请求后会立刻得到一个结果，若结果是error就再次发起请求，直到得到结果。在此期间会一直占用CPU，因为会一直询问内核数据是否就绪</p><h3 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h3><p><a href="https://xiaoerbutingbu.github.io/2022/08/19/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">多路复用IO模型</a></p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>用户线程发起IO请求，会给对应的socket注册一个信号函数，线程再继续执行，当用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际IO请求操作</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>用户线程发起请求后，就可做其他事，当接收到数据内核返回的成功信号时，就表示IO操作已经完成，可以直接去使用数据</p><h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p>本身是指数据 从源头到目的地</p><p>其中的输入输出流都是在外部文件和内存之间数据的流通</p><p>分为两种：字符流和字节流。InputStream和OutputStream，Reader，Writer</p><h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>底层设备只接收字节数据，字符流是字节流的包装，字符流则是直接接收字符串，它会在内部转成字节，再写入底层设备</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>同步阻塞，服务器实现模式为一个连接一个线程</p><p>服务端：通过serverSocket注册端口；服务器通过调用accept方法用于监听客户端socket请求；从socket中获取字节输入或者输出进行数据读写</p><p>客户端：通过socket独享请求域服务端的连接；从socket得到字节输入或字节输出流进行数据的读写</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>同步非阻塞式，核心类：</p><p>​                 Buffer（缓冲区）为所有原始类型提供缓存支持，是一个容器，连续的数组 </p><p>​                 Charset字符集编码解决解码方案</p><p>​                 Channel（通道）一个新的原始I&#x2F;O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备、程序或是网络的连接</p><p>数据source：需要读取，使用：InputStream、Reader。对应了 硬盘、内存、键盘（System.in）</p><p>数据destination：就是需要写入，使用OutputStram、Writer对应了 硬盘、内存、控制台（System.out）</p><h3 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h3><p>BIO：同步阻塞式IO，就平常使用的，模式简单使用方便，并发处理能力低</p><p>​    是一个连接一个线程</p><p>​    适用于连接数目较小且固定的架构，对服务器资源要求较高</p><p>NIO：同步非阻塞IO，客户端和服务器端通过Channel通讯，多路复用</p><p>​    一个请求一个线程</p><p>​    适用于连接数目多且连接较短的架构，比如聊天服务器</p><p>AIO：NIO的升级，异步非阻塞IO，异步IO操作基于事件和回调机制</p><p>一个有效请求一个线程</p><p>适用于连接数据木多且连接较长的架构，比如相册服务器</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础-类加载</title>
      <link href="/2022/05/21/JVM-2/"/>
      <url>/2022/05/21/JVM-2/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h1><p>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件结构</p><p>ClassLoader只负责class文件的加载，至于是否可以运行，则由ExecutionEngine决定</p><p>加载的类信息存放于一块称为方法区的内存空间，除了类信息外，方法区还有存放运行时常量池的信息，可能还包含字符串自变量和数字常量</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>加载-验证-准备-解析-初始化-使用-卸载</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>​    <em><strong>通过一个类的全限定名获取定义此类的二进制字节流（字节码文件）</strong></em></p><p>通过类额全限定名获取定义此类的二进制字节流；将该字节流所代表的的静态存储结构转化为方法区的运行时数据结构；内存生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>目的确保class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性不会危害虚拟机自身安全</p><p>主要包括四种验证：</p><p>文件格式验证：验证字符流格式是否符合Class问价你格式的规范，并能被当前版本的处理机处理</p><p>元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合要求。是否有父类、父类的继承是否合理、若不是抽象类是否实现了父类或接口的要求</p><p>字节码验证：通过数据流分析和控制流分析确定程序语义是合法的、符合逻辑的。</p><p>符号引用验证：发生在虚拟机将符号引用转为直接引用的时候</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><em><strong>为类变量分配内存并且设置该类变量的默认初始值，即零值</strong></em>。</p><p>此处不包含用修饰的static，因为final在编译时就已经会分配了，准备阶段会显示初始化</p><p>&#x3D;&#x3D;这里不包括实例变量分配初始化&#x3D;&#x3D;，实例变量是会随着对象一起分配到java堆中</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><em><strong>将常量池的符号引用（不一定已加在内存）转换为直接引用的过程</strong></em></p><p>符号引用：一组符号来描述所引用的目标，符号无形式的字面量，在在使用时能准确定位到目标即可</p><p>直接引用：可以直接指向目标的指针、相对偏移量或是能直接定位到目标的句柄</p><p>主要针对：类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    初始化过程就是执行类构造器方法<clinit>过程</clinit></p><p>该方法javac编译器的自动生成物 </p><p><clinit>方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，收集的顺序由语句在源文件中的出现的顺序决定，静态语句块中只能访问到定义在静态语句块之前的变量，定义在后面的变量在前面的静态语句可以赋值但不能访问</clinit></p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器：引导类加载器，自定义加载器</p><p>所有派生于抽象类ClassLoader的类加载器都划分于自定义加载器</p><p>Java核心类库都是引导类加载器加载的</p><p><img src="/2022/05/21/JVM-2/guocheng.png"></p><h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><pre><code>    该类由c/c++实现，嵌套在JVM内部</code></pre><p>​    用来加载java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path），提供JVM自身需要的类</p><p>​    并不继承java.lang.ClassLoader，没有父加载器</p><p>​    加载拓展类和应用程序类加载器，并指定为他们的父类加载器</p><p>​    为了安全，Bootstrap启动类加载器只加载名为java、javax、sun等开头的类</p><p>拓展类加载器（Extension ClassLoader）</p><p>​Java编写，由sun.misc.Launcher$ExtClassLoader实现</p><p>​派生于ClassLoader类</p><p>​父类加载器为启动类加载器</p><p>​    如果用户创建的JAR放在此目录下，也会自动由拓展类加载器加载</p><p>系统类加载器（应用程序类加载器）</p><p>​    Java编写</p><p>​    父类加载器为拓展类加载器</p><p>​    负责加载环境变量classpath或系统属性，java.class.path指定路径下的类库</p><p>​    该类加载程序中默认的类加载器</p><h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><p>为什么要自定义类加载器</p><p>​    隔离加载类</p><p>​    修改类加载的方式</p><p>​    拓展加载源</p><p>​    防止源码泄露</p><p>实现步骤</p><p>​    通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</p><p>​    JDK1.2之前，在自定义加载类时，总会继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。JDK1.2以后，不再建议用户覆盖loadClass方法，而是建议把自定义的类加载逻辑写在findclass方法中    </p><p>​    若没有复杂需求，可直接继承URLClassLoadr类，这就可避免自己去编写findClass方法及其获取字节码流的方式，使自定义类加载器的简洁</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础-虚拟机栈</title>
      <link href="/2022/05/20/JVM-1/"/>
      <url>/2022/05/20/JVM-1/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h1><img src="/2022/05/20/JVM-1/zucheng.png" alt="组成" style="zoom:150%;"><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>一种快速有效的分配存储方式，<em><strong>访问速度仅次于程序计数器；</strong></em></p><p>线程私有</p><p>  JVM直接对java栈的操作：</p><p>​            每个方法的执行，伴随着进栈（入栈，压栈）</p><p>​            执行结果后的出栈工作</p><p>  不存在垃圾回收的问题</p><p>  栈中的数据都是以栈帧的格式存在，<em><strong>这个线程上正在执行的每个方法都各自对应一个栈帧</strong></em>。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。每一个方法执行结束就对应着一个栈帧从虚拟机栈从入栈到出栈</p><p>栈就只有 压栈 和 出栈</p><p>不同线程中所包含的线帧是不允许相互引用的，即不可能在一个栈帧之中引用另一个线程中的栈帧</p><p>若当前方法调用其他方法，方法返回的时候，当前栈帧会传回此方法的执行结果给前一个栈帧，然后虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p><p>方法的结束方式：正常结束和抛出异常（未被捕获处理）</p><h2 id="栈帧内部结构"><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h2><p><img src="/2022/05/20/JVM-1/zhangzhen.png" alt="zhanzhen"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>  定义为一个数字数组，主要用于<em><strong>存储方法参数和定义在方法体内的局部变量</strong></em></p><p>  因是建立在线程的栈上，是<em><strong>私有</strong></em>的，所以不存在数据安全问题</p><p>  所需的容量的大小是在编译期确定下来的</p><p>  方法嵌套使用的次数由栈的大小决定。越大，次数越多</p><p>  局部变量表中的变量只在当前方法调用中有效。方法调用结束，该表也会随之销毁</p><p>  里面最基本的存储单元Slot（变量槽）：</p><p>​    参数值的存放总是在局部变量数组的index0开始，到数组长度-1结束</p><p>局部变量表最基本的存储单元</p><p>​    局部变量表里，32位以内的类型只占用一个slot，64位占两个</p><p>​    当一个实例方法被调用，它的方法参数和方法体内部定义的局部变量将会按照顺序复制到局部变量表中的每一个slot上</p><p>​    若当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处。</p><p>  Slot重复利用：栈帧中的局部变量表中的槽位是可以重用，为了节省资源。</p><p>  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表直接或间接引用的对象都不会被回收</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>  是一个以字长为单位的数组，但是以后进先出的操作数栈（表达式栈），方法执行过程中，根据字节码指令，进行入栈、出栈操作。</p><p>  进行数据运算的</p><p>  并非采用访问索引的方式来进行数据访问</p><p>  若被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</p><p>Java虚拟机的解释引擎是基于栈（操作数栈）的执行引擎</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>  一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用就是为了支持当前方法的代码能够实现动态连接</p><p>  Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中，动态链接作用就是将这些符号引用转换为调用方法的直接引用</p><p>  常量池：提供一些符号和常量，便于指令的识别</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的PC寄存器的值。（交给执行引擎，让其执行后续操作）</p><p>调用者的PC计数器的值作为返回地址，即调用该方法的指令作为下一条指令的地址</p><p>正常完成与异常完成的区别：异常完成出口退出不会给他上层调用者产生任何的返回值</p><p>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</p><h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>不一定有。比如：对程序调试提供支持的信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2022/05/19/redis_c/"/>
      <url>/2022/05/19/redis_c/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>持久化就是指redis会把内存中的数据写入到硬盘中，redis重启的时候加载这些数据，就最大限度的降低惠存丢失带来的影响。</p><p><em><strong>因为数据全部在内存，若宕机、进程退出，若没有持久化机制，数据就会全部丢失</strong></em>。有了持久化后，redis在下次重启的时候就会进行数据</p><p>备份的执行过程：redis会单独创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上一次持久化好的文件。整个过程，主进程是不进行任何I&#x2F;O操作，就确保了极高的性能，若要大规模的数据恢复，且对于数据恢复的完整性不是很敏感，那RDB方式要比AOF方式更高效。缺点就是最后一次 持久化后数据可能丢失</p><h1 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h1><h2 id="RDB快照（默认）"><a href="#RDB快照（默认）" class="headerlink" title="RDB快照（默认）"></a>RDB快照（默认）</h2><p>​    将当前redis中的数据<em><strong>生成快照二进制的形式</strong></em>保存到硬盘，保存的文件后缀是rdb；redis重启时可以读取快照文件恢复数据。有手动触发和自动触发两种。记录结果</p><h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>​    创建命令：SAVE和BGSAVE（推荐，因为可在不阻塞服务器进程情况下执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save：会阻塞Redis服务，直到RDB持久化完成，当Rredis里面存储了大量数据的时候，就造成较长时间的阻塞，不建议用</span><br><span class="line">bgsave：一般不会阻塞，进行会执行fork操作创建子进程负责，不会阻塞Redis服务进程。Redis服务的阻塞只发生在fork阶段，一般时间很短</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bgsave的流程：</span><br><span class="line">执行besave命令，Redis进程会判断当前是否存在正在执行的RDB或AOF子线程，若存在就直接结束</span><br><span class="line">Redis进程执行fork操作创建子线程，fork操作过程中redis进程会被阻塞</span><br><span class="line">fork完成后，bgsave就结束了，redis进程就不会被阻塞，其他命令就可以被响应</span><br><span class="line">子进程根据redis进程的内存生成快照文件，并替换原有的RDB文件</span><br><span class="line">子进程通过信号量通知Redis进程已完成</span><br></pre></td></tr></table></figure><h3 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h3><p>在配置文件中设置save的相关配置，如save 5 1，就表示在5s内数据被修改1次时自动触发bgsave操作</p><p>当从节点做全量复制时，主节点会自动执行bgsave操作，并且把生成的RDB文件发送给从节点</p><p>执行 “debug reload”命令时，会触发</p><p>执行“shutdown”，若没有开启AOF持久化也会触发bgsave操作</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：节省磁盘空间，恢复速度快（有向的持久化文件，重启redis，数据就可恢复），方便备份，可最大化redis性能</p><p>  缺点：虽然在fork中使用了写时拷贝技术，但若数据庞大，还是较耗性能；在备份周期，意外down掉的话，就会丢失最后一次快照后的所有改变；</p><p>  较适合大数据集恢复速度的，能承受数分钟内的数据丢失</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>  以日志的形式来<em><strong>记录每个写操作</strong></em>，只追加文件，不改写文件。随着AOF越来越大，需要定期对其重写，达到压缩的目的。默认关闭</p><p>  保存redis服务器执行的所有写命令来记录数据库数据。记录过程</p><p>  优点：备份机制更稳健，丢失数据的概率更低；可读的日志形式，通过AOF更稳健，可处理误操作。</p><p>  缺点：比RDB占用更多磁盘空间；恢复备份速度慢；每次读写都同步的话，有一定的性能压力；存在个别bug，造成不能恢复</p><p>  较适合对业务数据敏感的，不能承受数分钟内的数据丢失</p><h3 id="文件同步的策略"><a href="#文件同步的策略" class="headerlink" title="文件同步的策略"></a>文件同步的策略</h3><p>alawas：每次写入缓存区都要同步到AOF文件中，硬盘的操作比较慢，限制了Redis高并发</p><p>no：每次写入缓存区后不进行同步，同步到AOF文件的操作由操作系统负责，每次同步AOF文件的周期不可控，而且增大了每次同步的硬盘的数据量。</p><p>eversec：每次写入缓存区后，由专门的线程每秒钟同步一次，做到了兼顾性能和数据安全。是建议的同步策略，也是默认的策略。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认AOF不开启，需要修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendonly改为yes，开启AOF</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名字</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># AOF文件的写入方式</span></span><br><span class="line"><span class="comment"># everysec 每个一秒将缓存区内容写入文件 默认开启的写入方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># 运行AOF重写时AOF文件大小的增长率的最小值</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment"># 运行AOF重写时文件大小的最小值</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><img src="/2022/05/19/redis_c/changjing.png" alt="场景"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础</title>
      <link href="/2022/05/18/http-1/"/>
      <url>/2022/05/18/http-1/</url>
      
        <content type="html"><![CDATA[<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>是一个在计算机世界专门在 两点 之间 传输 文字、图片、音频、视频等 超文本 数据的 约定和规范</p><p>简单、灵活和易于拓展、应用广泛和跨平台</p><p>不安全</p><p>基于TCP&#x2F;IP,并且使用了【请求-应答】的通信模式</p><h3 id="五大状态码"><a href="#五大状态码" class="headerlink" title="五大状态码"></a>五大状态码</h3><p><img src="/http-1/zhuangtaima.png"></p><p>204：与200基本相同，只是响应头没有body数据</p><p>206：返回的body不是资源的全部，而是其中一部分</p><p>301：永久重定向，请求的资源不存在了，需用新的URL</p><p>302：临时重定向，需要另一URL访问</p><p>304：不具备跳转的含义，资源未修改，重定向已存在的缓冲文件</p><p>400：客户端请求的报文有错，笼统的错误</p><p>403：服务器禁止访问资源，不是客户端请求错误</p><p>404：请求的资源不存在或未找到</p><p>500：服务器错误，笼统</p><p>501：客户端请求的功能不支持</p><p>502：服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器错误</p><p>503：服务器当前忙，暂时无法响应服务器</p><h3 id="工作过程（浏览器输入url后的操作）"><a href="#工作过程（浏览器输入url后的操作）" class="headerlink" title="工作过程（浏览器输入url后的操作）"></a>工作过程（浏览器输入url后的操作）</h3><p>浏览器解析url，生成一个http请求</p><p>根据url从本地文件查找是否有映射ip，浏览器查看缓存（依次找浏览器缓存、系统缓存、路由器缓存）；若没有则域名解析（DNS解析），获取相应的IP地址</p><p>与服务器建立连接</p><p>​    TCP连接的建立（包含三次握手）</p><p>浏览器发起http请求，请求数据包</p><p>服务器收到请求并响应http请求，浏览器得到html源码</p><p>浏览器解析html代码，并请求html代码中的资源</p><p>TCP断开连接（四次挥手）</p><p>浏览器对页面进行渲染呈现给用户</p><h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><p>因为当顺序发送的请求序列中的一个请求因某种原因被阻塞，后面排队的所有请求也一同被阻塞，客户端也就一直请求不到资源</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>支持C&#x2F;S模式、简单、灵活易于拓展、应用广泛和跨平台</p><p>无状态、明文传输、不安全</p><h3 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h3><p>GET：从服务器获取资源，可以是静态的文本、页面、图片视频</p><p>POST：向URL指定的资源提交数据，放在报文的body</p><h3 id="请求头结构"><a href="#请求头结构" class="headerlink" title="请求头结构"></a>请求头结构</h3><p>由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号</p><p>User-Agent：产生请求的浏览器类型</p><p>Accept：客户端可识别的内容类型列表</p><p>Host：请求的主机名</p><h3 id="响应头格式"><a href="#响应头格式" class="headerlink" title="响应头格式"></a>响应头格式</h3><p>状态行：状态码、八本</p><p>响应头部：</p><p>​         Server：应用程序软件的名称和版本</p><p>​         Content-Type：发送给接受者的实体正文的媒体类型</p><p>​         Accept-Language：描述资源所用的自然语言</p><p>​         Content-Length：实体正文长度</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>SSL&#x2F;TLS协议基本流程：</p><p>  客户端向服务器所要并验证服务器的公钥</p><p>  双方协商生产‘会话密钥’</p><p>  双方采用‘会话密钥’进行加密通信</p><h4 id="SSL-x2F-TLS协议建立流程"><a href="#SSL-x2F-TLS协议建立流程" class="headerlink" title="SSL&#x2F;TLS协议建立流程"></a>SSL&#x2F;TLS协议建立流程</h4><p>1 客户端向服务器发加密通信请求（ClientHello）</p><p> 发送：客户端支持的SSL&#x2F;TLS版本、客户端产生的随机数还会用于生产‘会话密钥’、客户端支持的密码套件列表</p><p>2 服务器收到客户端请求后，客户端发出响应。</p><p>回应的内容：SSL&#x2F;TLS协议版本，若浏览器不支持就关闭加密通道；服务器产生的随机数后面用于生产；确认的密码套件列表（如RSA加密算法）；服务器的数字证书</p><p>3 客户端收到回应后，通过浏览器或操作系统中的CA公钥确认数字证书的真实性</p><p>  若没有问题，客户端从数字证书拿出公钥并使用加密报文，向服务器发送：一个随机数（服务器公钥加密）、加密通信算法那改变通知、客户端握手结束</p><p>4 服务器收到客户端的三个随机数后，通过加密算法得到‘密钥’，向客户端发最后的信息：加密通信算法改变通知、服务器握手结束通知</p><h4 id="RSA算法缺陷"><a href="#RSA算法缺陷" class="headerlink" title="RSA算法缺陷"></a>RSA算法缺陷</h4><p>最大的问题是不支持向前加密。因为客户端传递随机数给服务器端时使用的是公钥加密，服务端收到后会用私钥解密得到随机数，一旦服务端私钥泄露了，过去被第三方拦截的锁有TLS通讯密文都会破解</p><p>所以出现了DH算法</p><h4 id="HTTPS优化"><a href="#HTTPS优化" class="headerlink" title="HTTPS优化"></a>HTTPS优化</h4><p>硬件优化：</p><p>  因为https协议是计算密集型，而不是I&#x2F;O密集型，所以CPU要尽可能的好</p><p>软件优化</p><p>  软件升级：将正在使用的软件设计到最新版本。但会花费人力、时间，可能会影响上线</p><p>  协议优化（密钥交换过程优化）：就是密钥交换过程优化：即尽可能选用ECDHE密钥交换，消息忘返时间减短，安全性提高，具备前向安全性</p><p>​TLS升级：简化握手步骤。比如TLS1.3把Hello和公钥交换合并为一个消息</p><p>证书优化：传输优化：选择椭圆曲线证书而不是RSA证书，因为密钥长度短的多</p><p>​验证优化：</p><p>会话复用</p><p>​    SessionID：客户端和服务端首次TLS握手连接后，双方会在内存缓存会话密钥，并用唯一SessionID标识。服务器的内存压力越来越大，客户端再次连接不一定命中上次访问过的服务器</p><p>​    Session Ticket：服务器不缓存每个客户端的会话密钥，缓存工作交给客户端。对于集群服务器，要确保每台服务器加密‘会话密钥’的密钥一致</p><p>证书优化</p><p>证书传输优化：证书选择椭圆曲线证书而不是RSA证书。相同安全长度下，ECC比RSA短</p><p>  证书验证优化：</p><p>CRL：由CA定期更新，实时性较差，吊销证书越多，列表会越来越大，下载速度越慢</p><p>OCSP：是向CA发送查询请求，让CA返回证书的有效状态</p><h3 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h3><table><thead><tr><th align="center">http</th><th align="center">https</th></tr></thead><tbody><tr><td align="center">有安全风险问题</td><td align="center">TCP和HTTP层间加入了SSL&#x2F;TLS安全协议，报文能加密传输</td></tr><tr><td align="center">建立相对简单，TCP三次握手后就进行http报文</td><td align="center">TCP三次握手后还要SSL&#x2F;TLS的握手才能加密报文传输</td></tr><tr><td align="center">端口号80</td><td align="center">端口号443</td></tr><tr><td align="center">不需要数字证书证明身份</td><td align="center">需要向CA申请数字证书来保证服务器的身份可信</td></tr></tbody></table><h3 id="HTTPS解决HTTPS的风险"><a href="#HTTPS解决HTTPS的风险" class="headerlink" title="HTTPS解决HTTPS的风险"></a>HTTPS解决HTTPS的风险</h3><p>因为在HTTP与TCP层之间加入了SSL&#x2F;TLS协议</p><p>窃听风险：混合加密。混合加密的方式实现机密性</p><p>篡改风险：校验机制。摘要算法实现完整性，能生成独一无二的‘指纹’，用于校验数据的完整性，解决篡改风险</p><p>冒充风险：身份证书。要服务器公钥放入数字证书中</p><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>实现信息的机密性，解决窃听风险</p><p>HTTPS采用的是对称加密和非对称加密结合的‘混合加密’</p><ul><li><p>在通信建立前采用非对称加密的方式交换‘会话秘钥’，后续就不再使用非对称加密</p></li><li><p>在通信过程中全部使用对称加密的‘会话秘钥’的方式加密明文数据</p><img src="http-1/hunhe.png" alt="image-20220709115118267" style="zoom: 67%;"></li></ul><p>混合加密的原因：</p><p>  对称加密只用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换</p><p>  非对称加密用两个密钥，公钥和私钥，公钥可任意分发而私钥保密，解决密钥交换问题。速度慢</p><p>使用对称加密而不用非对称加密的原因：因为非对称加密解密算法效率较低，不适合客户端和服务端的高频率通信过程。</p><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>用来实现完整性，解决篡改风险</p><p><img src="/http-1/zhaiyao.png" alt="image-20220709120309951"></p><p>客户端在发送明文之前会通过算法算出明文的‘指纹’，发送时‘指纹+明文’一起加密成密文后发送给服务器，服务器解密后用相同摘要算法算出发送过来的明文，通过比较自己算出的‘指纹’和从客户端来的‘指纹’是否相同</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>客户端向服务器要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密</p><p>将服务器公钥放在数字证书，证书可信即公钥可信</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP基础</title>
      <link href="/2022/05/17/TCP/"/>
      <url>/2022/05/17/TCP/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>TCP是传输层控制协议</p><p><img src="/2022/05/17/TCP/chuanshu.png"></p><p>在运输层的可靠数据传输的服务，面向连接【1对1】、可靠的【一个报文一定能到达接收端】、基于字节流的传输层通信协议</p><p>经常用于FTP文件传输；HTTP&#x2F;HTTPS</p><p>头部包含端口号、序列号</p><p>唯一确定一个TCP连接：TCP四元组（源地址、源端口、目的地址、目的端口）</p><p><img src="/2022/05/17/TCP/jiegou.png" alt="结构"></p><p>标志位</p><p>URG：表示TCP包的紧急指针域有效，<em><strong>保证TCP连接不被中断</strong></em></p><p>ACK：应答域有效</p><p>PSH：push操作，让到达接收端的数据包能直接传给应用程序</p><p>RST：连接复位请求</p><p>SYN：建立连接</p><p>FIN：断开连接</p><h1 id="如何保证可靠传输"><a href="#如何保证可靠传输" class="headerlink" title="如何保证可靠传输"></a>如何保证可靠传输</h1><p>  <a href="https://xiaoerbutingbu.github.io/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/">TCP如何保证可靠传输</a></p><h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h1><p><img src="/2022/05/17/TCP/socket.png" alt="socket"></p><p>服务端和客户端初始化socket，得到文件描述符</p><p>服务端调用bind，将绑定在IP地址和端口</p><p>服务端调用listen，进行监听</p><p>服务端accept，等待客户端连接</p><p>客户端调用connect，向服务端的地址和端口发起连接请求</p><p>服务端accept返回用于传输的socket的文件描述符</p><p>客户端调用write写入数据；服务端调用read读取数据</p><p>客户端断开连接时，调用close，那么服务端read读取数据时就会读到EOF，待处理完数据后，服务端调用close表示关闭连接</p><p>accept发生在哪一步：客户端connect成功返回是在第二次握手，服务端accept成功返回是在三次握手成功之后</p><h1 id="黏包"><a href="#黏包" class="headerlink" title="黏包"></a>黏包</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多个数据包被连续存储在连续的缓存中，在对数据包读取时由于无法确定发生方的发送边界，而采用某一估测值大小来读出数据。双方size不一致就会让发送方发送的若干包数据到接收方接收时沾成一包，从接收缓冲区看，后一包的数据的头紧接着前一包数据的尾</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>TCP若连续几次发送的数据很少，那TCP根据优化算法把这些数据合成一包一次发送，接收方就收到了粘包数据</p><p>  TCP协议有MISS，若数据包过长就会被分开传输。接收方就收到粘包数据</p><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>TCP短连接就不用考虑</p><p>若数据无结构，发送放就只管发，接收方只管接，也不用考虑</p><p>双方建立长连接，要在连接一段是时间内发送不同数据结构：</p><p>​         发送端的每个数据包添加包首部，首部中应该至少包含数据包的长度。这样接收方就能知道数据包的实际长度</p><p>​         发送端将每个数据包封装为固定长度（不够的，0补充），接收端每次就从接收缓冲区中读取固定长度的数据就行，也就拆开了数据包</p><p>​         可在数据包之间设置边界</p><h1 id="与UDP的比较"><a href="#与UDP的比较" class="headerlink" title="与UDP的比较"></a>与UDP的比较</h1><table><thead><tr><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">面向连接</td><td align="center">无连接</td></tr><tr><td align="center">提供可靠服务</td><td align="center">尽最大努力交付</td></tr><tr><td align="center">面向字节流</td><td align="center">数据报文段</td></tr><tr><td align="center">每一条TCP连接都是点到点</td><td align="center">支持一对一，一对多，多对多的交互通信</td></tr><tr><td align="center">首部开销20字节</td><td align="center">首部开销8字节</td></tr><tr><td align="center">全双工可靠通信</td><td align="center">不可靠通信</td></tr><tr><td align="center">常用于FTP文件传输、HTTP&#x2F;HTTPS</td><td align="center">包总量较少信息，视频、音频等多媒体通信，广播通信</td></tr><tr><td align="center">传输较慢，所需资源较多</td><td align="center">传出快，所需资源少</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile</title>
      <link href="/2022/05/16/volatile/"/>
      <url>/2022/05/16/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>是java提供的一个轻量级的同步机制。java中有两种内在的同步机制：同步块和volatile变量，与synchronized相比，volatile更轻量，<em><strong>不会引起线程上下文切换和调度</strong></em>，但是同步性也较差</p><h1 id="并发编程的基本概念"><a href="#并发编程的基本概念" class="headerlink" title="并发编程的基本概念"></a>并发编程的基本概念</h1><p>原子性：一个或多个操作，要么全部执行且过程中不会打断，要么就都不执行。即拒绝多线程操作，同一时刻就只有一个线程进行操作。整个操作中，不会被线程调度器中断的操作，都可以认为是原子性</p><p>可见性：当多个线程去访问一个变量的时候，一个线程修改了一个或多个变量后，其他线程能够立刻看到这些被修改后的值。多线程环境下，一个线程对共享变量的操作对于其它线程是不可见的。volatile来保证可见性，变量被其修饰后，线程本地的内存就会无效，线程对该变量修改后就会同步更新到主内存中，其它线程读取变量时，就会从主内存中读取。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行</p><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>JMM决定一个线程对共享变量的写入在什么时候对另一个线程是可见的。JMM定义了线程和主内存之间的抽象空间：共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的操作必须在工作内存中进行，而不能直接读写主内存中的变量</p><img src="/2022/05/16/volatile/JMM.png" alt="JMM" style="zoom:50%;"><p>对于普通的共享变量，线程A将其修改为某个值的过程在本地内存A中，并没有同步到主内存中；而线程B已经缓存了该变量的旧值，也就导致了共享变量的值不一样。加锁（lock或synchronized）可以解决这样的问题，但是太重量级，影响效率，所以使用volatile</p><p>JMM是个<em><strong>抽象的内存模型</strong></em></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>保证共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量</p><p>该关键字能保证修改的值能立即被更新到主存</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JVM底层volatile是采用<em><strong>内存屏障</strong></em>实现，观察加入volatile关键字和没有加的关键字所产生的汇编代码发现，加入后的会有一个lock指令，实际上相当于一个内存屏障</p><p>内存屏障的作用：</p><p>​能确保指令重排时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障后面的；即执行到内存屏障这句指令时，前面的操作就已经完成</p><p>​会强调对缓存的修改操作立即写入主内存</p><p>​若是写操作，会让其它CPU中对应的缓存行无效，即必须从主内存中读取变量</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>可见性：对一个volatile变量的读，总能看到（任意线程）对该volatile变量最后的写入</p><p>防止指令重排的问题。</p><p>Java虚拟机中，每个线程对应一个工作内存，并共享主内存的数据</p><p>JMM：线程解锁前，必把共享变量的值刷新回主内存；加锁前，必须读主内存的值到自己的工作内存；加锁和解锁是同一把锁</p><h2 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h2><p>JMM会分别限制两种类型的重排序：编译重排序和处理器重排序</p><p>编译重排序：当第二个操作是volatile写时，不管第一个，都不能重排序；当第一个是读时，不管第二个，都不能重排序；第一个写，第二个读，不能</p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><p>对变量的写入操作不依赖变量的当前值或能确保只有单个线程改变变量的值</p><p>该变量不会与其他状态变量一起纳入不变性条件中</p><p>访问变量时不需要加锁</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p>volatile保证了<em><strong>可见性</strong></em>，提供了一定的<em><strong>有序性</strong></em>，<em><strong>不保证原子性</strong></em>。</p><h1 id="单例模式的双重锁为什么要写volatile"><a href="#单例模式的双重锁为什么要写volatile" class="headerlink" title="单例模式的双重锁为什么要写volatile"></a>单例模式的双重锁为什么要写volatile</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//在并发情况下，若没有volatile关键字，该行会出问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton();//分解为三行</span><br><span class="line"></span><br><span class="line">a. memory = allocate() //分配内存</span><br><span class="line"></span><br><span class="line">b. ctorInstanc(memory) //初始化对象</span><br><span class="line"></span><br><span class="line">c. instance = memory //设置instance指向刚分配的地址</span><br></pre></td></tr></table></figure><p>若没有volatile，可能会出现重排序的情况。多线程环境下，可能执行了a，c，没有执行b，A线程执行了c导致instance指向了一个地址，所以判断instance不会null，会直接返回一个初始化对象</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2022/05/15/String/"/>
      <url>/2022/05/15/String/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h1><p>String中使用了final关键字修饰字符数组保存字符串，所以Stirng对象是不可变的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java9之后，String、StringBuilder、StringBuffer都改用byte数组存储</span><br><span class="line">为什么从char字符改为byte字符？</span><br><span class="line">因为节省内存空间，byte占一个字节（8位），char占用两个字节，所以节省了一半的内存空间。降低了gc的压力，针对初始化的字符，对字符长度进行判断而选择不同的编码方式</span><br></pre></td></tr></table></figure><p>StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在该类中也是使用字符数组保存字符串char [] value，但是没有用final关键字修饰，所以这两种对象是可变的</p><p>AbstractStringBuilder类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This no-arg constructor is necessary for serialization of subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an AbstractStringBuilder of the specified capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>因为String类的不可变性，才让JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量中的同一个对象。这样<em><strong>节约内存又提升性能</strong></em></p><p>也因为不可变性，保证了字符串对象在<em><strong>多线程环境下是线程安全的</strong></em>。若String可变，那么会引发严重的安全问题。<em><strong>因为字符串不可变，所以值不能被修改，若字符串是可变的，那么可以通过改变引用地址指向的值去改变字符串的值，也就有安全漏洞</strong></em></p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>String因为不可变，可以<em><strong>理解</strong></em>为常量，线程安全。AbstractStringBuilder是StringBuilder和StringBuffer的公共父类。其中StirngBuffer加了同步锁或者调用的方法加了同步锁，线程安全。StringBuilder并没有对方法加同步锁，线程非安全</p><h1 id="Buffer和Builder"><a href="#Buffer和Builder" class="headerlink" title="Buffer和Builder"></a>Buffer和Builder</h1><p>都是AbstractStringBuilder的子类，但是StringBuffer的几乎所有方法都使用synchronized实现了同步，线程比较安全，在多线程系统中可以保证数据同步。</p><p>而StringBuilder没有实现同步，线程不安全，但是正因如此，效率更高</p><h2 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h2><p>二者的构造方法，默认都是16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer.java </span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">       append(str);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//StringBuilder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">       append(str);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过append方法中的ensureCapacityInternal方法可以触发扩容newCapacity获得新的容量大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value,</span><br><span class="line">                    newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//计划的扩容为 当前的容量*2+2.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            ? hugeCapacity(minCapacity)</span><br><span class="line">            : newCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/2022/05/14/thread/"/>
      <url>/2022/05/14/thread/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>新建(new)，就绪(runnable)，运行(running)，阻塞(block)，死亡(dead)</p><p>新建：使用new创建一个线程，此时仅由jvm为其分配内存，并初始化其成员变量的值</p><p>就绪：调用了start()方法，jvm为其创建方法调用栈和程序计数器</p><p>运行：就绪状态获取了cpu，开始执行run方法</p><p>阻塞：因某种原因放弃了cpu的使用，暂时停止运行，直到进入可运行状态</p><p>​    等到阻塞:运行o.wait()方法，JVM会把线程放入等待队列</p><p>   同步阻塞:运行的线程获取对象的同步锁时，若该锁被占用，则JVM把该线程放入锁池</p><p>​    其他阻塞:运行sleep()或t.join()或I&#x2F;O请求，JVM把该线程设为阻塞状态</p><p>死亡：正常结束或异常结束或调用线程的stop()方法（该方法易导致死锁）</p><p>Blocked和waiting的区别：线程可以通过notify进入waiting状态，进入后就等待唤醒才有获取cpu的时间片段来继续执行；blocked状态是无法进入同步方法&#x2F;代码完成的，因为无法获取相关联的锁</p><h1 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h1><p>继承Thead类</p><p>​自定义类继承Thread类，重写run()方法，创建线程对象并启动线程（start()方法，不是run；线程不能多次启动，只能执行一次）</p><p>实现Runnable接口</p><p>​自定义类实现Runnable接口，重写run()方法，创建自定义类对象，创建Thread类的对象，并把创建的自定义类的对象作为构造参数传递，启动线程</p><p>使用Callable和Future创建线程</p><p>​ 创建Callable接口的实现类，并实现call()方法，再创建该实现类的实例。使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值。使用FutureTask对象作为Thread对象的target创建并启动线程。调用FutrueTask对象的get()方法来获得子线程执行结束后的返回值</p><p>线程池实现</p><p>实现线程间共享数据：线程间共享对象，然后wait&#x2F;notify&#x2F;nofifyAll</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>  线程数小于核心线程数—&gt;核心线程数</p><p>  线程数大于核心线程数 —&gt;将多余的放入任务队列</p><p>  任务队列满了，就启动最大线程数</p><p>  最大线程数也达到后，就启动拒绝策略</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p> ThreadPoolExecutor.AbortPolicy：线程池默认的，即丢弃任务并抛出RejectedExecutionException异常</p><p>  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃</p><p>  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</p><p>  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务（不会丢弃任务，最后所有的任务都执行了，并不会抛出异常）</p><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>通过构造方法ThreadPoolExecutor</p><p><img src="/2022/05/14/thread/executors.png" alt="image-20220427110329004"></p><p>构造方法参数</p><p><img src="/2022/05/14/thread/threadPoolExecutor.png" alt="image-20220514145815343"></p><p>  CorePoolSize：核心线程数，默认状况下核心线程会一直存活；</p><p>  maximumPoolSize:线程池所能容纳的最大线程数。超过将被阻塞</p><p>  keepAliveTime:非核心线程的闲置时间超过时间，超过就会被回收</p><p>  unit：指定keepApliveTime的单位。但allowCoreThreadTimeOut设为true就无效</p><p>  workQueue：线程池的任务队列</p><p>  threadFactory：线程工厂，提供创建新线程时使用的工厂</p><p> handler：拒绝策略。当工作队列的任务和线程中的线程均到最大限制，就触发拒绝策略</p><h2 id="拒绝策略-1"><a href="#拒绝策略-1" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>  ThreadPoolExecutor.AbortPolicy：线程池默认的，即丢弃任务并抛出RejectedExecutionException异常</p><p>  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃</p><p>  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</p><p>  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务（不会丢弃任务，最后所有的任务都执行了，并不会抛出异常）</p><h2 id="execute-和submit"><a href="#execute-和submit" class="headerlink" title="execute()和submit()"></a>execute()和submit()</h2><p> Execute()用于提交不需要返回值的任务，so 不能判断线程池任务是否成功执行；Submit()用于提交需要返回值的任务</p><p>Execute是只能提交Runnable类型的任务，submit可以提交Runnable和Callable类型</p><p>Execute可以抛出异常，submit不排除异常（可以通过Future的get将任务执行时的异常抛出）</p><h1 id="为什么调用了start-后必须调用run-方法"><a href="#为什么调用了start-后必须调用run-方法" class="headerlink" title="为什么调用了start()后必须调用run()方法"></a>为什么调用了start()后必须调用run()方法</h1><p>new 一个 thread，线程进入新建状态，调用start()方法，会启动一个线程并使线程进入就绪状态，当分配时间片后就可以运行。Start会执行线程的准备工作，再自动执行run()。这才是真正的多线程工作。但直接run()，会吧其当成一个main线程下普通方法执行</p><p>总之：调用start()方法可启动线程并使线程进入就绪状态，直接run不会以多线程方式执行。但是执行start方法，线程不一定马上创建，因为底层是操作系统，是否创建线程需要看情况。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashmap</title>
      <link href="/2022/05/13/hashmap/"/>
      <url>/2022/05/13/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p><em><strong>主干是entry数组</strong></em>，每个entry保存了key和value。要添加键值对的时候会根据一个hash算法计算key后的值，再通过数组大小n-1&amp;hash值之后，得到一个数组的下标，然后往那个位置塞入这个entry。</p><p>默认大小16，负载因子0.75；当数量达到16* 0.75&#x3D;12时，就会扩容，扩容设计到rehash、复制数据等操作，很消耗性能，<em><strong>提前预估大小</strong></em></p><p>在JDK1.8以前：以数组和链表的形式组成。当数据越多，查询效率O(N)会越来越大。并且是<em><strong>先扩容再进行插入</strong></em></p><p>在JDK1.8后：引入了红黑树，链表元素超过阈值8时，链表转为红黑树；&lt;&#x3D;6时，树还原成链表。原因：红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；而且是先插入，再看size是否大于阈值，大于则扩容</p><p><img src="/2022/05/13/hashmap/jiegou.png" alt="image-20220427110202488"></p><h1 id="负载因子0-75"><a href="#负载因子0-75" class="headerlink" title="负载因子0.75"></a>负载因子0.75</h1><p>作用就是扩容机制的阈值。若是1.0，hashmap就会有大量冲突，底层的红黑树会很复杂，查询效率很低，空间利用率上去，时间效率降低；若是0.5，hash冲突减少，底层的链表长度和红黑树的高度会降低，时间效率提升，空间利用率降低。0.75就比较适中，空间利用率较高，避免比较多的冲突</p><h1 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h1><p>JDK1.7：</p><p>​判断当前数组是否要初始化</p><p>​    若key为空，则put一个空值进去</p><p>​通过hash()函数计算key哈希值，并得到其下标</p><p>​将hash、key、value等信息封装成一个entry对象</p><p>​根据当前下标位置上的节点情况，采用不同方法放置此节点（若key和传入的key相等则覆盖原来的key，反之增新增一个entry对象）。链表和红黑树的情况放置</p><p>JDK1.8:</p><p>​ 实际是调用putval方法，计算的key的hash值、key、value都放过去</p><p>判断底层的table表是否空，空就扩容到16；根据key计算hashcode，再通过hash值得到table表的下标索引；</p><p>若当前位置没有节点，就挂上去。</p><p>若有节点，先判断表里的key和输入的key或者内容是否相同，相同就赋值给e</p><p>​            若不相同，则判断是否是红黑树，若是则根据红黑树的原理加 </p><p>​                          也不是红黑树，则遍历链表，链表没有一个key相同，则放在最后；存在相同就覆盖</p><p>​    判断是否需要扩容</p><p>put源码1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//计算键的哈希值，放值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="comment">//链表数组；链表对象；           长度； 索引</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="comment">// tab是否为空或者长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 是：就执行扩容方法，数组的长度是扩容后的长度</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 获取tab的第i个元素，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 为空就赋值给第i个</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//就会有两种情况，hash值重复、碰撞了</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断key值是否重复了</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//就直接把上一个的值覆盖</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//判断tab[i]是否是红黑树 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据红黑树的性质插入值</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是红黑树就是链表，就开始遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//判断是否是最后一个或者是否是空，是空就插入进链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//判断链表的长度是否是大于8的，若是则转为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//key是否存在，存在就覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e不为空，就将e添加到tab中</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//当前的数量是否大于阈值，大于就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>流程图</p><p><img src="/2022/05/13/hashmap/put-liucheng.png" alt="image-20220513124451221"></p><h1 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h1><p>JDK1.7</p><p>​通过hash()计算key的哈希值，得到其下标，判断该位置是否是链表；不是就根据key、value的hashcode是否相等返回值。为链表就遍历直到 key和hashcode相等就返回。遍历完也没有就返回null</p><p>JDK1.8：</p><p>创建一个Node节点 e，调用getNode方法，传参计算的hash值和key值</p><p>  计算hashcode得到桶，桶空就返回null；判断桶的第一个位置的key是否为查询的key，是就返回value；不是就判断下一个是红黑树还是链表，就根据红黑树和链表进行查找（都是遍历，查找）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="comment">//判断是否为空，判断key对应的链表节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断链表头部元素是否是key值对应的真实value</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//链表是否含有下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//是否红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//根据红黑树的逻辑查找对应的value</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//根据hash和key值判断下一个元素是否是key值对应的真实value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//什么都没找到，就为null值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="与HashTable的比较"><a href="#与HashTable的比较" class="headerlink" title="与HashTable的比较"></a>与HashTable的比较</h1><table><thead><tr><th align="center">HashMap</th><th align="center">HashTable</th></tr></thead><tbody><tr><td align="center">继承的AbstractMap</td><td align="center">继承的Dictionary</td></tr><tr><td align="center">Null可以作为键（只有一个），也可以作为值（多个）</td><td align="center">不支持Null key和Null value</td></tr><tr><td align="center">线程不安全，多线程并发可能导致死锁。但也因此效率更高</td><td align="center">线程安全，因每个方法都有Synchronize方法</td></tr><tr><td align="center">默认初始化大小16，每次扩容为原来的2倍</td><td align="center">默认初始化大小11，每次扩容为原来的2*N+1</td></tr><tr><td align="center">计算hash值的方法不同</td><td align="center">计算hash值方法不同</td></tr><tr><td align="center">遍历方法的内部实现不同</td><td align="center">遍历内部实现不同</td></tr><tr><td align="center">没有contains方法</td><td align="center">有contains方法</td></tr></tbody></table><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手四次挥手基础</title>
      <link href="/2022/05/12/threefour/"/>
      <url>/2022/05/12/threefour/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>建立可靠的通信信道，也就是<em><strong>双方确认自己与对方发送与接收是正常的</strong></em></p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端随机初始化序号，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SEBT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><p><img src="/2022/05/12/threefour/woshou.png" alt="image-20220512090045815"></p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1），等待服务器发FIN报文；当服务器端确定数据（读到结束符EOF）已发送完成，则向客户端发FIN报文，延迟一段时间 再发ACK报文（处理一些最后的请求）；客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传）；服务器端收到ACK就关闭，客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/05/12/threefour/huishou.png" alt="image-20220512090215143"></p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以阻止重复历史连接的初始化（最主要，若是两次握手就不能判断）：若是历史连接，客户端发送的报文就是RST报文，反之则是ACK报文</p><p>同步双方的初始序列号：</p><p>避免资源浪费：  若服务端阻塞，发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：就没办法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</p><h1 id="握手是三次，挥手是四次"><a href="#握手是三次，挥手是四次" class="headerlink" title="握手是三次，挥手是四次"></a>握手是三次，挥手是四次</h1><p>当服务器端收到SYN连接请求报文后，可以直接发SYN+ACK报文，ACK是应答，SYN是同步的。关闭时，服务器端收到FIN时，有可能不会立即关闭SOCKET，所以只能先回一个ACK报文</p><p>但在抓包时，服务器接收到FIN后，服务器端同时要关闭链接，这样ACK和FIN一起发送节省了一个包。从抓包方面看，就是“三次挥手”</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB基础</title>
      <link href="/2022/05/11/InnoDB-1/"/>
      <url>/2022/05/11/InnoDB-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>现mysql 5.5后默认引擎，兼顾高可靠性和高性能性的通用存储引擎</p><p>若要对事务的完整性要求较高、要求实现并发的话，InnoDB有大优势；若频繁更新、删除操作也可，因为支持事务的提交和回滚</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>​    DML遵循ACID模型，支持<em><strong>事务</strong></em>。<em><strong>行级锁</strong></em>（加锁开销最大，加锁慢，会出现死锁），提供并发性能；支持<em><strong>外键</strong></em>FOREIGN KEY约束，保证数据的完整性和正确性。</p><p><em><strong>数据块要缓存</strong></em>；寻址要映射到块，再到行；要维护MVCC一致，所以Innodb在select的时候要维护的东西比较多</p><p>delete表的时是一行一行删除，而myisam则是先drop表，再重建表</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>聚集索引：</p><p>​将数据存储与索引放到一块，索引的叶子节点保存了行数据，必有且只有一个聚集索引。若有主键，主键即是；无主键用第一个唯一索引；若都没，会自动生成一个rowid作为隐藏的聚集索引。</p><p>索引结构：</p><p>​B+树：将所有数据都放在叶子节点，叶子节点形成一个列表，非叶子只存放键值，每个数据叶中的有效数据就多了，可以减少IO次数</p><p>​    因为相对于二叉树（会有左倾右倾的情况），B+树层级更少，搜索效率高</p><p>​    因为B树：无论叶子节点还是非叶子，都保存数据，所以存储值减少，指针就减少，要同样保存大量数据，只能增加树的高度，导致性能降低，要查找就要遍历整个树</p><p>​    Hash索引只支持等值匹配，不支持排序操作</p><p>二级索引：将数据与索引分开，索引结构的叶子节点关联的是对应的主键</p><h1 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h1><p>TableSpace(表空间)：可以看成Innodb逻辑存储的最高层，所有的数据都存放在表空间内</p><p>Segment（段）：分为数据段、索引段、回滚段。Innodb是索引组织表，数据段是B+树的叶子节点，索引段为B+的非叶子节点。段用来管理多个区</p><p>Extent（区）：表空间的单元结构，每个区默认1M。innodb引擎页大小为16K。连续的页组成</p><p>Page（页）：每个默认16KB，存储引擎磁盘管理的最小单位。数据页、undo页、系统页、事务数据页</p><p>Row（行）：存放的数据</p><h1 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h1><p>Buffer Pool（缓冲池）：</p><p>内存的速度弥补磁盘速度较慢对数据库性能的影响。</p><p>​数据库进度页的操作，先将从磁盘读到的页存放在缓冲池中，下次再读相同的页时，判断是否在缓冲池，若在就直接读取该页（命中），否在就读取磁盘上的页</p><p>​主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据。增删时，先操作缓冲池的页（没有，则从磁盘加载），再以Checkpoint的机制刷新到磁盘，也就<em><strong>减少磁盘IO，加快处理速度，提升了效率</strong></em>。</p><p>​    页为单位，默认16KB，索引页、数据页、undo页、插入缓冲、自适应哈希表页等。<em><strong>页与页之间形成了双向链表，同时使用LRU算法淘汰不常用的数据</strong></em>；每页的内部使用单向链表进行连接，因为数据是分散到Buffer Pool中，需要把这些分散的内存连接。</p><p><img src="/2022/05/11/InnoDB-1/22.png" alt="22"></p><h5 id="优化的LRU算法"><a href="#优化的LRU算法" class="headerlink" title="优化的LRU算法"></a>优化的LRU算法</h5><p>出现原因：因为实际生产中，会存在全表扫描的情况，若数据量较大，可能会将Buffer Pool中存下来的热点数据全部替换，性能就会极具下降。所以 <em><strong>缓冲池污染</strong></em></p><p>优化后的链表被分为两个部分，分别占用Buffer Pool的四分之三（New Sublist）和四分之一（Old Sublist）。</p><p>New Sublist：存放较为频繁的页</p><p>Old Sublist：存放不频繁的页，会在后续Buffer Pool剩余空间不足，或者有新的页加入时被移除     </p><p>Change Buffer（更改缓冲区）：执行DML时，操作的数据不在buffer pool中就不会操作磁盘，会将数据变更存在此处，在未来数据被读取时，再将数据合并恢复到缓冲池，再将合并后的数据写到磁盘</p><p>意义：可以在缓冲池中间进行合并处理，减少磁盘IO。因为二级索引一般非唯一，并且以相对随机的顺序插入二级索引。</p><p>Log Buffer（日志缓冲区）：用来保存要写入到磁盘中的log日志，默认16MB，日志缓冲区的日志可自己配置定期刷新到磁盘中。若日志缓冲区较大，就可存储更多Redo log，所以事务提交前就不需要将Redo Log刷入磁盘，只需要丢到Log Buffer。</p><p><em><strong>较大的Log Buffer可更好的支持事务的运行。若事务有大量更新、插入或删除行，可适当增加Log Buffer，可有效减少磁盘的IO操作</strong></em></p><p><img src="/2022/05/11/InnoDB-1/jiegou.png" alt="image-20220511134406227"></p><h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p>有多个内存块，可以认为这些内存块组成了一个大的内存池</p><p>负责： 维护所有进程；线程需要访问的多个内部数据结构</p><p>​缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前这这里缓存</p><p>​重做日志缓冲</p><p><img src="/2022/05/11/InnoDB-1/11.png" alt="1"></p><p>其中后台线程的主要作用是 负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下，Innodb能恢复到正常运行状态</p><h1 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h1><p>后台线程有多种，以完成不同的任务：</p><p>​Master Thread：核心，负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性（脏页的刷新，合并插入缓冲，UNDO页的回收）</p><p>​IO Thread：Innodb用AIO来处理IO请求，所以IO Thread负责将IO请求回调处理</p><p>​Pruge Thread：事务被提交后，undolog可能不需要，所以Pruge Thread来回收已经使用并分配的undo页</p><p>​Page Cleaner Thread：之前版本中脏页的刷新操作都放入到单独的线程中来完成。以减轻Masterr Thread的工作及用户查询线程的阻塞，提高性能</p><h1 id="保证ACID"><a href="#保证ACID" class="headerlink" title="保证ACID"></a>保证ACID</h1><p>Redo log（重做日志）：保证持久性。记录的是事务提交时数据页的物理修改。记录的是物理日志</p><p>​    重做日志缓冲：在内存   重做日志文件：在磁盘</p><p>​    当事务提交后把所有信息都存到日志文件，用于刷新脏页到磁盘；发生错误，进行数据恢复使用</p><p>​    在脏页信息发生错误时进行数据恢复，也就是持久性。</p><p>Undo log（回滚日志）：保证原子性。记录数据被修改前的操作。逻辑日志</p><p>​             作用：提供回滚和MVCC</p><p>​             Delete时，undo log里记录insert；update时，会记录反向的update语句 </p><p>​         当事务提交时不会立即删除，因为可能用于MVCC</p><p>​         采用段的方式进行管理和记录</p><h1 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h1><p>通过MVCC。</p><p>MVCC会给每行元祖加一些辅助字段，记录版本号和删除版本号，每一个事务启动都有一个唯一的递增的版本号。每开启一个事务，事务版本号就会递增</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized基础</title>
      <link href="/2022/05/10/synchronized-1/"/>
      <url>/2022/05/10/synchronized-1/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>解决多个线程之间访问资源的同步性，该关键字可保证修饰的方法或代码块在任意时刻只能有一个线程执行。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>JVM是通过进入、退出对象监视器来实现对方法、同步块的同步，而对象监视器的本质依赖于底层操作系统的互斥锁实现，能自动解锁</p><p>使用：</p><p>作用于普通方法时：锁的是对象的实例，即this对象，所谓的方法锁。进入同步代码块，要获得当前实例的锁</p><p>修饰静态方法时：锁的是这个类的所有class对象，即xxx.class  类锁。会作用于所有对象实例。进入同步代码要获得当前类对象的锁</p><p>修饰代码块（在方法中）时：锁的是synchronized(obj)，用户给定的对象，对象锁。进入同步代码要获得给定对象的锁</p><p><img src="/2022/05/10/synchronized-1/use.png" alt="use"></p><p>不能在类级别的（静态）代码块</p><p>特点：</p><p>  原子性、可见性（释放锁时，所有写入都会写回内存，获得锁就会从内存读取最新数据）、有序性；可重入性（对同一个线程在获得锁后，在调用其他需同样锁的代码时可直接调用）；重量级（底层是一个监视器对象完成。监视器锁的本质是依赖于操作系统的互斥锁实现）</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p> 偏向锁：Java6之后加的新锁。会偏向当前已经占领锁的线程 ，总是让一个线程多次获得。只在第一次请求锁时采用CAS操作并将锁对象的标记字段记录为当前线程地址。之后，持有该锁的线程无需加锁操作</p><p>​线程在进入同步代码块获得锁时，会检查对象头中是否存储了线程ID，若没有，判断一下偏向标志位是否为1，若不是1，说明该锁没有被任何线程获取，就CAS的方式替换mark word，将对象Mark word中的线程ID指向该线程，并将偏向标志位置位</p><p>  轻量锁：多个线程在不同时间请求同一把锁，即没有锁竞争。代码进入同步块时，若同步对象无锁，当前线程会在栈帧中创建一个锁记录区域，同时将锁对象头中的mark word拷贝到锁记录，再使用CAS将mark word 更新为指向锁记录的指针</p><p>  自旋锁：轻量级失败后，进行。基于大多数情况下，线程持有锁的时间都不会太长。因为线程间的切换操作系统需要从用户态到核心态，时间成本高。线程没有获取到锁的时候，虚拟机让线程做几个时间不太久的空循环（即自旋），循环后再次去尝试获取锁，若得到锁就进入临界区，反之就会被在操作系统层面挂起。<em><strong>提升了效率</strong></em>，最后没办法就只能升级为重量级锁</p><p>  锁消除：<em><strong>删除不必要的加锁</strong></em>。虚拟机在JIT编译时，扫描运行上下文，去除不可能存在共享资源竞争的锁。</p><p>  锁粗化：将多次连续的加锁、解锁操作合并为一次，将多个连续的锁拓展成一个更大的锁</p><p> 构造方法不能使用该关键字修饰，因为构造方法本身就线性安全</p><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p>是通过monitorenter获取锁，通过monitorexit释放锁</p><p>出现两个monitorexit：防止同步代码块中线程因异常退出，而锁没有释放，这必然会导致死锁。<em><strong>最后一个monitorexit保证在异常情况下，锁也可以得到释放，避免死锁</strong></em></p><h1 id="和Lock比较"><a href="#和Lock比较" class="headerlink" title="和Lock比较"></a>和Lock比较</h1><p>相同点：</p><p>  都是可重入锁；都保证了可见性和互斥性；都可以用于控制多线程对共享对象的访问</p><p>不同点</p><table><thead><tr><th align="center">ReetrantLock</th><th align="center">synchronized</th></tr></thead><tbody><tr><td align="center">默认也是非公平，但可以实现公平锁</td><td align="center">锁非公平</td></tr><tr><td align="center">只是lock接口下的实现类，是API层面的锁</td><td align="center">是JVM级别的锁</td></tr><tr><td align="center">显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作</td><td align="center">隐式获取锁和释放锁</td></tr><tr><td align="center">等待可中断、可实现公平锁、可实现选择性通知</td><td align="center"></td></tr><tr><td align="center">是可精确唤醒</td><td align="center">要么随机唤醒一个线程，要么唤醒所有等待的线程</td></tr></tbody></table><p>隐式锁和显示锁就是在使用的时候，使用者是否要手动写代码来控制获取锁和释放锁</p><p>公平锁实现：获取锁时，会先看sync队列是否在 等待获取资源的线程。没有就尝试获取锁，若有就将当前线程封装成node加入sync队列</p><p>非公平锁实现： 当线程争锁时，会进行一次CAS尝试获取锁，失败就进入acquir(1)函数，再尝试获取锁，若失败就将当前线程封装成node加入sync队列，就等前面线程执行完轮到自己</p><h1 id="和volatile比较"><a href="#和volatile比较" class="headerlink" title="和volatile比较"></a>和volatile比较</h1><table><thead><tr><th align="center">Synchronized</th><th align="center">Volatile</th></tr></thead><tbody><tr><td align="center">性能较差</td><td align="center">线程同步的轻量级实现，性能更好</td></tr><tr><td align="center">可以修饰方法以及代码块</td><td align="center">只能用于变量</td></tr><tr><td align="center">原子性、可见性都保证</td><td align="center">可保证数据的可见性，不保证原子性</td></tr><tr><td align="center">解决的是多线程之间访问资源的同步性</td><td align="center">解决变量在多个线程间的可见性</td></tr><tr><td align="center">因为是锁，可能造成线程阻塞</td><td align="center">不会线程阻塞</td></tr><tr><td align="center">标记的变量可以被编译器优化</td><td align="center">标记的变量不会被编译器优化</td></tr></tbody></table><p>内存屏障：是CPU的重排列指令引起的</p><p>Volatile通过内存屏障禁止指令重排序</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC基础</title>
      <link href="/2022/05/09/springmvc-1/"/>
      <url>/2022/05/09/springmvc-1/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><img src="/2022/05/09/springmvc-1/MVCP.png" alt="MVC" style="zoom:80%;"><p>是软件工程中的一种软件架构模式，它把软件系统分为模型、<strong>视图</strong>和<strong>控制器</strong>三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p>Model: 存储实体类。完成具体的业务操作，如：查询数据库，封装对象</p><p>View：页面展示（视图模式）。JSP、HTML等数据展示，用户可以看到的</p><p>Controller：页面逻辑处理，与用户监控。获取View的请求，调用模型将数据交给视图</p><p>流程：浏览器输入url后，就是发送请求到对象服务器，服务器根据url找到controller，控制器根据业务的逻辑从model获取数据，再把数据给特定的view，view就是客户看的到的结果</p><h2 id="为什么要使用MVC"><a href="#为什么要使用MVC" class="headerlink" title="为什么要使用MVC"></a>为什么要使用MVC</h2><p>可以使同一个程序使用不同的表现形式，若控制器反馈给模型的数据发生了变化，模型也要发生变化</p><p>因模型独立于视图，所以模型可以复用，模型可以独立的移植到别的地方使用</p><p>前后端代码分离，让项目开发的分工更加明确，提高了开发效率</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>一种基于java实现MVC设计模型的请求驱动类型的轻量级web框架。将负载的应用程序系统按照分层处理进行设计和规划，以降低开发难度，提供代码的可维护性。比其他的MVC框架更具有灵活性和拓展性</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/2022/05/09/springmvc-1/springmvcP.png" alt="springmvc"></p><p>框架主要就是围绕中央控制器dispatcherServlet展开</p><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p>前端控制器(dispatcherServlet)：接收请求，响应结果，将各个组件连通</p><p>处理器映射器：根据用户请求的URL找到对应的Handler</p><p>处理器适配器：按照HandlerAdapter的规则去编写，适配器才可以正确执行Handler</p><p>处理器：controller</p><p>视图解析器：视图的解析，根据视图逻辑名解析成真正的视图</p><p>视图：一个接口，支持不同的视图类型</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以支持各种视图技术，不局限于JSP</p><p>与spring框架继承</p><p>清晰的功能分配：前端控制器、请求到处理器映射、处理器适配器、视图解析器</p><p>支持各种请求资源的映射策略</p><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="建立Map-lt-urls-controller-gt-的关系"><a href="#建立Map-lt-urls-controller-gt-的关系" class="headerlink" title="建立Map&lt;urls,controller&gt;的关系"></a>建立Map&lt;urls,controller&gt;的关系</h3><p>入口类就是ApplicationObjectSupport的setApplicationContext方法，核心就是initApplicationContext</p><p><img src="/2022/05/09/springmvc-1/set.png" alt="image-20220509135611735"></p><p>AbstractDetectingUrlHandlerMapping实现了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException &#123;</span><br><span class="line">        <span class="built_in">super</span>.initApplicationContext();</span><br><span class="line">        detectHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">　　  * 建立当前ApplicationContext中的所有controller和url的对应关系</span></span><br><span class="line"><span class="comment">　　　 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">         <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">　　　　 <span class="comment">// 获取ApplicationContext容器中所有bean的Name</span></span><br><span class="line">       String[] beanNames = <span class="built_in">this</span>.detectHandlersInAncestorContexts?</span><br><span class="line">           BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class):</span><br><span class="line">           applicationContext.getBeanNamesForType(Object.class);</span><br><span class="line"> String[] var3 = beanNames;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> beanNames.length;</span><br><span class="line">        <span class="comment">// 遍历beanNames,并找到这些bean对应的url</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">             <span class="comment">// 找bean上的所有url(controller上的url+方法上的url),该方法由对应的子类实现</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">            String[] urls = <span class="built_in">this</span>.determineUrlsForHandler(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">                  <span class="comment">// 保存urls和beanName的对应关系,put it to Map&lt;urls,beanName&gt;,该方法在父类AbstractUrlHandlerMapping中实现</span></span><br><span class="line">                <span class="built_in">this</span>.registerHandler(urls, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled() &amp;&amp; !<span class="built_in">this</span>.getHandlerMap().isEmpty() || <span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.getHandlerMap().size() + <span class="string">&quot; mappings in &quot;</span> + <span class="built_in">this</span>.formatMappingName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           </span><br><span class="line">    <span class="comment">/** 获取controller中所有方法的url,由子类实现,典型的模板模式 **/</span></span><br><span class="line">　　<span class="keyword">protected</span> <span class="keyword">abstract</span> String[] determineUrlsForHandler(String var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后的determineUrlsForHandler是获取每个controller的url，不同子类不同的实现。此处分析BeanNameUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的url</span></span><br><span class="line"><span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">    <span class="comment">//用来保存url的容器</span></span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//判断beanName哪些是以&quot;/&quot;开头</span></span><br><span class="line">    <span class="keyword">if</span> (beanName.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        urls.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliases = <span class="built_in">this</span>.obtainApplicationContext().getAliases(beanName);</span><br><span class="line">    String[] var4 = aliases;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> aliases.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">        <span class="keyword">if</span> (alias.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            urls.add(alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br></pre></td></tr></table></figure><p>AbstractUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPaths, <span class="string">&quot;URL path array must not be null&quot;</span>);</span><br><span class="line">    String[] var3 = urlPaths;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> urlPaths.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">        <span class="built_in">this</span>.registerHandler((String)urlPath, (Object)beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPath, <span class="string">&quot;URL path must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(handler, <span class="string">&quot;Handler object must not be null&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedHandler</span> <span class="operator">=</span> handler;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">//将handler转为beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String)handler;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">            <span class="comment">//根据beanName获取bean，一对一对应到controller类</span></span><br><span class="line">            resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot map &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler) + <span class="string">&quot; to URL path [&quot;</span> + urlPath + <span class="string">&quot;]: There is already &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(mappedHandler) + <span class="string">&quot; mapped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Root mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setRootHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Default mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setDefaultHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//最终将结果put到map集合中，建立一一对应的关系</span></span><br><span class="line">        <span class="built_in">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Mapped [&quot;</span> + urlPath + <span class="string">&quot;] onto &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据url找到controller里处理请求方法"><a href="#根据url找到controller里处理请求方法" class="headerlink" title="根据url找到controller里处理请求方法"></a>根据url找到controller里处理请求方法</h3><p>因为找请求方法，所以看dispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//异步处理</span></span><br><span class="line">        <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//定义空的ModelAndView变量</span></span><br><span class="line">                <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//检查是否是文件上传的请求</span></span><br><span class="line">                    processedRequest = <span class="built_in">this</span>.checkMultipart(request);</span><br><span class="line">                    multipartRequestParsed = processedRequest != request;</span><br><span class="line">                    <span class="comment">//取得处理当前请求的controller（handler处理器），返回HandlerExecutionChain对象</span></span><br><span class="line">                    mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">                    <span class="comment">//handler不能为空</span></span><br><span class="line">                    <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//不同的controller类型交给不同的适配器</span></span><br><span class="line">                    <span class="comment">//若是bean，mappedHandler.getHandler()返回的对象</span></span><br><span class="line">                    <span class="comment">//若是method，返回的就是一个方法</span></span><br><span class="line">                    <span class="comment">//获取的就是handlerAdapter，方便后续找到对应的controller</span></span><br><span class="line">                    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">                    <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                        <span class="comment">//处理last-modified请求头</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">  <span class="comment">//拦截器预处理</span></span><br><span class="line">                    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">       <span class="comment">//通过适配器，处理请求</span></span><br><span class="line">  <span class="comment">//实际的处理器处理请求，返回结果视图对象</span></span><br><span class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">   <span class="comment">//结果视图对象处理</span></span><br><span class="line">                    <span class="built_in">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                    <span class="comment">//拦截器后置处理</span></span><br><span class="line">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">                    <span class="comment">//后面就是各种报错的判断反馈处理</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                    dispatchException = var20;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, var21);</span><br><span class="line">                <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, var23));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                <span class="built_in">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="与Struts2的区别"><a href="#与Struts2的区别" class="headerlink" title="与Struts2的区别"></a>与Struts2的区别</h2><table><thead><tr><th align="center">Struts2</th><th align="center">SpringMVC</th></tr></thead><tbody><tr><td align="center">filter为入口</td><td align="center">前端控制为入口</td></tr><tr><td align="center">基于类开发，传递参数通过类的属性，只能设置多例</td><td align="center">基于方法开发（一个url一个方法），请求参数传递到方法形参，可单例可多例</td></tr><tr><td align="center">值栈存储请求和响应的数据，OGNL存取数据</td><td align="center">通过参数解析器将request请求内容解析，给方法形参赋值，将数据视图封装成ModelAndView</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础</title>
      <link href="/2022/05/08/spring-1/"/>
      <url>/2022/05/08/spring-1/</url>
      
        <content type="html"><![CDATA[<h1 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h1><p><img src="/2022/05/08/spring-1/spring-model.png" alt="主要模块"></p><p>主要被分成：数据访问&#x2F;继承、web、AOP（面向切面编程）、工具、消息、测试</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>创建方式：构造器创建Bean<bean>标签、Setter方法、静态工厂方法创建bean、实例工厂方法创建bean</bean></p><p>获取bean：在初始化的时候保存ApplicationContext对象、通过Spring提供的工具类获取ApplicationContext对象、实现ApplicationContextAware接口、继承自抽象类ApplicationObjectSupport</p><p>配置Bean方式：基于XML配置、基于注解的配置、基于java的配置</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>默认下，spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例；所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为singleton，是所有bean的默认作用域</p><table><thead><tr><th align="center">类别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">在SpringIoc容器中仅存在一个bean实例,bean以单实例方式存在</td></tr><tr><td align="center">prototype</td><td align="center">每次调用getbean() 都将返回一个新的实例</td></tr><tr><td align="center">request</td><td align="center">每次Http请求都会创建一个新的bean,该作用域仅适合于WebApplicationContext 环境</td></tr><tr><td align="center">session</td><td align="center">同一个Http Session 共享一个bean,不同的Http Session使用不同的bean.该作用域仅适合 WebApplicationContext 环境</td></tr></tbody></table><p>singleton 默认值 当Ioc容器一创建就会创建bean实例,而且是单例的,每次得到的都是同一个<br>prototype 原型的 当Ioc容器一创建不实例化该bean,每次调用getBean() 方法时再实例化该bean,而且每次调用都是不同的bean实例<br>request 每次请求实例化一个bean<br>session 在一次会话中共享一个bean</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="创建前准备"><a href="#创建前准备" class="headerlink" title="创建前准备"></a>创建前准备</h3><p>​bean在开始加载之前，从上下文和配置中解析并查找bean有关的一些扩展实现。比如：init-method：容器在初始化时调用的；destroy-method：容器在销毁bean的时候会调用；BeanFactoryPostProcessor：加载过程中的前置、后置的一些处理拓展实现。</p><p>​这些类或配置时提供给开发者去实现bean加载过程中的拓展，在很多与spring集成的中间件常见。比如：Dubbo</p><h3 id="创建实例化"><a href="#创建实例化" class="headerlink" title="创建实例化"></a>创建实例化</h3><p>​通过反射去创建bean的实例对象，并且扫描和解析bean声明的一些属性</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>​若被实例化的bean存在依赖其他bean对象的一些情况，则需要对这些依赖的bean进行对象注入。比如：@Autowired、@Setter这样的配置形式。</p><p>​还会触发一些拓展的调用。比如：BeanPostProcessors：去实现bean初始化前后的拓展回调；</p><h3 id="容器缓存"><a href="#容器缓存" class="headerlink" title="容器缓存"></a>容器缓存</h3><p>​把bean缓存到容器里面以及spring的缓存中；这个阶段的bean就能被开发者拿去用。</p><h3 id="销毁实例"><a href="#销毁实例" class="headerlink" title="销毁实例"></a>销毁实例</h3><p>​当spring的应用上下文被关闭的时候，上下文中所有的bean会被销毁。若bean实现了诸如DisposableBean接口或者配置了destory-method属性的一些方法会在该阶段调用</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p> 一种设计思想，控制反转，<em><strong>将设计好的对象交给容器控制</strong></em>。在调用某个类时，容器会实例化，即容器控制对象的创建。</p><p>  IOC容器实例化过程中，一般不包含bean的依赖注入，bean的注册和依赖注入是两个过程，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xml中配置，在容器初始化的时候，这个bean就完成了初始化。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程基于IOC。简单说就是将部分重复的代码抽取出来，需要执行的时候用动态代理价技术。不修改代码进行功能增强。</p><p> 降低了耦合度，提高了程序的可重用性，同时提高了开发效率，实现业务和切入类的解耦</p><p>底层使用动态代理</p><p>与OOP相比，一个是横向一个纵向在</p><h1 id="涉及到的设计模式"><a href="#涉及到的设计模式" class="headerlink" title="涉及到的设计模式"></a>涉及到的设计模式</h1><p>IOC：工厂模式，单例模式，装饰器模式</p><p>AOP：代理模式，观察者模式（监听）</p><p>MVC:委派模式，适配者模式</p><p>JDBC：模板方法模式（RestTemplate）</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>有了IOC容器，对象间的依赖关系交给了spring，更专注业务逻辑代码</p><p>有AOP和OOP，很多功能更方便简单使用</p><p>简化开发</p><p>方便测试</p><p>声明式事务管理</p><p>减低API开发难度</p><p>低耦合</p><p>方便集成其他框架</p><h1 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h1><p>spring里面的核心功能是IOC容器，本质就是bean的容器、工厂，能去根据XML中声明的bean的配置去进行加载和初始化，然后beanFactory去生成我们所需要的各种各样的一个bean。</p><p>BeanFacory：是所有Spring Bean容器的顶级接口，为Spring的容器定义了一套规范，并提供像getBean等方法从容器中获取指定的Bean的实例；在产生bean的同时，提供解决bean之间依赖注入的能力；</p><p>FactoryBean：是一个工厂bean，接口，主要功能是去动态生成某一类型的bean的一个实例，即可以自定义一个bean并加载到IOC容器里，里面有个方法getObject就是实现动态构建bean的一个过程。OpenFeign组件客户端代理就是使用了FactoryBean实现</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2022/05/07/ThreadLocal-1/"/>
      <url>/2022/05/07/ThreadLocal-1/</url>
      
        <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/05/07/ThreadLocal-1/first.png" alt="结构"></p><p>线程本地存储机制，数据缓存到线程内部</p><p>当thread销毁时，threadLocal也会随之销毁，减少内存的使用</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>Synchronized用于线程间的数据共享，ThreadLocal用于<em><strong>数据隔离</strong></em>，最适合多实例的对象的访问。</p><p>保存该线程变量，这样每个线程都有自己的数据，就做到了不同线程间数据的隔离。即多线程环境下，对于共享变量访问的安全性。</p><p>为每个使用该变量的线程提供独立的变量副本，所以<em><strong>每个线程都可独立改变自己副本</strong></em>，而不影响其他线程对应的副本，从而没必要对该变量进行同步了。</p><p>  提供了线程安全的共享对象，在多线程中，可把不安全的变量封装进ThreadLocal</p><p>创建一个TheadLocal变量，那么访问这个变量的每个线程都会有这个线程的本地副本。</p><p><em><strong>解决了线程安全问题，避免了多线程竞争锁的开销</strong></em></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>连接ThreadLocalMap和Thread，来处理Thread的ThreadLocalMap属性</p><p>  ThreadLocalMap用来存储数据，类似于hashmap，存储ThreadLocal为key，需要隔 离的数据为value的Entry键值对数据结构。可以理解：ThreadLocal只是ThreadLocalMap封装，传递了变量值。ThreadLocalMap&lt;ThreadLocal,数据&gt;</p><p>  ThreadLocalMap是ThreadLocal内部类，由ThreadLocal创建，ThreadLocal本身就是一个代理工具</p><p>  每个thread对象都会存一个theadLocalMap</p><p>  这样不容易产生内存泄露</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//   获取当前线程对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//再获取该线程下的threadlocalmap对象map</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)<span class="comment">//  Map若存在，则将参数设置到Map中</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);<span class="comment">// 否则就创建map（createMap(Thread t,T value)）并设置初始值</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//首先获取线程</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//根据线程获取map；</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">// 若map不为空，则在map下以threadlocal的引用作为key来在map中获取对应的entry e；</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;<span class="comment">//若e不为mull，则返回e.value；</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();<span class="comment">//Map为空或e为空，则initialValue函数获取初始值value，用threadlocal的引用和value作为键和值创建一个新map</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());<span class="comment">//获取当前线程，根据线程获取一个map；</span></span><br><span class="line">         <span class="keyword">if</span> (m != <span class="literal">null</span>)<span class="comment">//若map部位空则移除当前threadlocal对象对应的entry</span></span><br><span class="line">             m.remove(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="InitialValue"><a href="#InitialValue" class="headerlink" title="InitialValue"></a>InitialValue</h2><p>默认就返回null。延迟方法可重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">      SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">          <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> supplier.get();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>ThreadLocal没有被外部强引用的情况下，垃圾回收时key就会被清理，value不会，因为前者为弱引用，后者为强引用。</p><p>在线程池中使用ThreadLocal可能内存泄露：在线程池中线程的存活时间太长，往往都是和程序同生共死，这样thread持有的ThreadLocalMap一直不会被回收，又因为是弱引用，所以ThreadLocal结束生命就可以被回收。而Entry中的value被Entry强引用，所以机制value生命周期结束，也不会被回收，导致内存泄露</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>每一个线程分配一个和JDBC连接Connection，保证每个线程的都在各自的Coonection上进行数据库的操作</p><p><em><strong>变量在线程内部共享，线程间无关</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> TheadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2022/05/06/redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/06/redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="redis的基本性质"><a href="#redis的基本性质" class="headerlink" title="redis的基本性质"></a>redis的基本性质</h1><p>完全基于内存，绝大部分请求是纯粹的内存操作</p><p>基于Reactor模式开发的网络时间处理器单多线程</p><p>C语言写的</p><p>Redis是单线程（6.0以前），利用<em><strong>队列技术将并发访问变为了串行访问，消除了传统数据库串行控制的开销。</strong></em></p><p>​因为线程切换而消耗CPU，而CPU不是redis的瓶颈。所以，单线程和多线程效果都差不多，还不如单线程来减少切换的消耗，单线程就没必要的上下文切换和竞争条件；易于维护</p><p>单线程的瓶颈主要在网络IO操作</p><p>6.0后redis引入多线程，为了提高网络IO读写性能。因为单线程的瓶颈，若大量键值删除，短时间删不完，那么单线程就会阻塞后边的操作</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载使用</p><p>提供各种数据结构进行存储</p><p>支持数据的备份</p><p>高性能、高并发，所以redis作为缓存。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://xiaoerbutingbu.github.io/2022/08/11/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>速度快，支持丰富数据类型，支持事务、<em><strong>指令操作</strong></em>都是原子性的</p><p>容量收到物理内存限制，只适合较小数据量的高性能操作和运算上；</p><p>难在线扩容，在集群容量达到上限时在线扩容很复杂，所以运维人员在保证足够的空间</p><h1 id="redis6-0以后为什么引入多线程？"><a href="#redis6-0以后为什么引入多线程？" class="headerlink" title="redis6.0以后为什么引入多线程？"></a>redis6.0以后为什么引入多线程？</h1><p>多线程的情况下，线程切换换消耗CPU，<em><strong>CPU并不是redis的瓶颈</strong></em>。</p><p>引入多线程<em><strong>主要是为了提高网络IO读写性能</strong></em>：多线程只是在网络数据的读写这类耗时操作上使用，而执行命令仍是单线程顺序执行</p><p>redis将所有数据放在了内存中，对于小数据包，redis服务器已经处理80000到100000QPS，已经是极限，对大部分公司已经够用了</p><p>从redis自身角度，因为读写网络read&#x2F;write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p><ul><li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</li><li>使用多线程充分利用多核，典型的实现比如 Memcached</li></ul><p>小总结：</p><p>​可以充分利用服务器CPU资源，目前主线程只有一个核</p><p>​多线程可以分摊redis同步IO读写消耗</p><h1 id="redis6-0关于多线程"><a href="#redis6-0关于多线程" class="headerlink" title="redis6.0关于多线程"></a>redis6.0关于多线程</h1><p><em><strong>多线程默认是禁用的，只使用主线程</strong></em>。所以需要修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>仅仅是开启多线程是不生效，修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核使用2/3个线程，8核使设置6个线程</span></span><br></pre></td></tr></table></figure><p>实现机制：</p><p>​主线程负责接收建立连接请求，获取socket放入全局等待处理读处理队列</p><p>​主线程处理完读时间后，通过RR（Round Robin）将这些连接分配给这些IO线程</p><p>​主线程阻塞等待IO线程读取socket完毕</p><p>​主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但不执行</p><p>​主线程阻塞等待IO线程将数据收回，写socket完毕</p><p>​解除绑定，清空等待队列</p><h1 id="开启多线程后，是否有线程并发安全问题"><a href="#开启多线程后，是否有线程并发安全问题" class="headerlink" title="开启多线程后，是否有线程并发安全问题"></a>开启多线程后，是否有线程并发安全问题</h1><p>Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p><h1 id="redis经常提到IO多路复用，怎么理解？"><a href="#redis经常提到IO多路复用，怎么理解？" class="headerlink" title="redis经常提到IO多路复用，怎么理解？"></a>redis经常提到IO多路复用，怎么理解？</h1><p>这是IO模型的一种，即经典的Reactor设计模式，有时也称为异步阻塞IO。</p><p>多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>[Redis 6.0 新特性-多线程连环13问！](<a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis 6.0 新特性-多线程连环13问！ (qq.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内存淘汰</title>
      <link href="/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
      <url>/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内存淘汰： 当内存的使用率到达了maxMemory的上限的时候，进行内存的释放。</p><p>redis提供了许多内存淘汰算法，主要分为4种：</p><p>​随机：随机移除某个key</p><p>​TTL算法：，在设置了过期时间的键里面去找更早过期时间的key进行有限的移除</p><p>​LRU算法：去移除最近很少使用的key。</p><p>​LFU算法：与LRU算法类似                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h1 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h1><p>​LRU算法会维护一个大小为16的侯选池，里面的数据会随着时间排序，每一次随机抽取5个key放入侯选池，当侯选池满了后，访问的时间间隔最大的key就从侯选池里面取出来并淘汰。这样就可以把真实的最少访问的key从内存里面淘汰。</p><p>​存在问题：若一个key很长时间没有访问，突然偶尔被访问，那LRU就会认为这是一个热点key就不会被淘汰。</p><h1 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h1><p>​相比于LRU算法，LFU增加了访问频率来统计数据的热点情况。</p><p>​主要设置是使用了两个双向链表形成了一个二维的双向链表，一个链表来保存访问频率，另一个保存访问频率相同的所有元素。当添加元素的时候，访问频次默认为1，找到相同频次的节点，然后添加到相同的频率节点对应的双向链表的头部，当元素被访问的时候，就增加对应key的访问频率，并把当前访问的节点移动到下一个频次的节点。</p><p>​可能出现某个数据前期的访问次数很多，但后续不再使用。若单纯按照这样的一个访问频次来进行淘汰的话，那这个key就很难被淘汰掉。该算法通过使用频率和上次访问的时间来标记数据的热度。若某个数据有读和写，那增加访问的频率；若一段时间内该数据没有读写，那就减少访问频率。</p><p>​经过LFU算法改进后就可以实现真正达到非热点数据的淘汰</p><p>​缺点：与LRU相比，增加了访问频次的维护以及实现的复杂度要比LRU更高</p><h1 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h1><p>定时策略：创建一个定时器，过期时间到，逻辑对键的删除</p><p>​对内存友好而CPU时间不好，redis还没有使用</p><p>惰性删除：过期键不管，每次从键空间获取键的时候，该键过期了删了，没过期就返回该键</p><p>​对内存不友好而CPU时间友好</p><p>定期删除：每隔一段时间就检查，删除过期键，由算法决定</p><p>​较为折中</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis和数据库的数据一致性</title>
      <link href="/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>redis用来实现应用和数据库之间读操作的缓存层，主要目的是去减少数据库的IO，并提升数据库的IO性能。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>当应用程序需要读取某个数据的时候，首先会尝试去redis里面加载，若命中就直接返回，反之就去数据库里面查询，查询到数据后再把数据缓存到redis里面。</p><h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>即一份数据同时保存在redis和数据库里面，当数据发生变化的时候需要同时更新数据库和redis，由于更新操作具有先后顺序且redis不像数据库中的多表事务操作（满足ACID的特性），所以会出现数据一致性的问题</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h2><p>此情况下，若缓存更新失败，就会导致数据库和redis的数据不一样。</p><p>线程1连接到数据库，读取到了数据A，此时线程1停顿，线程2连接到数据库将数据A更改为数据B，并将B写入了redis完成了线程2的操作，然后线程1将读取到的数据A写入redis即把B覆盖。此时，数据库里面的数据为B，而redis里的数据为A</p><h2 id="先删除缓存后更新数据库"><a href="#先删除缓存后更新数据库" class="headerlink" title="先删除缓存后更新数据库"></a>先删除缓存后更新数据库</h2><p>理想情况下是应用下次访问redis的时候，发现redis里面是空值，就会从数据库里加载并保存至数据库，理论上可行。但在极端情况下，由于删除redis和更新数据库的两个操作均不是原子操作，所以还是会出现数据不一致</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>基于RocketMQ的可靠性消息通信实现数据的最终一致性</p><p>通过Canal组件监控数据库里面的binlog的日志，把更新后的数据同步到redis里面</p><p>采用延时双删的原则：先淘汰缓存，再写数据库，休眠一会儿后再淘汰缓存。因为存在了延时时间，目的就是为了先把查到的数据写入redis再删redis</p><h1 id="redis的线程安全问题"><a href="#redis的线程安全问题" class="headerlink" title="redis的线程安全问题"></a>redis的线程安全问题</h1><h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h2><p>是一个线程安全的K-V数据库，即在redis-server端去执行指令的时候不要任何的同步机制，不存在任何线程安全的问题，虽然6.0之后增加了多线程的模型，但该模型只是去处理网络的IO事件，对于指令的执行还是采用主线程来处理的，所以并不会存在多个线程同时去执行操作指令的情况。</p><p>没有采用多线程执行指令：</p><p>​本身可能出现的性能瓶颈点无非是网络IO、CPU、内存，但是CPU不是redis的瓶颈，所以就没必要采用多线程执行指令</p><p>​若采用多线程，那么所有指令就必须要考虑线程安全的问题，也就需要加锁来解决，这种方式反而会对性能造成更大的影响</p><h2 id="redis-client"><a href="#redis-client" class="headerlink" title="redis-client"></a>redis-client</h2><p>里面的指令操作都是原子性，但若有多个redis客户端同时执行多个指令就无法保证原子性。</p><p>比如：两个client同时去获取server上的key1，同时去修改和写入，因为多线程下原子性不能保证以及多进程的情况下共享资源访问的竞争问题也不能保证数据安全性</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>尽可能使用redis里面的原子指令</p><p>对个客户端的资源访问加锁</p><p>通过lua脚本实现多个指令的操作，去满足原子性</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis理解和分布式锁</title>
      <link href="/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="对Redis的理解"><a href="#对Redis的理解" class="headerlink" title="对Redis的理解"></a>对Redis的理解</h1><p>redis是一个高性能的基于Key-Value结构存储的NoSQL开源数据库，绝大部分都采用redis实现分布式缓存，从而去提高数据的的检索效率。</p><p>redis流行的原因：</p><p>​1 基于内存存储，在进行数据IO操作的时候能达到很高的QPS（官方给的10w）</p><p>​2 提供了非常丰富的数据存储结构，比如String、list、hash、set、zset</p><p>​3 底层采用单线程实现数据的IO，所以在数据算法层面不需要考虑并发安全性，从而让底层算法的时间复杂度基本都是常量复杂度</p><p>​4 虽然是内存存储，但却可以支持持久化，避免因服务器故障而导致的数据丢失问题</p><p>综上，redis一般是用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响，redis还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供了解决方案</p><h1 id="实现分布式锁中-zookeeper和Redis的比较"><a href="#实现分布式锁中-zookeeper和Redis的比较" class="headerlink" title="实现分布式锁中 zookeeper和Redis的比较"></a>实现分布式锁中 zookeeper和Redis的比较</h1><p>分布式锁：核心目的是为了解决在同一个时刻有多个进程或线程来访问共享资源所带来的安全性问题。锁又分为共享锁（在同一个时刻允许多个线程或进程访问共享资源，适用于幂等性场景，从而避免重复加锁的性能开销）和排它锁（同一个时刻只允许一个线程或进程访问该共享资源，适用于非幂等性场景）</p><p>实现分布式锁的最常用中间件就是zookeeper和Redis</p><p>Redis实现分布式锁方式：</p><p>​1 基于Redis本身提供的指令：SET key value NX PX millisecounds。设置key的时候，若key已经存在与服务器上了会返回一个0，表示无法设置，否则就返回1表示设置成功。程序就根据0和1判断状态，从而表示去获得锁</p><p>​2 基于redission客户端实现，redission提供了分布式锁的封装方法，只需要调用封装好的api，<em><strong>lock()</strong></em> 和 ***unlock()***方法，就可以实现锁的抢占和释放。redission的所有指令都是通过lua脚本去实现，该脚本可以保证所有执行指令的原则性。另外，redission提供了一个watchdog，它会在我们获取锁后每隔10s去把key的时间延长，就避免锁的过期。</p><p>redis的缺点：</p><p>​在获得锁的时候，很简单，若获取不到锁就一直去尝试获取，会影响程序性能</p><p>​是一个&#x3D;&#x3D;AP模型&#x3D;&#x3D;，也就是可用性模型，集群模式中，存在数据一致性，会导致锁出现问题。即使使用了redlock算法实现分布式锁，但在某些复杂的场景下也不能保证锁的一定可用</p><p>zookeeper实现分布式锁：</p><p>​1 有序节点实现：每个线程或进程都到zookeeper上的<em><strong>lock</strong></em>目录下去创建一个临时有序节点，去表示抢占锁，所有创建的节点都会按照先后顺序生成带有有序编号的节点，线程创建节点后获取<em><strong>lock</strong></em>节点下的所有子节点，判断当前线程创建的节点是否是所有子节点里序号最小的，若是就获取锁成功。反之就需要对当前线程的前一个节点建立事件监听，当被监听的节点释放后，则触发回调告诉当前线程从而再次去尝试抢占锁</p><p> 使用redis还是比较常见，因为实际开发中极端情况少，redis本身的性能又高，在高并发中比较合适。</p><p>zookeeper是一个分布的协调组件，是&#x3D;&#x3D;一个CP模型&#x3D;&#x3D;所以更适合实现分布式锁。当获取不到锁就添加监听器，不用一直获取，就减少了性能。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java不可变类</title>
      <link href="/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/"/>
      <url>/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p><strong>不可变类</strong>：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p><p><strong>可变类</strong>：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><h1 id="不可变类优点"><a href="#不可变类优点" class="headerlink" title="不可变类优点"></a>不可变类优点</h1><p>主要有两点，效率和安全</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>当一个对象是不可变的，那么需要拷贝这个对象的内容时，就不用复制它的本身而只是复制它的地址，复制地址（通常一个指针的大小）只需要很小的内存空间，具有非常高的效率。同时，对于引用该对象的其他变量也不会造成影响。而且保证了hashCode 的唯一性，因此可以放心地进行缓存而不必每次重新计算新的哈希码。而哈希码被频繁地使用, 比如在hashMap 等容器中。将hashCode 缓存可以提高以不变类实例为key的容器的性能。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>是指线程安全</p><p>在多线程情况下，一个可变对象的值很可能被其他进程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况同时省去了同步加锁等过程，因此不可变类是线程安全的。</p><p>当然，不可变类也有缺点：不可变类的&#x3D;&#x3D;每一次“改变”都会产生新的对象，因此在使用中不可避免的会产生很多垃圾&#x3D;&#x3D;</p><h1 id="不可变类的设计"><a href="#不可变类的设计" class="headerlink" title="不可变类的设计"></a>不可变类的设计</h1><p>类使用final修饰，保证类不被继承</p><p>所有成员变量都被private和final修饰</p><p>不提供成员变量的setter方法</p><p>通过构造器初始化所有成员，进行深拷贝</p><p>在getter方法中，不直接返回对象本身，而是克隆对象并返回对象的拷贝内容</p><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>String源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="type">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="type">char</span> result[] = <span class="keyword">new</span> <span class="title class_">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可观察到</p><p>​String类被final修饰，就不能被继承</p><p>​内部变量所有成员都设置为私有变量</p><p>​没有setter方法</p><p>​&#x3D;&#x3D;传入可变数组时，进行copy而不是直接将数组赋值给内部变量&#x3D;&#x3D;</p><p>​获取value时不是直接返回对象引用，而是返回对象的copy</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​String不能被修改，让JVM可实现字符串常量池，该常量池可在运行时节约内存空间，不同字符串指向相同自变量时都指向字符串常量池中的同一对象，&#x3D;&#x3D;即提升了性能，节约了资源&#x3D;&#x3D;，更因为不可变性保证了线程安全</p><h2 id="String是否真的不可变"><a href="#String是否真的不可变" class="headerlink" title="String是否真的不可变"></a>String是否真的不可变</h2><p>虽然String对象将value设置为final,并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">char</span>[] valueCharArr = (<span class="type">char</span>[]) valueField.get(str);</span><br><span class="line">            valueCharArr[<span class="number">0</span>] = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">            valueField.set(str, <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = ABCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = GBCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = 12</span><br><span class="line">hashCode = 2001986</span><br></pre></td></tr></table></figure><p>由打印结果可知，字符串str的值发生了改变，哈希值没有发生变化。即通过反射可以修改“不可变”对象</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不可变类是实例创建后就不可以改变成员遍历的值。这种特性使得不可变类提供了线程安全的特性但同时也带来了对象创建的开销，每更改一个属性都是重新创建一个新的对象。JDK内部也提供了很多不可变类如Integer、Double、String等。</p><p>String的不可变特性主要为了满足<em><strong>常量池的使用</strong></em>、<em><strong>线程安全</strong></em>、<em><strong>类加载</strong></em>、<em><strong>提高运行速度</strong></em>、<em><strong>避免网络问题</strong></em>。合理使用不可变类可以带来极大的好处。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不可变类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
