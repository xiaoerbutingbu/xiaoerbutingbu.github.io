<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hashmap</title>
      <link href="/2022/05/13/hashmap/"/>
      <url>/2022/05/13/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p><em><strong>主干是entry数组</strong></em>，每个entry保存了key和value。要添加键值对的时候会根据一个hash算法计算key后的值，再通过数组大小n-1&amp;hash值之后，得到一个数组的下标，然后往那个位置塞入这个entry。</p><p>默认大小16，负载因子0.75；当数量达到16* 0.75&#x3D;12时，就会扩容，扩容设计到rehash、复制数据等操作，很消耗性能，<em><strong>提前预估大小</strong></em></p><p>在JDK1.8以前：以数组和链表的形式组成。当数据越多，查询效率O(N)会越来越大。并且是<em><strong>先扩容再进行插入</strong></em></p><p>在JDK1.8后：引入了红黑树，链表元素超过阈值8时，链表转为红黑树；&lt;&#x3D;6时，树还原成链表。原因：红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；而且是先插入，再看size是否大于阈值，大于则扩容</p><p><img src="/2022/05/13/hashmap/jiegou.png" alt="image-20220427110202488"></p><h1 id="负载因子0-75"><a href="#负载因子0-75" class="headerlink" title="负载因子0.75"></a>负载因子0.75</h1><p>作用就是扩容机制的阈值。若是1.0，hashmap就会有大量冲突，底层的红黑树会很复杂，查询效率很低，空间利用率上去，时间效率降低；若是0.5，hash冲突减少，底层的链表长度和红黑树的高度会降低，时间效率提升，空间利用率降低。0.75就比较适中，空间利用率较高，避免比较多的冲突</p><h1 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h1><p>JDK1.7：</p><p>​判断当前数组是否要初始化</p><p>​    若key为空，则put一个空值进去</p><p>​通过hash()函数计算key哈希值，并得到其下标</p><p>​将hash、key、value等信息封装成一个entry对象</p><p>​根据当前下标位置上的节点情况，采用不同方法放置此节点（若key和传入的key相等则覆盖原来的key，反之增新增一个entry对象）。链表和红黑树的情况放置</p><p>JDK1.8:</p><p>​ 实际是调用putval方法，计算的key的hash值、key、value都放过去</p><p>判断底层的table表是否空，空就扩容到16；根据key计算hashcode，再通过hash值得到table表的下标索引；</p><p>若当前位置没有节点，就挂上去。</p><p>若有节点，先判断表里的key和输入的key或者内容是否相同，相同就赋值给e</p><p>​            若不相同，则判断是否是红黑树，若是则根据红黑树的原理加 </p><p>​                          也不是红黑树，则遍历链表，链表没有一个key相同，则放在最后；存在相同就覆盖</p><p>​    判断是否需要扩容</p><p>put源码1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//计算键的哈希值，放值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="comment">//链表数组；链表对象；           长度； 索引</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="comment">// tab是否为空或者长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 是：就执行扩容方法，数组的长度是扩容后的长度</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 获取tab的第i个元素，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 为空就赋值给第i个</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//就会有两种情况，hash值重复、碰撞了</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断key值是否重复了</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//就直接把上一个的值覆盖</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//判断tab[i]是否是红黑树 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据红黑树的性质插入值</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是红黑树就是链表，就开始遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//判断是否是最后一个或者是否是空，是空就插入进链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//判断链表的长度是否是大于8的，若是则转为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//key是否存在，存在就覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e不为空，就将e添加到tab中</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//当前的数量是否大于阈值，大于就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>流程图</p><p><img src="/2022/05/13/hashmap/put-liucheng.png" alt="image-20220513124451221"></p><h1 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h1><p>JDK1.7</p><p>​通过hash()计算key的哈希值，得到其下标，判断该位置是否是链表；不是就根据key、value的hashcode是否相等返回值。为链表就遍历直到 key和hashcode相等就返回。遍历完也没有就返回null</p><p>JDK1.8：</p><p>创建一个Node节点 e，调用getNode方法，传参计算的hash值和key值</p><p>  计算hashcode得到桶，桶空就返回null；判断桶的第一个位置的key是否为查询的key，是就返回value；不是就判断下一个是红黑树还是链表，就根据红黑树和链表进行查找（都是遍历，查找）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="comment">//判断是否为空，判断key对应的链表节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断链表头部元素是否是key值对应的真实value</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//链表是否含有下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//是否红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//根据红黑树的逻辑查找对应的value</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//根据hash和key值判断下一个元素是否是key值对应的真实value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//什么都没找到，就为null值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="与HashTable的比较"><a href="#与HashTable的比较" class="headerlink" title="与HashTable的比较"></a>与HashTable的比较</h1><table><thead><tr><th align="center">HashMap</th><th align="center">HashTable</th></tr></thead><tbody><tr><td align="center">继承的AbstractMap</td><td align="center">继承的Dictionary</td></tr><tr><td align="center">Null可以作为键（只有一个），也可以作为值（多个）</td><td align="center">不支持Null key和Null value</td></tr><tr><td align="center">线程不安全，多线程并发可能导致死锁。但也因此效率更高</td><td align="center">线程安全，因每个方法都有Synchronize方法</td></tr><tr><td align="center">默认初始化大小16，每次扩容为原来的2倍</td><td align="center">默认初始化大小11，每次扩容为原来的2*N+1</td></tr><tr><td align="center">计算hash值的方法不同</td><td align="center">计算hash值方法不同</td></tr><tr><td align="center">遍历方法的内部实现不同</td><td align="center">遍历内部实现不同</td></tr><tr><td align="center">没有contains方法</td><td align="center">有contains方法</td></tr></tbody></table><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手四次挥手基础</title>
      <link href="/2022/05/12/threefour/"/>
      <url>/2022/05/12/threefour/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>建立可靠的通信信道，也就是<em><strong>双方确认自己与对方发送与接收是正常的</strong></em></p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端随机初始化序号，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SEBT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><p><img src="/2022/05/12/threefour/woshou.png" alt="image-20220512090045815"></p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1），等待服务器发FIN报文；当服务器端确定数据（读到结束符EOF）已发送完成，则向客户端发FIN报文，延迟一段时间 再发ACK报文（处理一些最后的请求）；客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传）；服务器端收到ACK就关闭，客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/05/12/threefour/huishou.png" alt="image-20220512090215143"></p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以阻止重复历史连接的初始化（最主要，若是两次握手就不能判断）：若是历史连接，客户端发送的报文就是RST报文，反之则是ACK报文</p><p>同步双方的初始序列号：</p><p>避免资源浪费：  若服务端阻塞，发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：就没办法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</p><h1 id="握手是三次，挥手是四次"><a href="#握手是三次，挥手是四次" class="headerlink" title="握手是三次，挥手是四次"></a>握手是三次，挥手是四次</h1><p>当服务器端收到SYN连接请求报文后，可以直接发SYN+ACK报文，ACK是应答，SYN是同步的。关闭时，服务器端收到FIN时，有可能不会立即关闭SOCKET，所以只能先回一个ACK报文</p><p>但在抓包时，服务器接收到FIN后，服务器端同时要关闭链接，这样ACK和FIN一起发送节省了一个包。从抓包方面看，就是“三次挥手”</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB基础</title>
      <link href="/2022/05/11/InnoDB-1/"/>
      <url>/2022/05/11/InnoDB-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>现mysql 5.5后默认引擎，兼顾高可靠性和高性能性的通用存储引擎</p><p>若要对事务的完整性要求较高、要求实现并发的话，InnoDB有大优势；若频繁更新、删除操作也可，因为支持事务的提交和回滚</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>​    DML遵循ACID模型，支持<em><strong>事务</strong></em>。<em><strong>行级锁</strong></em>（加锁开销最大，加锁慢，会出现死锁），提供并发性能；支持<em><strong>外键</strong></em>FOREIGN KEY约束，保证数据的完整性和正确性。</p><p><em><strong>数据块要缓存</strong></em>；寻址要映射到块，再到行；要维护MVCC一致，所以Innodb在select的时候要维护的东西比较多</p><p>delete表的时是一行一行删除，而myisam则是先drop表，再重建表</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>聚集索引：</p><p>​将数据存储与索引放到一块，索引的叶子节点保存了行数据，必有且只有一个聚集索引。若有主键，主键即是；无主键用第一个唯一索引；若都没，会自动生成一个rowid作为隐藏的聚集索引。</p><p>索引结构：</p><p>​B+树：将所有数据都放在叶子节点，叶子节点形成一个列表，非叶子只存放键值，每个数据叶中的有效数据就多了，可以减少IO次数</p><p>​    因为相对于二叉树（会有左倾右倾的情况），B+树层级更少，搜索效率高</p><p>​    因为B树：无论叶子节点还是非叶子，都保存数据，所以存储值减少，指针就减少，要同样保存大量数据，只能增加树的高度，导致性能降低，要查找就要遍历整个树</p><p>​    Hash索引只支持等值匹配，不支持排序操作</p><p>二级索引：将数据与索引分开，索引结构的叶子节点关联的是对应的主键</p><h1 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h1><p>TableSpace(表空间)：可以看成Innodb逻辑存储的最高层，所有的数据都存放在表空间内</p><p>Segment（段）：分为数据段、索引段、回滚段。Innodb是索引组织表，数据段是B+树的叶子节点，索引段为B+的非叶子节点。段用来管理多个区</p><p>Extent（区）：表空间的单元结构，每个区默认1M。innodb引擎页大小为16K。连续的页组成</p><p>Page（页）：每个默认16KB，存储引擎磁盘管理的最小单位。数据页、undo页、系统页、事务数据页</p><p>Row（行）：存放的数据</p><h1 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h1><p>Buffer Pool（缓冲池）：</p><p>主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据。增删时，先操作缓冲池的数据（没有，则从磁盘加载），再以一定频率刷新到磁盘，也就减少磁盘IO，加快处理速度</p><p>​    页为单位，链表数据结构管理Page。空闲page（未被使用），被使用page（数据没有被修改过），脏页（被使用过，数据与磁盘的数据不同）</p><p>Change Buffer（更改缓冲区）：执行DML时，操作的数据不在buffer pool中就不会操作磁盘，会将数据变更存在此处，在未来数据被读取时，再将数据合并恢复到缓冲池，再将合并后的数据写到磁盘</p><p>意义：可以在缓冲池中间进行合并处理，减少磁盘IO。因为二级索引一般非唯一，并且以相对随机的顺序插入二级索引。</p><p>Log Buffer（日志缓冲区）：用来保存要写入到磁盘中的log日志数据，默认16MB，日志缓冲区的日志会定期刷新到磁盘中。</p><p>后台线程：将缓冲池中的数据在合适的时候刷新到磁盘</p><p>Master thread：核心，负责调度其他线程，将缓冲池中的数据异步刷新到磁盘中，保持数据一致性，包括脏页的刷新、合并插入缓存，undo页的回收</p><p>​    IO thread：负责IO请求的回调</p><p><img src="/2022/05/11/InnoDB-1/jiegou.png" alt="image-20220511134406227"></p><h1 id="保证ACID"><a href="#保证ACID" class="headerlink" title="保证ACID"></a>保证ACID</h1><p>Redo log（重做日志）：保证持久性。记录的是事务提交时数据页的物理修改。记录的是物理日志</p><p>​    重做日志缓冲：在内存   重做日志文件：在磁盘</p><p>​    当事务提交后把所有信息都存到日志文件，用于刷新脏页到磁盘；发生错误，进行数据恢复使用</p><p>​    在脏页信息发生错误时进行数据恢复，也就是持久性。</p><p>Undo log（回滚日志）：保证原子性。记录数据被修改前的操作。逻辑日志</p><p>​             作用：提供回滚和MVCC</p><p>​             Delete时，undo log里记录insert；update时，会记录反向的update语句 </p><p>​         当事务提交时不会立即删除，因为可能用于MVCC</p><p>​         采用段的方式进行管理和记录</p><h1 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h1><p>通过MVCC。</p><p>MVCC会给每行元祖加一些辅助字段，记录版本号和删除版本号，每一个事务启动都有一个唯一的递增的版本号。每开启一个事务，事务版本号就会递增</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized基础</title>
      <link href="/2022/05/10/synchronized-1/"/>
      <url>/2022/05/10/synchronized-1/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>解决多个线程之间访问资源的同步性，该关键字可保证修饰的方法或代码块在任意时刻只能有一个线程执行。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>JVM是通过进入、退出对象监视器来实现对方法、同步块的同步，而对象监视器的本质依赖于底层操作系统的互斥锁实现，能自动解锁</p><p>使用：</p><p>作用于普通方法时：锁的是对象的实例，即this对象，所谓的方法锁。进入同步代码块，要获得当前实例的锁</p><p>修饰静态方法时：锁的是这个类的所有class对象，即xxx.class  类锁。会作用于所有对象实例。进入同步代码要获得当前类对象的锁</p><p>修饰代码块（在方法中）时：锁的是synchronized(obj)，用户给定的对象，对象锁。进入同步代码要获得给定对象的锁</p><p><img src="/2022/05/10/synchronized-1/use.png" alt="use"></p><p>不能在类级别的（静态）代码块</p><p>特点：</p><p>  原子性、可见性（释放锁时，所有写入都会写回内存，获得锁就会从内存读取最新数据）、有序性；可重入性（对同一个线程在获得锁后，在调用其他需同样锁的代码时可直接调用）；重量级（底层是一个监视器对象完成。监视器锁的本质是依赖于操作系统的互斥锁实现）</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p> 偏向锁：Java6之后加的新锁。会偏向当前已经占领锁的线程 ，总是让一个线程多次获得。只在第一次请求锁时采用CAS操作并将锁对象的标记字段记录为当前线程地址。之后，持有该锁的线程无需加锁操作</p><p>​线程在进入同步代码块获得锁时，会检查对象头中是否存储了线程ID，若没有，判断一下偏向标志位是否为1，若不是1，说明该锁没有被任何线程获取，就CAS的方式替换mark word，将对象Mark word中的线程ID指向该线程，并将偏向标志位置位</p><p>  轻量锁：多个线程在不同时间请求同一把锁，即没有锁竞争。代码进入同步块时，若同步对象无锁，当前线程会在栈帧中创建一个锁记录区域，同时将锁对象头中的mark word拷贝到锁记录，再使用CAS将mark word 更新为指向锁记录的指针</p><p>  自旋锁：轻量级失败后，进行。基于大多数情况下，线程持有锁的时间都不会太长。因为线程间的切换操作系统需要从用户态到核心态，时间成本高。线程没有获取到锁的时候，虚拟机让线程做几个时间不太久的空循环（即自旋），循环后再次去尝试获取锁，若得到锁就进入临界区，反之就会被在操作系统层面挂起。<em><strong>提升了效率</strong></em>，最后没办法就只能升级为重量级锁</p><p>  锁消除：<em><strong>删除不必要的加锁</strong></em>。虚拟机在JIT编译时，扫描运行上下文，去除不可能存在共享资源竞争的锁。</p><p>  锁粗化：将多次连续的加锁、解锁操作合并为一次，将多个连续的锁拓展成一个更大的锁</p><p> 构造方法不能使用该关键字修饰，因为构造方法本身就线性安全</p><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p>是通过monitorenter获取锁，通过monitorexit释放锁</p><p>出现两个monitorexit：防止同步代码块中线程因异常退出，而锁没有释放，这必然会导致死锁。<em><strong>最后一个monitorexit保证在异常情况下，锁也可以得到释放，避免死锁</strong></em></p><h1 id="和Lock比较"><a href="#和Lock比较" class="headerlink" title="和Lock比较"></a>和Lock比较</h1><p>相同点：</p><p>  都是可重入锁；都保证了可见性和互斥性；都可以用于控制多线程对共享对象的访问</p><p>不同点</p><table><thead><tr><th align="center">ReetrantLock</th><th align="center">synchronized</th></tr></thead><tbody><tr><td align="center">默认也是非公平，但可以实现公平锁</td><td align="center">锁非公平</td></tr><tr><td align="center">只是lock接口下的实现类，是API层面的锁</td><td align="center">是JVM级别的锁</td></tr><tr><td align="center">显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作</td><td align="center">隐式获取锁和释放锁</td></tr><tr><td align="center">等待可中断、可实现公平锁、可实现选择性通知</td><td align="center"></td></tr><tr><td align="center">是可精确唤醒</td><td align="center">要么随机唤醒一个线程，要么唤醒所有等待的线程</td></tr></tbody></table><p>隐式锁和显示锁就是在使用的时候，使用者是否要手动写代码来控制获取锁和释放锁</p><p>公平锁实现：获取锁时，会先看sync队列是否在 等待获取资源的线程。没有就尝试获取锁，若有就将当前线程封装成node加入sync队列</p><p>非公平锁实现： 当线程争锁时，会进行一次CAS尝试获取锁，失败就进入acquir(1)函数，再尝试获取锁，若失败就将当前线程封装成node加入sync队列，就等前面线程执行完轮到自己</p><h1 id="和volatile比较"><a href="#和volatile比较" class="headerlink" title="和volatile比较"></a>和volatile比较</h1><table><thead><tr><th align="center">Synchronized</th><th align="center">Volatile</th></tr></thead><tbody><tr><td align="center">性能较差</td><td align="center">线程同步的轻量级实现，性能更好</td></tr><tr><td align="center">可以修饰方法以及代码块</td><td align="center">只能用于变量</td></tr><tr><td align="center">原子性、可见性都保证</td><td align="center">可保证数据的可见性，不保证原子性</td></tr><tr><td align="center">解决的是多线程之间访问资源的同步性</td><td align="center">解决变量在多个线程间的可见性</td></tr><tr><td align="center">因为是锁，可能造成线程阻塞</td><td align="center">不会线程阻塞</td></tr><tr><td align="center">标记的变量可以被编译器优化</td><td align="center">标记的变量不会被编译器优化</td></tr></tbody></table><p>内存屏障：是CPU的重排列指令引起的</p><p>Volatile通过内存屏障禁止指令重排序</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC基础</title>
      <link href="/2022/05/09/springmvc-1/"/>
      <url>/2022/05/09/springmvc-1/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><img src="/2022/05/09/springmvc-1/MVCP.png" alt="MVC" style="zoom:80%;"><p>是软件工程中的一种软件架构模式，它把软件系统分为模型、<strong>视图</strong>和<strong>控制器</strong>三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p>Model: 存储实体类。完成具体的业务操作，如：查询数据库，封装对象</p><p>View：页面展示（视图模式）。JSP、HTML等数据展示，用户可以看到的</p><p>Controller：页面逻辑处理，与用户监控。获取View的请求，调用模型将数据交给视图</p><p>流程：浏览器输入url后，就是发送请求到对象服务器，服务器根据url找到controller，控制器根据业务的逻辑从model获取数据，再把数据给特定的view，view就是客户看的到的结果</p><h2 id="为什么要使用MVC"><a href="#为什么要使用MVC" class="headerlink" title="为什么要使用MVC"></a>为什么要使用MVC</h2><p>可以使同一个程序使用不同的表现形式，若控制器反馈给模型的数据发生了变化，模型也要发生变化</p><p>因模型独立于视图，所以模型可以复用，模型可以独立的移植到别的地方使用</p><p>前后端代码分离，让项目开发的分工更加明确，提高了开发效率</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>一种基于java实现MVC设计模型的请求驱动类型的轻量级web框架。将负载的应用程序系统按照分层处理进行设计和规划，以降低开发难度，提供代码的可维护性。比其他的MVC框架更具有灵活性和拓展性</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/2022/05/09/springmvc-1/springmvcP.png" alt="springmvc"></p><p>框架主要就是围绕中央控制器dispatcherServlet展开</p><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p>前端控制器(dispatcherServlet)：接收请求，响应结果，将各个组件连通</p><p>处理器映射器：根据用户请求的URL找到对应的Handler</p><p>处理器适配器：按照HandlerAdapter的规则去编写，适配器才可以正确执行Handler</p><p>处理器：controller</p><p>视图解析器：视图的解析，根据视图逻辑名解析成真正的视图</p><p>视图：一个接口，支持不同的视图类型</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以支持各种视图技术，不局限于JSP</p><p>与spring框架继承</p><p>清晰的功能分配：前端控制器、请求到处理器映射、处理器适配器、视图解析器</p><p>支持各种请求资源的映射策略</p><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="建立Map-lt-urls-controller-gt-的关系"><a href="#建立Map-lt-urls-controller-gt-的关系" class="headerlink" title="建立Map&lt;urls,controller&gt;的关系"></a>建立Map&lt;urls,controller&gt;的关系</h3><p>入口类就是ApplicationObjectSupport的setApplicationContext方法，核心就是initApplicationContext</p><p><img src="/2022/05/09/springmvc-1/set.png" alt="image-20220509135611735"></p><p>AbstractDetectingUrlHandlerMapping实现了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException &#123;</span><br><span class="line">        <span class="built_in">super</span>.initApplicationContext();</span><br><span class="line">        detectHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">　　  * 建立当前ApplicationContext中的所有controller和url的对应关系</span></span><br><span class="line"><span class="comment">　　　 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">         <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">　　　　 <span class="comment">// 获取ApplicationContext容器中所有bean的Name</span></span><br><span class="line">       String[] beanNames = <span class="built_in">this</span>.detectHandlersInAncestorContexts?</span><br><span class="line">           BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class):</span><br><span class="line">           applicationContext.getBeanNamesForType(Object.class);</span><br><span class="line"> String[] var3 = beanNames;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> beanNames.length;</span><br><span class="line">        <span class="comment">// 遍历beanNames,并找到这些bean对应的url</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">             <span class="comment">// 找bean上的所有url(controller上的url+方法上的url),该方法由对应的子类实现</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">            String[] urls = <span class="built_in">this</span>.determineUrlsForHandler(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">                  <span class="comment">// 保存urls和beanName的对应关系,put it to Map&lt;urls,beanName&gt;,该方法在父类AbstractUrlHandlerMapping中实现</span></span><br><span class="line">                <span class="built_in">this</span>.registerHandler(urls, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled() &amp;&amp; !<span class="built_in">this</span>.getHandlerMap().isEmpty() || <span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.getHandlerMap().size() + <span class="string">&quot; mappings in &quot;</span> + <span class="built_in">this</span>.formatMappingName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           </span><br><span class="line">    <span class="comment">/** 获取controller中所有方法的url,由子类实现,典型的模板模式 **/</span></span><br><span class="line">　　<span class="keyword">protected</span> <span class="keyword">abstract</span> String[] determineUrlsForHandler(String var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后的determineUrlsForHandler是获取每个controller的url，不同子类不同的实现。此处分析BeanNameUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的url</span></span><br><span class="line"><span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">    <span class="comment">//用来保存url的容器</span></span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//判断beanName哪些是以&quot;/&quot;开头</span></span><br><span class="line">    <span class="keyword">if</span> (beanName.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        urls.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliases = <span class="built_in">this</span>.obtainApplicationContext().getAliases(beanName);</span><br><span class="line">    String[] var4 = aliases;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> aliases.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">        <span class="keyword">if</span> (alias.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            urls.add(alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br></pre></td></tr></table></figure><p>AbstractUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPaths, <span class="string">&quot;URL path array must not be null&quot;</span>);</span><br><span class="line">    String[] var3 = urlPaths;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> urlPaths.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">        <span class="built_in">this</span>.registerHandler((String)urlPath, (Object)beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPath, <span class="string">&quot;URL path must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(handler, <span class="string">&quot;Handler object must not be null&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedHandler</span> <span class="operator">=</span> handler;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">//将handler转为beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String)handler;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">            <span class="comment">//根据beanName获取bean，一对一对应到controller类</span></span><br><span class="line">            resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot map &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler) + <span class="string">&quot; to URL path [&quot;</span> + urlPath + <span class="string">&quot;]: There is already &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(mappedHandler) + <span class="string">&quot; mapped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Root mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setRootHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Default mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setDefaultHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//最终将结果put到map集合中，建立一一对应的关系</span></span><br><span class="line">        <span class="built_in">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Mapped [&quot;</span> + urlPath + <span class="string">&quot;] onto &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据url找到controller里处理请求方法"><a href="#根据url找到controller里处理请求方法" class="headerlink" title="根据url找到controller里处理请求方法"></a>根据url找到controller里处理请求方法</h3><p>因为找请求方法，所以看dispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//异步处理</span></span><br><span class="line">        <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//定义空的ModelAndView变量</span></span><br><span class="line">                <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//检查是否是文件上传的请求</span></span><br><span class="line">                    processedRequest = <span class="built_in">this</span>.checkMultipart(request);</span><br><span class="line">                    multipartRequestParsed = processedRequest != request;</span><br><span class="line">                    <span class="comment">//取得处理当前请求的controller（handler处理器），返回HandlerExecutionChain对象</span></span><br><span class="line">                    mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">                    <span class="comment">//handler不能为空</span></span><br><span class="line">                    <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//不同的controller类型交给不同的适配器</span></span><br><span class="line">                    <span class="comment">//若是bean，mappedHandler.getHandler()返回的对象</span></span><br><span class="line">                    <span class="comment">//若是method，返回的就是一个方法</span></span><br><span class="line">                    <span class="comment">//获取的就是handlerAdapter，方便后续找到对应的controller</span></span><br><span class="line">                    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">                    <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                        <span class="comment">//处理last-modified请求头</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">  <span class="comment">//拦截器预处理</span></span><br><span class="line">                    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">       <span class="comment">//通过适配器，处理请求</span></span><br><span class="line">  <span class="comment">//实际的处理器处理请求，返回结果视图对象</span></span><br><span class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">   <span class="comment">//结果视图对象处理</span></span><br><span class="line">                    <span class="built_in">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                    <span class="comment">//拦截器后置处理</span></span><br><span class="line">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">                    <span class="comment">//后面就是各种报错的判断反馈处理</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                    dispatchException = var20;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, var21);</span><br><span class="line">                <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, var23));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                <span class="built_in">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="与Struts2的区别"><a href="#与Struts2的区别" class="headerlink" title="与Struts2的区别"></a>与Struts2的区别</h2><table><thead><tr><th align="center">Struts2</th><th align="center">SpringMVC</th></tr></thead><tbody><tr><td align="center">filter为入口</td><td align="center">前端控制为入口</td></tr><tr><td align="center">基于类开发，传递参数通过类的属性，只能设置多例</td><td align="center">基于方法开发（一个url一个方法），请求参数传递到方法形参，可单例可多例</td></tr><tr><td align="center">值栈存储请求和响应的数据，OGNL存取数据</td><td align="center">通过参数解析器将request请求内容解析，给方法形参赋值，将数据视图封装成ModelAndView</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础</title>
      <link href="/2022/05/08/spring-1/"/>
      <url>/2022/05/08/spring-1/</url>
      
        <content type="html"><![CDATA[<h1 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h1><p><img src="/2022/05/08/spring-1/spring-model.png" alt="主要模块"></p><p>主要被分成：数据访问&#x2F;继承、web、AOP（面向切面编程）、工具、消息、测试</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>创建方式：构造器创建Bean<bean>标签、Setter方法、静态工厂方法创建bean、实例工厂方法创建bean</bean></p><p>获取bean：在初始化的时候保存ApplicationContext对象、通过Spring提供的工具类获取ApplicationContext对象、实现ApplicationContextAware接口、继承自抽象类ApplicationObjectSupport</p><p>配置Bean方式：基于XML配置、基于注解的配置、基于java的配置</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>默认下，spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例；所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为singleton，是所有bean的默认作用域</p><table><thead><tr><th align="center">类别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">在SpringIoc容器中仅存在一个bean实例,bean以单实例方式存在</td></tr><tr><td align="center">prototype</td><td align="center">每次调用getbean() 都将返回一个新的实例</td></tr><tr><td align="center">request</td><td align="center">每次Http请求都会创建一个新的bean,该作用域仅适合于WebApplicationContext 环境</td></tr><tr><td align="center">session</td><td align="center">同一个Http Session 共享一个bean,不同的Http Session使用不同的bean.该作用域仅适合 WebApplicationContext 环境</td></tr></tbody></table><p>singleton 默认值 当Ioc容器一创建就会创建bean实例,而且是单例的,每次得到的都是同一个<br>prototype 原型的 当Ioc容器一创建不实例化该bean,每次调用getBean() 方法时再实例化该bean,而且每次调用都是不同的bean实例<br>request 每次请求实例化一个bean<br>session 在一次会话中共享一个bean</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="创建前准备"><a href="#创建前准备" class="headerlink" title="创建前准备"></a>创建前准备</h3><p>​bean在开始加载之前，从上下文和配置中解析并查找bean有关的一些扩展实现。比如：init-method：容器在初始化时调用的；destroy-method：容器在销毁bean的时候会调用；BeanFactoryPostProcessor：加载过程中的前置、后置的一些处理拓展实现。</p><p>​这些类或配置时提供给开发者去实现bean加载过程中的拓展，在很多与spring集成的中间件常见。比如：Dubbo</p><h3 id="创建实例化"><a href="#创建实例化" class="headerlink" title="创建实例化"></a>创建实例化</h3><p>​通过反射去创建bean的实例对象，并且扫描和解析bean声明的一些属性</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>​若被实例化的bean存在依赖其他bean对象的一些情况，则需要对这些依赖的bean进行对象注入。比如：@Autowired、@Setter这样的配置形式。</p><p>​还会触发一些拓展的调用。比如：BeanPostProcessors：去实现bean初始化前后的拓展回调；</p><h3 id="容器缓存"><a href="#容器缓存" class="headerlink" title="容器缓存"></a>容器缓存</h3><p>​把bean缓存到容器里面以及spring的缓存中；这个阶段的bean就能被开发者拿去用。</p><h3 id="销毁实例"><a href="#销毁实例" class="headerlink" title="销毁实例"></a>销毁实例</h3><p>​当spring的应用上下文被关闭的时候，上下文中所有的bean会被销毁。若bean实现了诸如DisposableBean接口或者配置了destory-method属性的一些方法会在该阶段调用</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p> 一种设计思想，控制反转，<em><strong>将设计好的对象交给容器控制</strong></em>。在调用某个类时，容器会实例化，即容器控制对象的创建。</p><p>  IOC容器实例化过程中，一般不包含bean的依赖注入，bean的注册和依赖注入是两个过程，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xml中配置，在容器初始化的时候，这个bean就完成了初始化。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程基于IOC。简单说就是将部分重复的代码抽取出来，需要执行的时候用动态代理价技术。不修改代码进行功能增强。</p><p> 降低了耦合度，提高了程序的可重用性，同时提高了开发效率，实现业务和切入类的解耦</p><p>底层使用动态代理</p><p>与OOP相比，一个是横向一个纵向在</p><h1 id="涉及到的设计模式"><a href="#涉及到的设计模式" class="headerlink" title="涉及到的设计模式"></a>涉及到的设计模式</h1><p>IOC：工厂模式，单例模式，装饰器模式</p><p>AOP：代理模式，观察者模式（监听）</p><p>MVC:委派模式，适配者模式</p><p>JDBC：模板方法模式（RestTemplate）</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>有了IOC容器，对象间的依赖关系交给了spring，更专注业务逻辑代码</p><p>有AOP和OOP，很多功能更方便简单使用</p><p>简化开发</p><p>方便测试</p><p>声明式事务管理</p><p>减低API开发难度</p><p>低耦合</p><p>方便集成其他框架</p><h1 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h1><p>spring里面的核心功能是IOC容器，本质就是bean的容器、工厂，能去根据XML中声明的bean的配置去进行加载和初始化，然后beanFactory去生成我们所需要的各种各样的一个bean。</p><p>BeanFacory：是所有Spring Bean容器的顶级接口，为Spring的容器定义了一套规范，并提供像getBean等方法从容器中获取指定的Bean的实例；在产生bean的同时，提供解决bean之间依赖注入的能力；</p><p>FactoryBean：是一个工厂bean，接口，主要功能是去动态生成某一类型的bean的一个实例，即可以自定义一个bean并加载到IOC容器里，里面有个方法getObject就是实现动态构建bean的一个过程。OpenFeign组件客户端代理就是使用了FactoryBean实现</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2022/05/07/ThreadLocal-1/"/>
      <url>/2022/05/07/ThreadLocal-1/</url>
      
        <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/05/07/ThreadLocal-1/first.png" alt="结构"></p><p>线程本地存储机制，数据缓存到线程内部</p><p>当thread销毁时，threadLocal也会随之销毁，减少内存的使用</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>Synchronized用于线程间的数据共享，ThreadLocal用于<em><strong>数据隔离</strong></em>，最适合多实例的对象的访问。</p><p>保存该线程变量，这样每个线程都有自己的数据，就做到了不同线程间数据的隔离。即多线程环境下，对于共享变量访问的安全性。</p><p>为每个使用该变量的线程提供独立的变量副本，所以<em><strong>每个线程都可独立改变自己副本</strong></em>，而不影响其他线程对应的副本，从而没必要对该变量进行同步了。</p><p>  提供了线程安全的共享对象，在多线程中，可把不安全的变量封装进ThreadLocal</p><p>创建一个TheadLocal变量，那么访问这个变量的每个线程都会有这个线程的本地副本。</p><p><em><strong>解决了线程安全问题，避免了多线程竞争锁的开销</strong></em></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>连接ThreadLocalMap和Thread，来处理Thread的ThreadLocalMap属性</p><p>  ThreadLocalMap用来存储数据，类似于hashmap，存储ThreadLocal为key，需要隔 离的数据为value的Entry键值对数据结构。可以理解：ThreadLocal只是ThreadLocalMap封装，传递了变量值。ThreadLocalMap&lt;ThreadLocal,数据&gt;</p><p>  ThreadLocalMap是ThreadLocal内部类，由ThreadLocal创建，ThreadLocal本身就是一个代理工具</p><p>  每个thread对象都会存一个theadLocalMap</p><p>  这样不容易产生内存泄露</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//   获取当前线程对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//再获取该线程下的threadlocalmap对象map</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)<span class="comment">//  Map若存在，则将参数设置到Map中</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);<span class="comment">// 否则就创建map（createMap(Thread t,T value)）并设置初始值</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//首先获取线程</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//根据线程获取map；</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">// 若map不为空，则在map下以threadlocal的引用作为key来在map中获取对应的entry e；</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;<span class="comment">//若e不为mull，则返回e.value；</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();<span class="comment">//Map为空或e为空，则initialValue函数获取初始值value，用threadlocal的引用和value作为键和值创建一个新map</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());<span class="comment">//获取当前线程，根据线程获取一个map；</span></span><br><span class="line">         <span class="keyword">if</span> (m != <span class="literal">null</span>)<span class="comment">//若map部位空则移除当前threadlocal对象对应的entry</span></span><br><span class="line">             m.remove(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="InitialValue"><a href="#InitialValue" class="headerlink" title="InitialValue"></a>InitialValue</h2><p>默认就返回null。延迟方法可重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">      SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">          <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> supplier.get();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>ThreadLocal没有被外部强引用的情况下，垃圾回收时key就会被清理，value不会，因为前者为弱引用，后者为强引用。</p><p>在线程池中使用ThreadLocal可能内存泄露：在线程池中线程的存活时间太长，往往都是和程序同生共死，这样thread持有的ThreadLocalMap一直不会被回收，又因为是弱引用，所以ThreadLocal结束生命就可以被回收。而Entry中的value被Entry强引用，所以机制value生命周期结束，也不会被回收，导致内存泄露</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>每一个线程分配一个和JDBC连接Connection，保证每个线程的都在各自的Coonection上进行数据库的操作</p><p><em><strong>变量在线程内部共享，线程间无关</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TheadLocal </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="/2022/05/06/redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/06/redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="redis的基本性质"><a href="#redis的基本性质" class="headerlink" title="redis的基本性质"></a>redis的基本性质</h1><p>redis是<em><strong>完全基于内存</strong></em>，绝大部分请求是都是纯粹的内存操作</p><p>基于Reactor模式开发的网络处理器单多线程</p><p>6.0以前是单线程，利用队列技术将并发访问变为了串行访问，消除了传统数据库串行控制的开销</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>支持数据持久化，可以将内存的数据保存在磁盘中，重启的时候可以再次舒勇</p><p>提供各种数据结构进行存储</p><p>支持数据的备份</p><p>高性能、高并发，所以可以作为缓存</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>五种基础：</p><p>String：最基本的，动态字符串，存数字时底层是int；长字符串（长度&gt;39字节）raw；短字符串（长度&lt;39字节）embstr</p><p>利用key的生命周期做投票系统；String特点数据刷新；利用数值操作特征为分布式数据库自增。访问次数、点赞、转发量</p><hr><p>Hash：是一个键值对集合，是一个String类型的key和value的映射表。相当于hashmap。存放对象类型的数据，可避免键名冲突。 用户的购物车；hash作为商品秒杀技术对象完成商品秒杀系统</p><p>底层：ziplist（元素数量&lt;512，所有元素长度&lt;64字节）和哈希表。</p><hr><p>List：简单的字符串列表，底层是顺序的双向链表和ziplist（元素数量&lt;512，所有对象元素长度小于64字节）。可用于消息队列；顺序特性实现朋友圈点赞；顺序特性进行分布式日志顺序性展示</p><hr><p>Set:String类型的无序集合，底层哈希表和inset（所有元素是整数，元素数量小于512）</p><p>比如标签；黑白名单；获取所有业务的权限</p><hr><p>Zset（SortedSet）：ziplist（元素数量小于128，所有元素长度&lt;64）和跳表结合，value保证唯一性，又可为每个value代表权重的值。排行榜系统；带权重任务队列；根据权重进行排序</p><p>三种高级：</p><p>Bitmaps:String类型上的一组面向bit操作的集合，不是真的数据结构，优点就是存储信息可节省大量空间。一般用于实时分析，存储对象ID关联的节省空间且高性能的布尔信息。底层是String</p><hr><p>HyperLogLogs：用于计算唯一事物的概率数据结构。可用于计算用户每天在搜索框中执行唯一的搜索。底层是String</p><hr><p>GEO：存储用户给定的地理位置信息，并对这些信息操作。底层是zset</p><hr><p>Streams：内存版的kafka</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>速度快，支持丰富数据类型，支持事务、<em><strong>指令操作</strong></em>都是原子性的</p><p>容量收到物理内存限制，只适合较小数据量的高性能操作和运算上；</p><p>难在线扩容，在集群容量达到上限时在线扩容很复杂，所以运维人员在保证足够的空间</p><h1 id="redis6-0以后为什么引入多线程？"><a href="#redis6-0以后为什么引入多线程？" class="headerlink" title="redis6.0以后为什么引入多线程？"></a>redis6.0以后为什么引入多线程？</h1><p>多线程的情况下，线程切换换消耗CPU，<em><strong>CPU并不是redis的瓶颈</strong></em>。</p><p>引入多线程<em><strong>主要是为了提高网络IO读写性能</strong></em>：多线程只是在网络数据的读写这类耗时操作上使用，而执行命令仍是单线程顺序执行</p><p>redis将所有数据放在了内存中，对于小数据包，redis服务器已经处理80000到100000QPS，已经是极限，对大部分公司已经够用了</p><p>从redis自身角度，因为读写网络read&#x2F;write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p><ul><li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</li><li>使用多线程充分利用多核，典型的实现比如 Memcached</li></ul><p>小总结：</p><p>​可以充分利用服务器CPU资源，目前主线程只有一个核</p><p>​多线程可以分摊redis同步IO读写消耗</p><h1 id="redis6-0关于多线程"><a href="#redis6-0关于多线程" class="headerlink" title="redis6.0关于多线程"></a>redis6.0关于多线程</h1><p><em><strong>多线程默认是禁用的，只使用主线程</strong></em>。所以需要修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>仅仅是开启多线程是不生效，修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核使用2/3个线程，8核使设置6个线程</span></span><br></pre></td></tr></table></figure><p>实现机制：</p><p>​主线程负责接收建立连接请求，获取socket放入全局等待处理读处理队列</p><p>​主线程处理完读时间后，通过RR（Round Robin）将这些连接分配给这些IO线程</p><p>​主线程阻塞等待IO线程读取socket完毕</p><p>​主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但不执行</p><p>​主线程阻塞等待IO线程将数据收回，写socket完毕</p><p>​解除绑定，清空等待队列</p><h1 id="开启多线程后，是否有线程并发安全问题"><a href="#开启多线程后，是否有线程并发安全问题" class="headerlink" title="开启多线程后，是否有线程并发安全问题"></a>开启多线程后，是否有线程并发安全问题</h1><p>Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p><h1 id="redis经常提到IO多路复用，怎么理解？"><a href="#redis经常提到IO多路复用，怎么理解？" class="headerlink" title="redis经常提到IO多路复用，怎么理解？"></a>redis经常提到IO多路复用，怎么理解？</h1><p>这是IO模型的一种，即经典的Reactor设计模式，有时也称为异步阻塞IO。</p><p>多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>[Redis 6.0 新特性-多线程连环13问！](<a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis 6.0 新特性-多线程连环13问！ (qq.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis内存淘汰</title>
      <link href="/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
      <url>/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内存淘汰： 当内存的使用率到达了maxMemory的上限的时候，进行内存的释放。</p><p>redis提供了许多内存淘汰算法，主要分为4种：</p><p>​随机：随机移除某个key</p><p>​TTL算法：，在设置了过期时间的键里面去找更早过期时间的key进行有限的移除</p><p>​LRU算法：去移除最近很少使用的key。</p><p>​LFU算法：与LRU算法类似                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h1 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h1><p>​LRU算法会维护一个大小为16的侯选池，里面的数据会随着时间排序，每一次随机抽取5个key放入侯选池，当侯选池满了后，访问的时间间隔最大的key就从侯选池里面取出来并淘汰。这样就可以把真实的最少访问的key从内存里面淘汰。</p><p>​存在问题：若一个key很长时间没有访问，突然偶尔被访问，那LRU就会认为这是一个热点key就不会被淘汰。</p><h1 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h1><p>​相比于LRU算法，LFU增加了访问频率来统计数据的热点情况。</p><p>​主要设置是使用了两个双向链表形成了一个二维的双向链表，一个链表来保存访问频率，另一个保存访问频率相同的所有元素。当添加元素的时候，访问频次默认为1，找到相同频次的节点，然后添加到相同的频率节点对应的双向链表的头部，当元素被访问的时候，就增加对应key的访问频率，并把当前访问的节点移动到下一个频次的节点。</p><p>​可能出现某个数据前期的访问次数很多，但后续不再使用。若单纯按照这样的一个访问频次来进行淘汰的话，那这个key就很难被淘汰掉。该算法通过使用频率和上次访问的时间来标记数据的热度。若某个数据有读和写，那增加访问的频率；若一段时间内该数据没有读写，那就减少访问频率。</p><p>​经过LFU算法改进后就可以实现真正达到非热点数据的淘汰</p><p>​缺点：与LRU相比，增加了访问频次的维护以及实现的复杂度要比LRU更高</p><h1 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h1><p>定时策略：创建一个定时器，过期时间到，逻辑对键的删除</p><p>​对内存友好而CPU时间不好，redis还没有使用</p><p>惰性删除：过期键不管，每次从键空间获取键的时候，该键过期了删了，没过期就返回该键</p><p>​对内存不友好而CPU时间友好</p><p>定期删除：每隔一段时间就检查，删除过期键，由算法决定</p><p>​较为折中</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis和数据库的数据一致性</title>
      <link href="/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>redis用来实现应用和数据库之间读操作的缓存层，主要目的是去减少数据库的IO，并提升数据库的IO性能。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>当应用程序需要读取某个数据的时候，首先会尝试去redis里面加载，若命中就直接返回，反之就去数据库里面查询，查询到数据后再把数据缓存到redis里面。</p><h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>即一份数据同时保存在redis和数据库里面，当数据发生变化的时候需要同时更新数据库和redis，由于更新操作具有先后顺序且redis不像数据库中的多表事务操作（满足ACID的特性），所以会出现数据一致性的问题</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h2><p>此情况下，若缓存更新失败，就会导致数据库和redis的数据不一样。</p><p>线程1连接到数据库，读取到了数据A，此时线程1停顿，线程2连接到数据库将数据A更改为数据B，并将B写入了redis完成了线程2的操作，然后线程1将读取到的数据A写入redis即把B覆盖。此时，数据库里面的数据为B，而redis里的数据为A</p><h2 id="先删除缓存后更新数据库"><a href="#先删除缓存后更新数据库" class="headerlink" title="先删除缓存后更新数据库"></a>先删除缓存后更新数据库</h2><p>理想情况下是应用下次访问redis的时候，发现redis里面是空值，就会从数据库里加载并保存至数据库，理论上可行。但在极端情况下，由于删除redis和更新数据库的两个操作均不是原子操作，所以还是会出现数据不一致</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>基于RocketMQ的可靠性消息通信实现数据的最终一致性</p><p>通过Canal组件监控数据库里面的binlog的日志，把更新后的数据同步到redis里面</p><p>采用延时双删的原则：先淘汰缓存，再写数据库，休眠一会儿后再淘汰缓存。因为存在了延时时间，目的就是为了先把查到的数据写入redis再删redis</p><h1 id="redis的线程安全问题"><a href="#redis的线程安全问题" class="headerlink" title="redis的线程安全问题"></a>redis的线程安全问题</h1><h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h2><p>是一个线程安全的K-V数据库，即在redis-server端去执行指令的时候不要任何的同步机制，不存在任何线程安全的问题，虽然6.0之后增加了多线程的模型，但该模型只是去处理网络的IO事件，对于指令的执行还是采用主线程来处理的，所以并不会存在多个线程同时去执行操作指令的情况。</p><p>没有采用多线程执行指令：</p><p>​本身可能出现的性能瓶颈点无非是网络IO、CPU、内存，但是CPU不是redis的瓶颈，所以就没必要采用多线程执行指令</p><p>​若采用多线程，那么所有指令就必须要考虑线程安全的问题，也就需要加锁来解决，这种方式反而会对性能造成更大的影响</p><h2 id="redis-client"><a href="#redis-client" class="headerlink" title="redis-client"></a>redis-client</h2><p>里面的指令操作都是原子性，但若有多个redis客户端同时执行多个指令就无法保证原子性。</p><p>比如：两个client同时去获取server上的key1，同时去修改和写入，因为多线程下原子性不能保证以及多进程的情况下共享资源访问的竞争问题也不能保证数据安全性</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>尽可能使用redis里面的原子指令</p><p>对个客户端的资源访问加锁</p><p>通过lua脚本实现多个指令的操作，去满足原子性</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis理解和分布式锁</title>
      <link href="/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="对redis的理解"><a href="#对redis的理解" class="headerlink" title="对redis的理解"></a>对redis的理解</h1><p>redis是一个高性能的基于Key-Value结构存储的NoSQL开源数据库，绝大部分都采用redis实现分布式缓存，从而去提高数据的的检索效率。</p><p>redis流行的原因：</p><p>​1 基于内存存储，在进行数据IO操作的时候能达到很高的QPS（官方给的10w）</p><p>​2 提供了非常丰富的数据存储结构，比如String、list、hash、set、zset</p><p>​3 底层采用单线程实现数据的IO，所以在数据算法层面不需要考虑并发安全性，从而让底层算法的时间复杂度基本都是常量复杂度</p><p>​4 虽然是内存存储，但却可以支持持久化，避免因服务器故障而导致的数据丢失问题</p><p>综上，redis一般是用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响，redis还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供了解决方案</p><h1 id="实现分布式锁中-zookeeper和redis的比较"><a href="#实现分布式锁中-zookeeper和redis的比较" class="headerlink" title="实现分布式锁中 zookeeper和redis的比较"></a>实现分布式锁中 zookeeper和redis的比较</h1><p>分布式锁：核心目的是为了解决在同一个时刻有多个进程或线程来访问共享资源所带来的安全性问题。锁又分为共享锁（在同一个时刻允许多个线程或进程访问共享资源，适用于幂等性场景，从而避免重复加锁的性能开销）和排它锁（同一个时刻只允许一个线程或进程访问该共享资源，适用于非幂等性场景）</p><p>实现分布式锁的最常用中间件就是zookeeper和redis</p><p>redis实现分布式锁方式：</p><p>​1 基于redis本身提供的指令：SET key value NX PX millisecounds。设置key的时候，若key已经存在与服务器上了会返回一个0，表示无法设置，否则就返回1表示设置成功。程序就根据0和1判断状态，从而表示去获得锁</p><p>​2 基于redission客户端实现，redission提供了分布式锁的封装方法，只需要调用封装好的api，<em><strong>lock()</strong></em> 和 ***unlock()***方法，就可以实现锁的抢占和释放。redission的所有指令都是通过lua脚本去实现，该脚本可以保证所有执行指令的原则性。另外，redission提供了一个watchdog，它会在我们获取锁后每隔10s去把key的时间延长，就避免锁的过期。</p><p>redis的缺点：</p><p>​在获得锁的时候，很简单，若获取不到锁就一直去尝试获取，会影响程序性能</p><p>​是一个&#x3D;&#x3D;AP模型&#x3D;&#x3D;，也就是可用性模型，集群模式中，存在数据一致性，会导致锁出现问题。即使使用了redlock算法实现分布式锁，但在某些复杂的场景下也不能保证锁的一定可用</p><p>zookeeper实现分布式锁：</p><p>​1 有序节点实现：每个线程或进程都到zookeeper上的<em><strong>lock</strong></em>目录下去创建一个临时有序节点，去表示抢占锁，所有创建的节点都会按照先后顺序生成带有有序编号的节点，线程创建节点后获取<em><strong>lock</strong></em>节点下的所有子节点，判断当前线程创建的节点是否是所有子节点里序号最小的，若是就获取锁成功。反之就需要对当前线程的前一个节点建立事件监听，当被监听的节点释放后，则触发回调告诉当前线程从而再次去尝试抢占锁</p><p> 使用redis还是比较常见，因为实际开发中极端情况少，redis本身的性能又高，在高并发中比较合适。</p><p>zookeeper是一个分布的协调组件，是&#x3D;&#x3D;一个CP模型&#x3D;&#x3D;所以更适合实现分布式锁。当获取不到锁就添加监听器，不用一直获取，就减少了性能。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java不可变类</title>
      <link href="/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/"/>
      <url>/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p><strong>不可变类</strong>：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p><p><strong>可变类</strong>：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><h1 id="不可变类优点"><a href="#不可变类优点" class="headerlink" title="不可变类优点"></a>不可变类优点</h1><p>主要有两点，效率和安全</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>当一个对象是不可变的，那么需要拷贝这个对象的内容时，就不用复制它的本身而只是复制它的地址，复制地址（通常一个指针的大小）只需要很小的内存空间，具有非常高的效率。同时，对于引用该对象的其他变量也不会造成影响。而且保证了hashCode 的唯一性，因此可以放心地进行缓存而不必每次重新计算新的哈希码。而哈希码被频繁地使用, 比如在hashMap 等容器中。将hashCode 缓存可以提高以不变类实例为key的容器的性能。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>是指线程安全</p><p>在多线程情况下，一个可变对象的值很可能被其他进程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况同时省去了同步加锁等过程，因此不可变类是线程安全的。</p><p>当然，不可变类也有缺点：不可变类的&#x3D;&#x3D;每一次“改变”都会产生新的对象，因此在使用中不可避免的会产生很多垃圾&#x3D;&#x3D;</p><h1 id="不可变类的设计"><a href="#不可变类的设计" class="headerlink" title="不可变类的设计"></a>不可变类的设计</h1><p>类使用final修饰，保证类不被继承</p><p>所有成员变量都被private和final修饰</p><p>不提供成员变量的setter方法</p><p>通过构造器初始化所有成员，进行深拷贝</p><p>在getter方法中，不直接返回对象本身，而是克隆对象并返回对象的拷贝内容</p><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>String源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="type">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="type">char</span> result[] = <span class="keyword">new</span> <span class="title class_">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可观察到</p><p>​String类被final修饰，就不能被继承</p><p>​内部变量所有成员都设置为私有变量</p><p>​没有setter方法</p><p>​&#x3D;&#x3D;传入可变数组时，进行copy而不是直接将数组赋值给内部变量&#x3D;&#x3D;</p><p>​获取value时不是直接返回对象引用，而是返回对象的copy</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​String不能被修改，让JVM可实现字符串常量池，该常量池可在运行时节约内存空间，不同字符串指向相同自变量时都指向字符串常量池中的同一对象，&#x3D;&#x3D;即提升了性能，节约了资源&#x3D;&#x3D;，更因为不可变性保证了线程安全</p><h2 id="String是否真的不可变"><a href="#String是否真的不可变" class="headerlink" title="String是否真的不可变"></a>String是否真的不可变</h2><p>虽然String对象将value设置为final,并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">char</span>[] valueCharArr = (<span class="type">char</span>[]) valueField.get(str);</span><br><span class="line">            valueCharArr[<span class="number">0</span>] = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">            valueField.set(str, <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = ABCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = GBCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = 12</span><br><span class="line">hashCode = 2001986</span><br></pre></td></tr></table></figure><p>由打印结果可知，字符串str的值发生了改变，哈希值没有发生变化。即通过反射可以修改“不可变”对象</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不可变类是实例创建后就不可以改变成员遍历的值。这种特性使得不可变类提供了线程安全的特性但同时也带来了对象创建的开销，每更改一个属性都是重新创建一个新的对象。JDK内部也提供了很多不可变类如Integer、Double、String等。</p><p>String的不可变特性主要为了满足&#x3D;&#x3D;常量池的使用&#x3D;&#x3D;、&#x3D;&#x3D;线程安全&#x3D;&#x3D;、&#x3D;&#x3D;类加载&#x3D;&#x3D;、&#x3D;&#x3D;提高运行速度&#x3D;&#x3D;、&#x3D;&#x3D;避免网络问题&#x3D;&#x3D;。合理使用不可变类可以带来极大的好处。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不可变类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
