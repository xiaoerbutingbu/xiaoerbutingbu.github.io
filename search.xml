<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IP</title>
      <link href="/2022/07/16/IP/"/>
      <url>/2022/07/16/IP/</url>
      
        <content type="html"><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><p>网络层，<em><strong>实现主机与主机之间的通信，点对点通信</strong></em></p><p>MAC（数据链路层）是实现 直连 两个设备之间通信，IP是在没有直连的两个网络之间进行通信传输。个人理解：计划和实施的区别。IP是整个旅游行程表，MAC是行程表里的交通工具。</p><p>&#x3D;&#x3D;源IP地址和目标IP地址不会变化，只有源MAC地址和目标MAC一直在变化&#x3D;&#x3D;</p><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><p>IP地址（IPv4地址）32位，在计算机中二进制方式处理。点分十进制的标记方式处理</p><p>分类：A,B,C,D,E类</p><p>A（0<del>127.255.255.255）,B（128</del>191.255.255.255）,C（192~223）主要两部分，网络号和主机号（比如：A小区1栋101号和B小区1栋101号）</p><p>A,B,C类中有私有IP和公有IP区分</p><p>解析IP地址，看第一个0出现在哪一位。在第一位是A类，第二为是B类，依次类推</p><p>广播地址</p><p>用于在同一个链路中互相连接的主机之间发送的数据包</p><p>​    分为：本地广播（本网络内广播）和直接广播（不同网络间的广播）</p><p>D类和E类地址没有主机号，不可用于主机IP。</p><p>D类常用于多播，E类是预留的分类，暂未使用</p><p>多播地址</p><p>​    用于将包发送给特定组内的所有主机</p><h3 id="IPV4分类的优缺点"><a href="#IPV4分类的优缺点" class="headerlink" title="IPV4分类的优缺点"></a>IPV4分类的优缺点</h3><p>优点：简单明了、选路（基于网络地址）简单</p><p>缺点：同一网络下没有地址层次，就缺少地址的灵活性；不能很好与现实网路匹配</p><p>两个缺点都可在CIDR无分类地址解决：前面是网络号，后面是主机号</p><p>​    以a.b.c.d&#x2F;x形式表示，比如10.100.122.2&#x2F;24: &#x2F;24表示前24位是网络号，剩余是主机号。</p><h2 id="问点"><a href="#问点" class="headerlink" title="问点"></a>问点</h2><p>为什么要分离网络号和主机号：两台计算机要通讯，首先判断是否处于同一个广播域内，即网络地址是否相同。若相同，表名接收方在本网络上，数据包就可以发送到目标主机</p><p>怎么划分子网：子网掩码的作用之一就是划分子网，将主机地址分为 子网网络地址和子网主机地址</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>是128位，与v4比，可分配的地址变多；可自动装配；包头包首部长度固定的40字节，去掉包头检验和，简化了首部结构，减轻了路由器符合，提高传输的性能；可伪造IP地址的网络安全，防止窃听，提升了安全性</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>单播地址：一对一通信；</p><p>组播地址：一对多通信；</p><p>任播地址：通信最近的节点，最近的节点由路由协议决定</p><p>没有广播地址</p><h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS：可将域名网址自动转换成具体的IP地址。越靠右，层级越高</p><p>层级关系：根DNS服务器，顶级域DNS服务器，权威DNS服务器</p><p>解析流程：</p><p>客户端发送DNS请求，并发给本地DNS解析器；本地域名解析器收到请求后，若缓存中能找到就直接返回IP地址，反之本地DNS会去问它的根域名服务器；根DNS收到请求后，发现后置是.com，就给本地DNS关于顶级域名服务器的地址；本地DNS收到后再发请求给顶级域名服务器，顶级域名服务器就返回权威域名服务器的地址；本地收到后，发送权威域名服务器请求，权威域名查询后将IP地址告诉给本地DNS。本地DNS将得到的IP地址返回给客户端，客户端建立连接</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在传输IP数据包的时候，确定了源IP和目标IP后，就通过路由表确定IP数据包下一跳、因为网络层下面是数据链路层，所以要知道下一跳的MAC地址。</p><p>因为主机路由表可找到下一跳的IP地址，所以可通过ARP协议，求下一跳MAC地址</p><p>即已知IP地址求MAC地址</p><p>ARP就是借助ARP请求域ARP响应两种类型确定MAC地址</p><p>主机通过广播发送ARP请求（里面有想知道的MAC地址的主机IP地址）；同个链路中所有设备收到ARP请求时，会自动拆开ARP里的内容，若里面的IP地址与自己的一致就将自己MAC地址放入ARP响应包返回给主机</p><p>操作系统会把第一次获取的MAC地址缓存起来（有期限）。</p><p>RARP：已知MAC地址求IP地址。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态获取IP地址，省去了配IP信息繁琐过程</p><p>步骤：</p><p>​    客户端发起DHCP发现报文的IP数据报（用的UDP广播通信，因IP地址、DHCP服务器地址都不知道），并用0.0.0.0作为源IP地址，255.255.255.255为广播目的地址。DHCP客户端将该IP数据包传给MAC，MAC再将帧广播到所有网络设备中</p><p>​    DHCP服务器收到DHCP报文时向客户端响应，里面包含IP地址、子网掩码等信息。客户端收到一个或多个服务器的DHCP提供报文后，选择一个服务器，并对其发送DHCP请求报文进行响应，回显配置的参数。服务端用DHCP ACK报文进行响应，回应其要求的参数</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>网络地址转换NAT，缓解IPV4地址耗尽的问题</p><p>简单说就是在主机对外通信时，把私有IP地址转换成公有IP地址</p><p>缺点：外部无法主动与NAT内部服务器建立连接，因NAPT转换表没有转换记录；转换表的生成与转换操作会产生性能开销；通信过程中，若NAT路由器重启了，所有TCP链接将重置</p><p>解决：改用IPV6；NAT穿透技术</p><h3 id="ICMP（互联网控制报文协议）"><a href="#ICMP（互联网控制报文协议）" class="headerlink" title="ICMP（互联网控制报文协议）"></a>ICMP（互联网控制报文协议）</h3><p>主要功能：确认IP包是否到达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置</p><p>分类</p><p>​    查询报文类型：诊断查询信息</p><p>​    差错报文类型：通知出错原因的错误信息</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四次挥手</title>
      <link href="/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1）客户端就进入FIN_WAIT_1状态，等待服务器发FIN报文；</p><p>当服务器端收到FIN后，发送ACK应答报文，服务端就进入close_wait状态，</p><p>客户端收到ACK应答报文后，进入FIN_WAIT_2状态</p><p>服务端做最后的数据处理（读到结束符EOF）已发送完成，则向客户端发FIN报文，服务端就进入LAST_ACK状态 ；</p><p>客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传），就进入TIME_WAIT状态；</p><p>服务器端收到ACK就关闭（CLOASE状态），客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/07/14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/guocheng.png"></p><h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><p>关闭连接时，客户端向服务端发送FIN后，表示客户端不再发数据，但是能接收数据</p><p>服务端收到FIN后，先回ACK应答，但可能还有数据处理和发送不能立马关闭socket，等不再发数据后，才发FIN表示同意现在关闭连接。</p><p>所以，服务端需要等待完成数据的发送和处理，ACK和FIN一般都会分开发送，所以多一次</p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么TIME_WAIT等待时间是2MSL：是报文最大生存时间，超过这个时间报文将被丢弃。因为TCP报文基于IP协议的，IP头部中有一个TTL字段，是IP数据报可以经过最大路由数，<em><strong>MSL要  &amp;ge; TTL消耗为0的时间</strong></em>。2MSL是从<em><strong>客户端收到FIN后发送ACK开始计时的</strong></em>，若客户端的ACK没有传到服务端，客户端就又会收到来自服务端的FIN报文，那么2MSL将重新计时</p><p>为什么需要TIME_WAIT：主动发起关闭连接的一方才会有TIME-WAIT状态。需要TIME-WAIT状态，是<em><strong>防止接收到具有相同的四元组出现的旧数据包</strong></em>，2MSL足以上两个方向上数据包都被丢掉，保证出现的数据包一定是建立连接时所产生的；保证连接能正确关闭：给出足够的时间确保最后的ACK能让被动关闭方接收</p><p>TIME_WAIT过多的危害：内存资源占用；端口资源的占用，一个TCP连接至少消耗一个本地端口，若沾满了所有端口，就不能创建新链接</p><p>若已建立了链接，但客户端突然故障：</p><p>​TCP的&#x3D;&#x3D;保活机制&#x3D;&#x3D;：定义一个时间段，该时间段内，若没有任何连接相关的活动，TCP保活机制就会开始作用，每隔一个时间段就发探测报文（数据很少），若连续几个探测报文没有回应，则认为当前TCP连接已死亡，系统内核就将错误信息通知给上层应用</p><p>​对端程序工作正常：TCP保活的探测报文，对端会正常响应，TCP保活时间会被重置</p><p>​对端程序崩溃并重启：发探测报文，对端可响应，但是没有该连接的有效信息，会产生一个RST报文，就很块发现TCP连接已被重置</p><p>​对端程序崩溃或其他原因让报文能不到达：探测报文不能得到响应，TCP会报告该TCP连接已死亡</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>四次挥手优化</p><p>​    主动方优化：发FIN报文的方式有close和shutdown，所以发送更改方式。调整FIN重传次数。调整状态时间和孤儿连接的上限个数。</p><p>   被动方优化：复用time_wait状态的连接（只使用于客户端）</p><p>Close：断开后，不能传输数据也不能发数据。</p><p>Shutdown：控制只关闭一个方向的连接</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP怎么保证可靠传输</title>
      <link href="/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
      <url>/2022/07/13/TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="普通处理"><a href="#普通处理" class="headerlink" title="普通处理"></a>普通处理</h1><p>应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传送</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；</p><p>TCP会在<strong>数据包丢失和确认应答丢失后发生超时重传</strong></p><p>设置的时间RTO：RTO太大，重发慢，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时。所以，设置的RTO应该略大于报文忘返RTT的值</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>以<em><strong>数据驱动重传</strong></em>。收到三个相同ACK报文时，会在定时器过期之前，重传文段。</p><p>只解决了超时时间的问题，有另一个问题：重传的时候，是重传一个，还是重传之前的所有，所以就有了SACK方法</p><h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p>在TCP头部的“选项”字段中添加一个SACK，<em><strong>将缓存的地图发送给发送方</strong></em>，发送方就知道哪些数据收到了，哪些没有，就可以<em><strong>只传丢失的数据</strong></em>、</p><h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p>使用了SACK告诉 发送方，有哪些数据被重复接收了。</p><p>可以让发送方知道，是发出去的包丢了；可以知道是不是发送方的数据包被网略延时了；可以知道网络中是不是把发送方的数据包给复制了</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>TCP是每发一个数据，收到回应后再发下一个，数据包忘返时间长，通信效率低。</p><p>发送方会定时发送窗口大小探测报文，及时知道接收方窗口大小辩护</p><p>窗口大小就是指<em><strong>无需等待确认应答，可以继续发送数据的最大值</strong></em></p><p>大小在TCP头部，该字段是接收端告诉发送端自己有多少缓冲区可接收数据，发送端根据这个发送数据</p><p>接收窗口和发送窗口大小不完全相等：接收窗口大小约等于发送窗口大小。因为滑动窗口大小不是一成不变，若接收方的程序读取数据很快，接收的滑动窗口就会空出来。那么新的接收窗口大小，是通过TCP头部的窗口大小字段告诉发送方，传输存在时延，所以两者是约等于的关系</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率，根据接收方的实际接收能力变化</p><p>窗口关闭：窗口大小为0，就会阻止发送方传递数据，直到窗口非0。当窗口关闭时，接收方处理完数据后会发送一个窗口非0的ACK报文，若该报文丢失，那会出现问题</p><p>​解决窗口关闭时潜在的死锁现象：TCP为每一个连接设置定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器。该计时器若超时，就发送窗口探测报文，对方在确认该探测报文时会给出自己的窗口大小</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>目的是<em><strong>避免发送方的数据填满整个网络</strong></em></p><p>拥塞窗口是发送方维护的一个状态变量，根据网络的拥塞程度动画变化。</p><p>发送了超时重传，就认为网络出现拥塞</p><h2 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h2><p>慢启动：当发送方每收到一个ACK，拥塞窗口CWND的大小就加1。当没启动到ssthresh就使用拥塞避免算法</p><p>拥塞避免：每收到一个ACK时，CWND增加1&#x2F;CWND</p><p>拥塞发生：就出现数据包重传</p><p>​超时重传：ssthresh设为CWND&#x2F;2，CWND重置为1</p><p>​快速重传：CWND为原来的一半，ssthresh&#x3D;CWND，进入快速恢复算法</p><p>快速恢复：拥塞窗口CWND&#x3D;ssthresh+1；重传丢失的数据包；若重复收到ACK，CWND+1；收到新的ACK后，CWND就设置为第一步中的ssthresh的值，恢复到之前的状态</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手</title>
      <link href="/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
      <url>/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="三次握手简述"><a href="#三次握手简述" class="headerlink" title="三次握手简述"></a>三次握手简述</h1><p>目的是建立可靠的通信信道，也就是双方确认自己与对方发送与接收是正常的</p><p>TCP连接：用于保证可靠性和流浪控制维护的某些状态信息，包括socket、序列号和窗口大小</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><img src="/2022/07/12/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/guocheng.png"></p><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端<strong>随机初始化序号</strong>，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以<em><strong>阻止重复历史连接的初始化</strong></em>（最主要，若是两次握手就不能判断，防止旧的重复连接初始化造成混乱）：若是历史连接，客户端发送的报文就是RST报文，反之则是ACK报文</p><p><em><strong>同步双方的初始序列号</strong></em>：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发出去的数据包，哪些已被对方收到</p><p>避免资源浪费：若服务端阻塞，发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：<strong>无法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立</strong>，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p><em><strong>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</strong></em></p><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><p>为什么客户端和服务端和初始序列号ICN是不同的若一个已经失效的连接被重用了，但旧连接的历史报文还残留在网络中，若序列号相同究就不能判断该报文是不是历史报文，历史报文被接收就会发生数据混乱。所以每次建立连接前重新初始化序列号是为了<em><strong>通信双方能根据序号将不属于本连接的报文丢弃</strong></em></p><p>SYN攻击：攻击者短时间伪造不同的IP地址的SYN报文，服务端每收到一个SYN报文，就进入下一个状态，但服务端发送的ACK+SYN报文无法得到IP的ACK应答，久而久之就沾满SYN接收队列（未连接队列），服务器就不能为正常的用户服务。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>​     客户端优化：修改SYN重传次数、调整客户端的三次握手时间上限。</p><p>​     服务端优化：调整SYN半连接队列大小，增大accept全连接队列大小</p><p>​     绕开三次握手：客户端从第二次向服务器建立连接之后。就减少了1个RTT时间的（客户端到服务器端的忘返时间）消耗。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度算法</title>
      <link href="/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/08/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>无论是在批处理系统还是分时系统中，用户进程数一般都多用于处理机数，这将导致它们互相争夺处理。另外，系统进程也同样需要使用处理机。<br>这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><h1 id="7种调度算法"><a href="#7种调度算法" class="headerlink" title="7种调度算法"></a>7种调度算法</h1><h2 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h2><p>最简单的一种调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><p>算法思想：主要从“公平的角度考虑”</p><p>规则：按照作业&#x2F;进程到达的先后顺序进行服务</p><p>用于作业&#x2F;进程调度：用于作业调度时，考虑的是哪个作业先到达后备<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>；用于进程调度时，考虑的是哪个进程先到达就绪队列</p><p><strong>非抢占式的算法</strong></p><p><strong>优缺：</strong> 公平、算法实现简单<br><strong>缺点：</strong> 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利<br><strong>不会导致饥饿</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">周转时间=作业完成时间-作业提交时间</span><br><span class="line">平均周转时间=各作业周转时间之和 / 作业数</span><br><span class="line">带权周转时间=作业周转时间 / 作业实际运行的时间=（作业完成时间-作业提交时间）/ 作业实际运行的时间</span><br></pre></td></tr></table></figure><h2 id="短作业优先的调度算法（SJF）"><a href="#短作业优先的调度算法（SJF）" class="headerlink" title="短作业优先的调度算法（SJF）"></a>短作业优先的调度算法（SJF）</h2><p>从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。</p><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级</p><h2 id="时间⽚轮转调度算法-RR"><a href="#时间⽚轮转调度算法-RR" class="headerlink" title="时间⽚轮转调度算法(RR)"></a>时间⽚轮转调度算法(RR)</h2><p>时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许运⾏的时间。</p><h2 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h2><p>最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p><h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>根据比率：<em><strong>R&#x3D;(w+s)&#x2F;s</strong></em> （R为响应比，w为等待处理的时间，s为预计的服务时间）</p><p>如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p><p> 高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p><strong>根据公式可知：</strong></p><ul><li>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</li><li>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</li><li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</li></ul><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</p><p>多级反馈队列调度算法的实现思想如下：</p><ol><li>应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</li><li>赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。</li><li>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</li><li>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWiteArrayList</title>
      <link href="/2022/07/04/CopyOnWiteAayList/"/>
      <url>/2022/07/04/CopyOnWiteAayList/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>写数组的拷贝，<em><strong>支持高效率并发且是线程安全</strong></em>，读操作无锁的ArrayList。所有操作都是通过对底层进行一次新的复制实现</p><p>适用于读操作远远大于写操作的场景里。</p><p>存在扩容的概念，因为每次写操作都要复制一个副本，在副本的基础上修改后改变Aray引用。写操作需要大面积复制数组，所以性能很差</p><p><em><strong>读多写少</strong></em>的场景</p><h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><p>核心：创建新副本，读写分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;<span class="comment">//内部维护的数组</span></span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (E) a[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>直接通过下标访问数组，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有CAS操作。因为只是读，不会进行任何修改</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局的锁的状态</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当下（旧）的数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">//创建新的数组，并将旧的数组所有数据赋值到新的数组中</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//在末尾添加新的数据</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//将旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                    <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">            Object[] newElements;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index;</span><br><span class="line">            <span class="comment">//如果就是插入到末尾</span></span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//旧数组里的所有数据都赋值到新的数组</span></span><br><span class="line">                newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//声明新长度的数组</span></span><br><span class="line">                newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//以要插入的位置为分界线，把插入的下标的数据空出来</span></span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                 numMoved);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往index插入数据</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">//旧数组的引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add方法采用ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份数据被复制的数组；因为一开始的数组引用时被volatile修饰，根据happens-beffore规则，写线程对数组引用的修改对读线程是可见的；</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//获取全局锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="comment">//获取的数组中下标为index的数据值</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">            <span class="comment">//如果数组里该下标本身的值与需要设定的值不一样</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">                <span class="comment">//旧数组的值复制到新数组里</span></span><br><span class="line">                Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">                <span class="comment">//在下标为index处赋值</span></span><br><span class="line">                newElements[index] = element;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一样就不需要更改，直接修改旧数组的引用即可</span></span><br><span class="line">                <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>remove、removeRange与上面都类似</p><h2 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h2><p>读读共享、其他都互斥</p><p>读写锁规则的升级：读取时完全不用加锁的，并且更厉害的是，<em><strong>写入也不会阻塞读操作</strong></em></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>读多写少的场景，写即使慢一些也行</p><p>场景：黑名单、每日更新；监听看；迭代操作远多余修改操作</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>数据一致性问题：CopyOnWite容器只能<em><strong>保证数据的最终一致性</strong></em>，不能保证数据<em><strong>实时</strong></em>的一致性。所以，一旦写入不会马上就可以被读到</p><p>内容占用：因为通过复制机制开辟出一个新的副本，进行写操作时，内存里会同时驻扎两个对象的内存</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程安全的集合类</title>
      <link href="/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2022/07/02/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>vector与ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全的，它给几乎所有的public方法都加上了synchronized关键字，也正因为如此，加锁导致性能降低，在不需要并发访问同一对象时，这种强制性的同步机制就显得多余，所以现在Vector已被弃用。</p><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>HashTable和HashMap类似，不同点是HashTable是线程安全的，它给几乎所有public方法都加上了synchronized关键字，还有一个不同点是HashTable的K，V都不能是null，但HashMap可以，它现在也因为性能原因被弃用了。</p><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Vector和HashTable被弃用后，它们被ArrayList和HashMap代替，但它们不是线程安全的，所以Collections工具类中提供了相应的包装方法把它们包装成线程安全的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Set&lt;E&gt; synHashSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;E&gt;());</span><br><span class="line"></span><br><span class="line">Map&lt;K,V&gt; synHashMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K,V&gt;());</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步。</p><h1 id="Java-util-concurrent包中的集合"><a href="#Java-util-concurrent包中的集合" class="headerlink" title="Java.util.concurrent包中的集合"></a>Java.util.concurrent包中的集合</h1><h4 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h4><p>ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而ConcurrentHashMap是更细粒度的加锁。</p><p>在JDK1.8之前，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment含有整个table的一部分，这样不同分段之间的并发操作就互不影响。</p><p>JDK1.8对此做了进一步的改进，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</p><h4 id="2-CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#2-CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="2.CopyOnWriteArrayList和CopyOnWriteArraySet"></a>2.CopyOnWriteArrayList和CopyOnWriteArraySet</h4><p>它们是加了写锁的ArrayList和ArraySet，锁住的是整个对象，但读操作可以并发执行。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autowired和Resource</title>
      <link href="/2022/06/25/Autowired%E5%92%8CResource/"/>
      <url>/2022/06/25/Autowired%E5%92%8CResource/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>@Auwired：</p><p>对成员变量、方法及构造函数进行标注，完成自动装配的工作</p><p>@Resource：</p><p>​官方定义：在语义上被定义为通过其唯一的名称来标识特定的目标组件，其中声明的类型与匹配过程无关</p><p>​若没有明确指定名称，则默认名称是从字段名称或设置方法（get、set方法）派生的。若用在字段上，则采用字段名称；如果用在setter方法，它采用其属性名称（例如setProperty()方法，取property作为属性名称）    </p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>包含的属性不同：</p><p>​Autowired只包含一个参数：required，表示是否开启自动注入，默认是true</p><p>​Resource有七个参数，其中最重要的两个参数：name和type</p><p>注解使用的地方不同：</p><p>​Autowired可以用在构造方法、方法、参数、成员变量和注解上</p><p>​Resource可以用在类、成员变量、方法上</p><p>出处不同：</p><p>​Autowired是Spring定义的注解，所以只能用在Spring框架下</p><p>​Resource是JSR-250定义的注解，所以可以与其他框架一起使用</p><p>自动装配的方式不同：</p><p>​Autowired默认按byType，如果要使用byName，需要结合@Qualifier注解配合使用</p><p>​Resource默认byName自动装配，如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配</p><p>自动装配的顺序：</p><p>​Autowired：默认先按byTpe进行匹配，若发现找到多个bean则又按照byName方式进行匹配，如果还有多个，则抛出异常</p><p>​<img src="/2022/06/25/Autowired%E5%92%8CResource/A.png" alt="image-20220625222414253"></p><p>​Resource：</p><p>​若同时指定了name和type：会从容器中查找name和type唯一匹配bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了name：则按name后的名字去bean元素里查找有与之相等的name属性的bean，若找到则自动装配，找不到则抛出异常</p><p>​只指定了type：则从上下文汇总找到类型匹配的<em><strong>唯一</strong></em>bean进行装配，找不到或者找到多个，都会抛出异常</p><p>​都没有指定：自动按照byName方式找，若没有找到符合的bean，则回退为一个原始类型进行查找，如果找到就注入，没找到或者找到多个则抛出异常</p><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro</title>
      <link href="/2022/06/16/Shiro/"/>
      <url>/2022/06/16/Shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/06/16/Shiro/jiegou1.png" alt="image-20220616152612753"></p><p><strong>Subject</strong>：主体，外部应用与subject进行交互，subject记录当前的用户。外部程序通过subject进行认证权限，subject通过Security Manager安全管理进行认证</p><p><strong>Security Manager</strong>：对全部subject进行安全管理，核心。可以对subjectManager完成subject的认证、授权，实质上是通过Authenticator</p><p>本身是一个接口，继承了Authenticator、Authorizer、SessionManager三个接口</p><p><strong>Authenticator</strong>：认证器，对用户身份进行认证，本身是一个接口，shiro提供ModularRealmAuthenticator的实现类，可以满足大部分需求</p><p><strong>Authorizer</strong>：授权器，用户通过授权器，用户通过认证器通过，在访问功能时需要通过授权器判断用户是否能操作的权限</p><p><strong>Realm</strong>：就相当于datasource数据源，subjectManager进行安全认证需要通过Realm获取用户权限数据</p><p><strong>SessionManager</strong>：会话管理，shiro定义了一套会话管理，不依赖web容器的session</p><p><strong>CacheManager</strong>：缓存管理，将用户的权限数据存储在缓存</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>即身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确</p><p>Subject：访问系统的用户，主体可以是用户、程序等</p><p>Principal：身份信息，是主体进行身份认证的标识，标识必须具有唯一性，一个主体可以有多个身份，但必须有一个主身份</p><p>credential：凭证信息，是只有主体自己知道的安全信息</p><h1 id="权限字符串"><a href="#权限字符串" class="headerlink" title="权限字符串"></a>权限字符串</h1><p>资源标识符：操作：资源实例标识符    对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用*通配符。</p><p>比如：用户创建权限   user:create  或 user:create:*</p><p>​用户实例001的所有权限 user:*:001</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><em><strong>以下所有代码来源于“编程不良人”</strong></em></p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 授权</span></span><br><span class="line"><span class="comment">     * @param principals</span></span><br><span class="line"><span class="comment">     * @return AuthorizationInfo</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">//获取身份信息 内容根据实际情况(看源码了解)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">primaryPrincipal</span> <span class="operator">=</span> (String) principals.getPrimaryPrincipal();</span><br><span class="line">        System.out.println(<span class="string">&quot;PrincipalCollection      &quot;</span>+primaryPrincipal);</span><br><span class="line">        <span class="comment">//从工厂中获取service对象</span></span><br><span class="line">        <span class="comment">//根据主身份信息获取角色 和 权限信息</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils</span><br><span class="line">                .getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="comment">//根据userService找到用户信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findRolesByUserName(primaryPrincipal);</span><br><span class="line">        <span class="comment">//授权角色信息</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(user.getRoles()))&#123;</span><br><span class="line">            <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">            user.getRoles().forEach(role-&gt;&#123;</span><br><span class="line">                <span class="comment">//从数据库中查出来的权限给该对象</span></span><br><span class="line">                simpleAuthorizationInfo.addRole(role.getName());</span><br><span class="line">                <span class="comment">//从数据库中角色具备的权限信息</span></span><br><span class="line">                List&lt;Perms&gt; perms = userService.findPermsByRoleId(role.getId());</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(perms))&#123;</span><br><span class="line">                    perms.forEach(perm-&gt;&#123;</span><br><span class="line">                        <span class="comment">//对该角色赋予相应的权限</span></span><br><span class="line">                        simpleAuthorizationInfo.addStringPermission(perm.getName());</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * @Description: 身份认证,主体调用用户登录时，会调用该方法</span></span><br><span class="line"><span class="comment">     * @param token</span></span><br><span class="line"><span class="comment">     * @return AuthenticationInfo 里面收集用户提交的身份（比如：用户名）和凭据（比如：密码）</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取身份信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> (String) token.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">credentials</span> <span class="operator">=</span> (String) token.getCredentials();</span><br><span class="line">        <span class="comment">//在工厂中获取service对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ApplicationContextUtils.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUserName(principal);</span><br><span class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(user))&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   用户名</span></span><br><span class="line"><span class="comment">            *   加密的密码</span></span><br><span class="line"><span class="comment">            *   随机盐</span></span><br><span class="line"><span class="comment">            *   当前realm的名称</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user.getUsername(),user.getPassword(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MyByteSource</span>(user.getSalt()),</span><br><span class="line">                    <span class="built_in">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="doGetAuthenticationInfo中的principal和credentials的来源"><a href="#doGetAuthenticationInfo中的principal和credentials的来源" class="headerlink" title="doGetAuthenticationInfo中的principal和credentials的来源"></a>doGetAuthenticationInfo中的principal和credentials的来源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password,String code,HttpSession session)</span> &#123;</span><br><span class="line">       <span class="comment">//比较验证码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">codes</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (codes.equalsIgnoreCase(code))&#123;</span><br><span class="line">               <span class="comment">//获取主体对象</span></span><br><span class="line">               <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">               <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">               <span class="comment">//  重点  重点</span></span><br><span class="line">               <span class="comment">//将该UsernamePasswordToken类对象作为token专递给doGetAuthenticationInfo</span></span><br><span class="line">               subject.login(token);</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;验证码错误!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;用户名错误!&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(<span class="string">&quot;密码错误!&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/user/loginview&quot;</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="UsernamePasswordToken源码"><a href="#UsernamePasswordToken源码" class="headerlink" title="UsernamePasswordToken源码"></a>UsernamePasswordToken源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordToken</span> <span class="keyword">implements</span> <span class="title class_">HostAuthenticationToken</span>, RememberMeAuthenticationToken &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> rememberMe;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"><span class="comment">//省去了所有构造方法以及所有set方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] getPassword() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过该方法得到的username</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRememberMe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rememberMe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.host = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.rememberMe = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.password != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.password.length; ++i) &#123;</span><br><span class="line">                <span class="built_in">this</span>.password[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.password = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义的realm进行操作的配置"><a href="#自定义的realm进行操作的配置" class="headerlink" title="自定义的realm进行操作的配置"></a>自定义的realm进行操作的配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shiroDialect&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建shiroFilter  //负责拦截所有请求</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager defaultWebSecurityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//给filter设置安全管理器</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   可以实现权限相关的拦截器</span></span><br><span class="line"><span class="comment">         *       常用:</span></span><br><span class="line"><span class="comment">         *           anon:无需认证(登录)也已访问</span></span><br><span class="line"><span class="comment">         *           authc:必须认证和授权才可以访问</span></span><br><span class="line"><span class="comment">         *           user:若使用rememberMe的功能可以直接访问</span></span><br><span class="line"><span class="comment">         *           perms:该资源必须资源权限才可以访问</span></span><br><span class="line"><span class="comment">         *           role：该资源必须得到角色权限</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//配置系统受限资源</span></span><br><span class="line">        <span class="comment">//配置系统公共资源</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/getImage&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/register&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/registerview&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);<span class="comment">//anon 设置为公共资源  放行资源放在下面</span></span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);<span class="comment">//authc 请求这个资源需要认证和授权</span></span><br><span class="line">        <span class="comment">//默认认证界面路径,没有登录的用户就都可以访问的</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/user/loginview&quot;</span>);</span><br><span class="line">        <span class="comment">//放在过滤链里面</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="comment">//未授权的</span></span><br><span class="line">        <span class="comment">//shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建安全管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(Realm realm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//给安全管理器设置</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建自定义realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Realm <span class="title function_">getRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CustomerRealm</span> <span class="variable">customerRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerRealm</span>();</span><br><span class="line">        <span class="comment">//修改凭证校验匹配器</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//设置加密算法为md5</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">//设置散列次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//放入realm</span></span><br><span class="line">        customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="comment">//开启缓存管理，用redis缓存信息</span></span><br><span class="line">        customerRealm.setCacheManager(<span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>());</span><br><span class="line">        customerRealm.setCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启全局缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCachingEnabled(<span class="literal">true</span>);<span class="comment">//认证认证缓存</span></span><br><span class="line">        customerRealm.setAuthenticationCacheName(<span class="string">&quot;authenticationCache&quot;</span>);</span><br><span class="line">        customerRealm.setAuthorizationCachingEnabled(<span class="literal">true</span>);<span class="comment">//开启授权缓存</span></span><br><span class="line">        customerRealm.setAuthorizationCacheName(<span class="string">&quot;authorizationCache&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customerRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的RediscacheManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheManager</span> <span class="keyword">implements</span> <span class="title class_">CacheManager</span> &#123;</span><br><span class="line">    <span class="comment">//参数1:认证或者是授权缓存的统一名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; Cache&lt;K, V&gt; <span class="title function_">getCache</span><span class="params">(String cacheName)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;redis Cache      &quot;</span>+cacheName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCache</span>&lt;K,V&gt;(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现redis作为缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span>&lt;k,v&gt; <span class="keyword">implements</span> <span class="title class_">Cache</span>&lt;k,v&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cacheName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">(String cacheName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheName = cacheName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">get</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get              &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;get key:&quot;</span>+k);</span><br><span class="line">        System.out.println( <span class="string">&quot;redis  get value     &quot;</span>+getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString()));</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().get(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">put</span><span class="params">(k k, v v)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;put           &quot;</span>+<span class="built_in">this</span>.cacheName);</span><br><span class="line">        System.out.println(<span class="string">&quot;put key: &quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;put value:&quot;</span>+v);</span><br><span class="line">        getRedisTemplate().opsForHash().put(<span class="built_in">this</span>.cacheName,k.toString(),v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> v <span class="title function_">remove</span><span class="params">(k k)</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============remove=============&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (v) getRedisTemplate().opsForHash().delete(<span class="built_in">this</span>.cacheName,k.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;=============clear==============&quot;</span>);</span><br><span class="line">        getRedisTemplate().delete(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().size(<span class="built_in">this</span>.cacheName).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;k&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().keys(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;v&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().values(<span class="built_in">this</span>.cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate <span class="title function_">getRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用于接口（接口式）"><a href="#作用于接口（接口式）" class="headerlink" title="作用于接口（接口式）"></a>作用于接口（接口式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@RequiresRoles(value=&#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span><span class="comment">//用来判断角色  Logical.OR:满足其中一个就行   logical = Logical.AND:要同时满足</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;user:update:01&quot;)</span> <span class="comment">//用来判断权限字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入方法多个&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用于接口（编程式）"><a href="#作用于接口（编程式）" class="headerlink" title="作用于接口（编程式）"></a>作用于接口（编程式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">save1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">       <span class="keyword">if</span> (subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">           <span class="comment">//有权限</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有权限</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外还有标签式，因采用前后端分离，便不再展示</p>]]></content>
      
      
      <categories>
          
          <category> 权限框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud简单阐述</title>
      <link href="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
      <url>/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Spring社区有大一统java的趋势，快速构建一个单体单元SpringBoot，分布式微服务解决方案，SpringCloud和SpringFrameWork和各种组件等等</p><p>SpringCloud是一个分布式的微服务解决方案。区别于Dubbo，Dubbo只是一个远程RPC框架，而前者则是一整套的解决方案，包括<strong>服务注册、服务调用、负载均衡、服务网关、服务降级与熔断、分布式配置管理、消息总线</strong>等等技术。</p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou3.png" alt="1"></p><p>SpringCloud 是微服务架构的集大成者，将一系列优秀的组件进行了整合。基于springboot构建，对我们熟悉spring的程序员来说，上手比较容易。</p><p>通过一些简单的注解，我们就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p><p>SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix</p><h2 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h2><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/eureka.png" alt="1"></p><p>作用：实现服务治理（服务注册与发现）</p><p>简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</p><p>由两个组件组成：Eureka服务端和Eureka客户端。</p><p>Eureka服务端用作服务注册中心。支持集群部署。</p><p>Eureka客户端是一个java客户端，用来处理服务注册与发现。</p><p>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个组件可实现自动拼接服务地址</p><ul><li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li><li>接着你要是调用那个接口，<strong>本质就是会调用 Feign创建的动态代理</strong></li><li>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来<strong>动态构造出你要请求的服务的地址</strong></li><li>最后针对这个地址，发起请求、解析响应</li></ul><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>主要提供客户侧的软件<strong>负载均衡</strong>算法。</p><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p><ul><li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</li><li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li><li>Feign就会针对这台机器，构造并发起请求。</li></ul><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><ul><li>可以在调用服务的时候，在服务出现异常时进行服务熔断和降级避免一直长时间等待服务返回结果而出现雪崩效应</li><li>它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</li></ul><p>熔断：当发现有服务卡死不能工作的时候，熔断器会对他进行熔断，比如这5分钟对这个服务的请求就直接返回了，不要去走网络请求卡几秒钟，这个过程就是溶断！</p><p>降级：就是当服务被熔断后，每次调用这个服务，你就写到单独的数据库中，等这个服务修复后，你手工的添加到业务的数据库中。这个过程就是降级！</p><p>雪崩：如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p><h1 id="为什么还要SpringCloudAlibaba？"><a href="#为什么还要SpringCloudAlibaba？" class="headerlink" title="为什么还要SpringCloudAlibaba？"></a>为什么还要SpringCloudAlibaba？</h1><p>因为SpringCloud版本迭代非常快，每次发布一个realease之后又会马上发布下一个版本，所以可能会积累很多bug，而若是进入到了维护阶段，意味着不会再有新的组件技术出现，只是在原来的技术上修改。</p><h1 id="SpringCloudAlibaba"><a href="#SpringCloudAlibaba" class="headerlink" title="SpringCloudAlibaba"></a>SpringCloudAlibaba</h1><p>是Spring cloud的子项目，符合SpringCloud的标准，致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li></ul><h2 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h2><p>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。<br>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。<br>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。<br>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。<br>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。<br>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。<br>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。<br><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou1.png" alt="1"></p><p><img src="/2022/06/15/SpringCloudAlibaba%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/jiegou2.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean</title>
      <link href="/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="配置Bean"><a href="#配置Bean" class="headerlink" title="配置Bean"></a>配置Bean</h1><p>两种方式：在xml中写<bean>标签，用@Bean注解</bean></p><p>两个方法都在sping的refresh方法中都会用loadBeanDefinitions加载到容器里面，通过BeanDefinitionRegistry.register方法，会包括一些后置处理</p><h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><p>配置bean之后就拿到了BeanDefinition，是配置bean的加载结果，也是下面步骤的原始数据。</p><p>Spring在启动时，会扫描到类的信息，将相关信息封装为BeanDefinition存入到beanDefinitionMap中，根据里面的扫描信息生成bean                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><p>注意：beanName、ClassType。</p><p>提前初始化：把那个没有配置的懒加载bean开始初始化</p><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>入参实际上只有一个beanName，与beanDefinition的两个属性相对应，通过beanName然后找到beanType，找到type之后调用&#x3D;&#x3D;反射&#x3D;&#x3D;返回了一object。</p><p>反射的大致：获取class对象得到一个构造器，Constructor ctor&#x3D;clazz.getDeclaredConstructor()，Object obj &#x3D; ctor.newInstance()。</p><p>容器中按照使用者来分，可以把bean对象分为用户自定义对象、容器对象（比如：ApplicationContext、BeanFactory等等）</p><p>注意：InstantiationAwareBeanPostProcessor去生成代理类回来</p><h1 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h1><p>此处就需要解决循环依赖-三级缓存</p><p>给自定义属性赋值：核心在于populateBean里面的autowireByName、autowireByType两个方法（@Autowire，@Resource）</p><p>给容器对象属性赋值：invokeAwareMethods</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>对象的拓展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/14/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220614145857358.png" alt="image-20220614145857358"></p><p>在属性赋值阶段后，postProcessBeforeInitialization方法之前，会执行很多Aware类型的接口，这种接口类型作用就是加载到Spring容器中，Aware前面的名字就是对应哪种资源</p><p>aware：如果实现了某些接口，比如BeanNameAware、BeanFactoryAware、ApplicationContextAware，就把这些实例给set进去。</p><p>初始化的方式有三个：分别是Initialization的afterPropertiesSet方法；PostConstruct注解标注方法；配置的init-method</p><p>BeanPostProcessor实现了AOP，AOP就是在整个IOC处理流程中某一个拓展点的实现</p><p>执行完就是一个完成的对象</p><h1 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h1><p>要么去实现DisposableBean接口，要么去定义destory-method方法 </p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环依赖</title>
      <link href="/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h1 id="循环依赖问题简述"><a href="#循环依赖问题简述" class="headerlink" title="循环依赖问题简述"></a>循环依赖问题简述</h1><p><img src="/2022/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/question.png" alt="image-20220613223428341"></p><p>如图所示，在创建对象A的时候，需要依赖注入对象B，但此时容器里面并没有B，所以去创建B，B在创建的过程中又需要A的注入，而此时A在等待B的创建，所以就造成了双方都在等待，类似的“死锁”的情况，导致两者都无法创建成功。</p><p>创建Spring Bean对象到初始化的大致流程</p><p>getSingleton：从单例池中获取bean对象，若没有就创建</p><p>doCreateBean：创建bean对象</p><p>populateBean：填充依赖，若被填充的对象不存在于单例池中，则进行创建</p><p>addSingleton：将初始化完成的对象加入到单例池</p><h1 id="三级循环"><a href="#三级循环" class="headerlink" title="三级循环"></a>三级循环</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">//一级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一级缓存：是成品，里面是完成生命周期的对象，是完成的bean，可以被任意使用</p><p>二级缓存：是半成品，不完整，里面是刚刚实例化但是没有全部实例化的原始对象</p><p>三级缓存：里面的bean是构造器反射创建出来的bean，没有任何的填充属性，单例工程的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">        <span class="comment">//从singletonObjects（一级缓存）尝试获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//如果一次缓存中获取不到并且对象正在创建中，就在二级缓存中查找</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//二级缓存中也查找不到且允许从三级缓存中经过getObject获取</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">               <span class="comment">//对一级缓存进行加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">//一级缓存获取不到</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//二级缓存还是获取不到</span></span><br><span class="line">                        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//获取工厂</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//就从三级缓存中得到bean</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">//若是获取到了，就将singletonObject放入到二级缓存中，并移除三级缓存中的实例</span></span><br><span class="line">                                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isSingletonCurrentlyInCreation（）：判断当前的单例bean是否正在创建的过程中，即没有执行初始化方法</span><br><span class="line">allowEarlyReference：是否允许从三级缓存中经过getObject()方法获取bean对象</span><br></pre></td></tr></table></figure><p>大致：</p><p>Spring会先从一级缓存中去获取bean对象</p><p>获取不到而且对象正在建立中，就会尝试从二级缓存中获取bean</p><p>若还是获取不到，且允许从第三次缓存中的getObject()获取对象，就尝试从三级缓存中获取</p><p>若是三级缓存中获取到了bean，就会将bean放入二级缓存中</p><p>如上图A、B在三级缓存中的迁移过程：</p><p>1创建对象A，完成生命周期第一步（实例化），在调用createBeanInstance方法后，会调用addSingletonFactory方法，将已实例化但未属性赋值未初始化的对象放入三级缓存中。即将对象A提早曝光给IOC容器</p><p>2执行对象A生命周期第二步（属性赋值）。此时，发现对象A依赖对象B，所以就会尝试去获取对象B</p><p>3发现B没有被创建，所以会执行创建对象B的过程</p><p>4创建对象B的过程中，执行实例化和属性赋值操作，此时发生对象B依赖对象A</p><p>5 尝试去缓存中查找对象A。从一级缓存开始找，没有对象A（因为对象A此时还没有初始化完成）；再找二级缓存，也没有对象A（此时的对象A还没有进行属性赋值）；转而查找三级缓存，对象B通过singletonFactory.getObject();拿到对象A</p><p>6对象B获取到对象A后，继续执行生命周期，属性赋值、初始化操作。对象B完成初始化操作后，会被存到一级缓存中</p><p>7转到【对象A执行属性赋值过程并发现依赖了对象B】的阶段，此时对象已经可以从一级缓存中获取到对象B。所以可以顺利执行属性赋值操作</p><p>8对象A执行初始化操作，完成后，对象A也会放到一级缓存中</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>Spring进行扫描-&gt;反射后封装成beanDefinition对象-&gt;放入beanDefinitionMap-&gt;遍历map-&gt;验证（是否单例、是否延迟加载、是否抽象）-&gt;推断构造方法-&gt;准备开始进行实例-&gt;去单例池中查，没有-&gt;去二级缓存中找，没有提前暴露-&gt;生成一个objectFactory对象暴露到二级缓存中-&gt;属性注入，发现依赖Y-&gt;此时Y开始它的生命周期直到属性注入，发现依赖X-&gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;完成循环依赖。</p><h1 id="Spring为什么不能解决非单例Bean的循环依赖"><a href="#Spring为什么不能解决非单例Bean的循环依赖" class="headerlink" title="Spring为什么不能解决非单例Bean的循环依赖"></a>Spring为什么不能解决非单例Bean的循环依赖</h1><p>该问题可以分为：</p><p>Spring为什么不能解决构造器的循环依赖？</p><p>​因为对象的构造函数实在实例化阶段调用。因为在对象实例化后，会将对象放到三级缓存中。在调用对象的构造函数时，对象还没有初始化，所以不能把对象放入三级缓存中。在构造函数注入时，两个对象都没在三级缓存中，所以两个bean都不能实例化</p><p>Spring为什么不能解决prototype作用域循环依赖？</p><p>​IOC只会管理Bean的生命周期，并将单例Bean存放到缓存池中（三级缓存）。Spring不会管理prototype作用域的bean</p><p>Spring为什么不能解决多例的循环依赖?</p><p>​多实例Bean每次调用getBean都会创建一个新的Bean对象，该对象不能缓存。而解决循环依赖是通过缓存实现</p><h1 id="非单实例对象怎么解决？"><a href="#非单实例对象怎么解决？" class="headerlink" title="非单实例对象怎么解决？"></a>非单实例对象怎么解决？</h1><p>对于构造器注入产生的循环依赖，使用@Lazy注解，延迟加载</p><p>对于多例bean和prototype作用域产生的循环依赖，可以尝试改为单例Bean</p><h1 id="为什么一定要三级缓存"><a href="#为什么一定要三级缓存" class="headerlink" title="为什么一定要三级缓存"></a>为什么一定要三级缓存</h1><p><strong>如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理</strong></p><p>使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于 IOC 的考虑，而是出于 AOP 的考虑，即若使用二级缓存，在 AOP 情形注入到其他 Bean的，不是最终的代理对象，而是原始对象。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap部分解析</title>
      <link href="/2022/06/09/concurrentHashMap/"/>
      <url>/2022/06/09/concurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><img src="/2022/06/09/concurrentHashMap/jiegou.png" alt="image-20220609111027013"></p><p>JDK1.7：本质上是一个16个Segment对象的数组，每个Segment都是HashEntry&lt;K,V&gt;[] table，每个table包含若干个HashEntry对象连接起来的链表。get、put等操作只锁当前需要用的桶。即分段数组+链表。</p><p>实现上与hashMap类似，只是采用了分段锁，每个分段锁维护着几个桶（hashEntry），&#x3D;&#x3D;多个线程可以同时访问不同分段锁上的桶&#x3D;&#x3D;</p><p>concurrentHashMap中含有几个segment数组 ，每个segment又含有几个hashEntry数组</p><p>JDK1.8：没有使用段锁，而是采用了Node数组+链表+红黑树的方式</p><h4 id="构造方法（1-8）"><a href="#构造方法（1-8）" class="headerlink" title="构造方法（1.8）"></a>构造方法（1.8）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量              扩容因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, </span></span><br><span class="line"><span class="params">     //并发级别（当前concurrentHashMap对象，最多同时支持多少线程同时操作）segment数组的长度。但是不会随着扩容长度发生变化（因为有了最大的限制）</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//以上均是防止传非法数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Put（1-8）"><a href="#Put（1-8）" class="headerlink" title="Put（1.8）"></a>Put（1.8）</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="comment">//首先就是不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());<span class="comment">//基于key进行计算，一定是正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录某个桶上元素的个数，若&gt;8就转变为红黑树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//是否要初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//根据下标计算，若f为空，数组的这个位置就没有元素，所以加进去就可以退出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//CAS操作，防止多个线程同时进行</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出值判断hash值，判断是否是forwar节点（代表是否正在扩容）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//锁这个节点，保证该节点的元素插入是安全的（不影响其他节点）。即保证安全又保证效率</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//为什么还要判断？ 防止变成树后节点发生了变化</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//fh&gt;0就代表是一个链表结构</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//遍历依次比对</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//原数组里面没有，就需要添加新的节点</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//不是&gt;0就不是链表结构，就是树结构</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以上就添加结束，就开始维护</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//泊松分布</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)  <span class="comment">//TREEIFY_THRESHOLD=8</span></span><br><span class="line">                        <span class="comment">//触发变成树的可能函数</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护集合长度，是否扩容</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Get（1-8）"><a href="#Get（1-8）" class="headerlink" title="Get（1.8）"></a>Get（1.8）</h4><p>  计算hash值</p><p>根据hash值计算得到数组相应的位置</p><p>在该位置进行针对性的查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">//计算值，将保存数据的table赋值给tab，且判断数组是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//该数组下标所对应的值</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组上的值就是所要查找的值</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//就表示正在进行扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//直接遍历链表需要所要查找的值</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现高效并发机制的保证：</p><p>通过不加锁和加锁的两种方案控制跨段操作的安全性</p><p>通过HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作</p><p>（理想操作）可以支持16个线程执行并发写操作，及任意数量线程的读操作</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>微服务是一种架构风格，即将单体应用划分为小型的服务单元，微服务之间使用 HTTP 的 API 进行资源访问与操作。</p><p>在笔者看来，微服务架构的演变更像是一个公司的发展过程，从最开始的小公司，到后来的大集团。大集团可拆分出多个子公司，每个子公司的都有自己独立的业务、员工，各自发展，互不影响，合起来则是威力无穷。</p><p>臃肿的系统、重复的代码、超长的启动时间带给开发人员的只有无限的埋怨，丝毫没有那种很舒服的、很流畅的写代码的感觉。他们把大部分时间都花在解决问题和项目启动上面了。</p><h3 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h3><p>使用微服务架构能够为我们带来如下好处：</p><h4 id="1）服务的独立部署"><a href="#1）服务的独立部署" class="headerlink" title="1）服务的独立部署"></a>1）服务的独立部署</h4><p>每个服务都是一个独立的项目，可以独立部署，不依赖于其他服务，耦合性低。</p><h4 id="2）服务的快速启动"><a href="#2）服务的快速启动" class="headerlink" title="2）服务的快速启动"></a>2）服务的快速启动</h4><p>拆分之后服务启动的速度必然要比拆分之前快很多，因为依赖的库少了，代码量也少了。</p><h4 id="3）更加适合敏捷开发"><a href="#3）更加适合敏捷开发" class="headerlink" title="3）更加适合敏捷开发"></a>3）更加适合敏捷开发</h4><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行。服务拆分可以快速发布新版本，修改哪个服务只需要发布对应的服务即可，不用整体重新发布。</p><h4 id="4）职责专一，由专门的团队负责专门的服务"><a href="#4）职责专一，由专门的团队负责专门的服务" class="headerlink" title="4）职责专一，由专门的团队负责专门的服务"></a>4）职责专一，由专门的团队负责专门的服务</h4><p>业务发展迅速时，研发人员也会越来越多，每个团队可以负责对应的业务线，服务的拆分有利于团队之间的分工。</p><h4 id="5）服务可以按需动态扩容"><a href="#5）服务可以按需动态扩容" class="headerlink" title="5）服务可以按需动态扩容"></a>5）服务可以按需动态扩容</h4><p>当某个服务的访问量较大时，我们只需要将这个服务扩容即可。</p><h4 id="6）代码的复用"><a href="#6）代码的复用" class="headerlink" title="6）代码的复用"></a>6）代码的复用</h4><p>每个服务都提供 REST API，所有的基础服务都必须抽出来，很多的底层实现都可以以接口方式提供。</p><h3 id="微服务架构的劣势"><a href="#微服务架构的劣势" class="headerlink" title="微服务架构的劣势"></a>微服务架构的劣势</h3><p>微服务其实是一把双刃剑，有利有弊。下面我们来谈谈微服务有哪些弊端，以及能采取什么办法避免。</p><h4 id="1）分布式部署，调用的复杂性高"><a href="#1）分布式部署，调用的复杂性高" class="headerlink" title="1）分布式部署，调用的复杂性高"></a>1）分布式部署，调用的复杂性高</h4><p>单体应用的时候，所有模块之前的调用都是在本地进行的，在微服务中，每个模块都是独立部署的，通过 HTTP 来进行通信，这当中会产生很多问题，比如网络问题、容错问题、调用关系等。</p><h4 id="2）独立的数据库，分布式事务的挑战"><a href="#2）独立的数据库，分布式事务的挑战" class="headerlink" title="2）独立的数据库，分布式事务的挑战"></a>2）独立的数据库，分布式事务的挑战</h4><p>每个微服务都有自己的数据库，这就是所谓的去中心化的数据管理。这种模式的优点在于不同的服务，可以选择适合自身业务的数据，比如订单服务可以用 MySQL、评论服务可以用 MongoDB、商品搜索服务可以用 ElasticSearch。</p><p>缺点就是事务的问题了，目前最理想的解决方案就是柔性事务中的最终一致性，后面的章节会给大家做具体介绍。</p><h4 id="3）测试的难度提升"><a href="#3）测试的难度提升" class="headerlink" title="3）测试的难度提升"></a>3）测试的难度提升</h4><p>服务和服务之间通过接口来交互，当接口有改变的时候，对所有的调用方都是有影响的，这时自动化测试就显得非常重要了，如果要靠人工一个个接口去测试，那工作量就太大了。这里要强调一点，就是 API 文档的管理尤为重要。</p><h4 id="4）运维难度的提升"><a href="#4）运维难度的提升" class="headerlink" title="4）运维难度的提升"></a>4）运维难度的提升</h4><p>在采用传统的单体应用时，我们可能只需要关注一个 Tomcat 的集群、一个 MySQL 的集群就可以了，但这在微服务架构下是行不通的。当业务增加时，服务也将越来越多，服务的部署、监控将变得非常复杂，这个时候对于运维的要求就高了。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父类子类加载顺序</title>
      <link href="/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
      <url>/2022/05/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><p>父类静态属性（成员变量） &gt; 父类静态代码块 &gt; 子类静态属性 &gt; 子类静态代码块 &gt; 父类非静态属性 &gt; 父类非静态代码块 &gt; 父类构造器 &gt; 子类非静态属性 &gt; 子类非静态代码块 &gt; 子类构造器</p><p>简而言之就是先静态后非静态，先父类后子类</p><ol><li>父类静态变量</li><li>父类静态代码块（若有多个按代码先后顺序执行）</li><li>子类静态变量</li><li>子类静态代码块（若有多个按代码先后顺序执行）</li><li>父类非静态变量</li><li>父类非静态代码块（若有多个按代码先后顺序执行）</li><li>父类构造函数</li><li>子类非静态变量</li><li>子类非静态代码块（若有多个按代码先后顺序执行）</li><li>子类构造函数</li></ol><p><em><strong>所有的静态资源都只会被加载一次，非静态资源可以被重复加载</strong></em></p><h1 id="类初始化和实例初始化"><a href="#类初始化和实例初始化" class="headerlink" title="类初始化和实例初始化"></a>类初始化和实例初始化</h1><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>一个类要创建实例需要先加载并初始化该类</p><p>  Main方法所在的类需要先加载和初始化</p><p>子类要初始化需要先初始化父类</p><p>一个类初始化就是执行<clinit>()方法 类初始化方法</clinit></p><p>  <clinit>()方法由静态类变量显示赋值代码和静态代码块组成</clinit></p><p>  类变量显示赋值代码和静态代码块代码从上到下顺序执行</p><h2 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h2><p>就是执行<init>()方法</init></p><p>  <init>()方法可能重载有多个，有几个构造器就有几个<init>方法</init></init></p><p>  <init>()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成</init></p><p>  非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应的构造器的代码最后执行</p><p>  每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法</init></p><p>  <init>方法的首行就是super()或super（实参列表），即对应父类的<init>方法</init></init></p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>不能被重写的方法</p><p>Final方法</p><p>  静态方法</p><p>  Private等子类中不可见的方法</p><p>多态性</p><p>  子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码</p><p>  非静态方法默认的调用对象是this</p><p>  This对象在构造器或者说<init>方法中就是正在创建的对象</init></p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法被子类重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Son()&#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//写或不写都在，一定会会调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="小结特点"><a href="#小结特点" class="headerlink" title="小结特点"></a>小结特点</h1><ol><li>静态属性和代码块，当且仅当该类在程序中第一次被 new 或者第一次被类加载器调用时才会触发（不考虑永久代的回收）。也正是因为上述原因，<strong>类优先于对象</strong> 加载&#x2F;new，即 <strong>静态优先于非静态</strong>。</li><li>属性（成员变量）优先于构造方法，可以这么理解，加载这整个类，需要先知道类具有哪些属性，并且这些属性初始化完毕之后，这个类的对象才算是<strong>完整的</strong>。另外，非静态代码块其实就是对象 new 的准备工作之一，算是一个不接受任何外来参数的构造方法。因此，<strong>属性 &gt; 非静态代码块 &gt; 构造方法。</strong></li><li>有趣的是，<strong>静态部分（前4个）是父类 &gt; 子类</strong>，而 <strong>非静态部分也是父类 &gt; 子类。</strong></li><li>另外容易忽略的是，非静态代码块在每次 new 对象时都会运行，可以理解：<strong>非静态代码块是正式构造方法前的准备工作</strong>（非静态代码块 &gt; 构造方法）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/26/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>实现单例模式三个主要特点：</p><p>1、构造方法私有化；<br>2、实例化的变量引用私有化；<br>3、获取实例的方法共有。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>静态化实例对象</p><p>私有化构造方法，禁止通过构造方法创建实例</p><p>提供一个公共的静态方法，用来返回唯一的实例</p><h1 id="单例的好处"><a href="#单例的好处" class="headerlink" title="单例的好处"></a>单例的好处</h1><p>整个系统只存在一个对象，内存开始少，性能好</p><p>避免对资源的多重占用</p><p>在系统设置全局访问点，优化和共享资源访问</p><h1 id="不同创建方式"><a href="#不同创建方式" class="headerlink" title="不同创建方式"></a>不同创建方式</h1><p>饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//向外提供   自行创建   不能更改(单例)</span></span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">static</span>    <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的懒汉式：线程不安全，不可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内部类加载：静态内部类不会随着外部类的加载和初始化而初始化。因为是在内部类加载和初始化时创建的。所以线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h1><p>反射</p><p>常见的单例模式实现中，往往有一个私有的构造函数，防止外部程序的调用，但是通过反射可以轻而易举的破坏这个限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> singleton.getSingleton();</span><br><span class="line">            Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">reflectInstance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">            System.out.println(S\singleton == reflectInstance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：false，单例被破坏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>序列化</p><p>其中 Singleton 实现了 Serializable 接口，才有可能通过序列化破坏单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>克隆</p><p>实现 Cloneable 接口重写 clone 方法</p><h1 id="枚举类详解"><a href="#枚举类详解" class="headerlink" title="枚举类详解"></a>枚举类详解</h1><p>Joshua Bloch大神在《Effective Java》中明确表达过的观点：使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法</p><p>枚举类型单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">public</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类的单例模式优点</p><p>写法简单</p><p>枚举会自己处理序列化：<em><strong>传统的单例存在一个问题，一旦实现了序列化接口，那么就不再保持单例</strong></em>，因为readObject()方法一直返回一个新的对象，就像java的构造方法一样</p><p>枚举类创建的是thread-safe</p><p>面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点</p><p>在序列化的过程中Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。</p><p>如上，序列化的时候只将 INSTANCE这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。</p><h1 id="不会被破坏单例的原因"><a href="#不会被破坏单例的原因" class="headerlink" title="不会被破坏单例的原因"></a>不会被破坏单例的原因</h1><p>通过枚举实现的单例模式，利用反射构造新的对象，由于 <a href="https://so.csdn.net/so/search?q=enum&spm=1001.2101.3001.7020">enum</a> 没有无参构造器，结果会抛出 NoSuchMethodException 异常;</p><p>枚举类不实现 Serializable 接口，都可以进行序列化，并且返回原来的单例;</p><p>Enum 类中 clone 的方法是 final 类型，无法重写，也就不能通过克隆破坏单例。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础</title>
      <link href="/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>是管理计算机硬件与软件资源的程序</p><p>本质是一个运行在计算机上的软件程序，用于管理计算机硬件和软件的资源</p><p>屏蔽了硬件层的复杂性</p><p>内核是操作系统核心，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</p><h2 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h2><p>处理器的执行状态分为内核态和用户态，就是为了避免操作系统和关键字数据被用户程序破坏</p><p>内核态：是操作系统管理程序执行时所处状态，能执行包含特权指令在内的所有指令，能访问系统内所有的存储空间</p><p>用户态：用户态运行的进程或可以直接遁去用户程序的数据</p><h2 id="实现内核态和用户态的切换"><a href="#实现内核态和用户态的切换" class="headerlink" title="实现内核态和用户态的切换"></a>实现内核态和用户态的切换</h2><p>系统调用：是操作系统的最小功能单位，操作系统提供的用户接口，本身是一种软中断。</p><p>异常：也叫内中断，由错误引起</p><p>外中断: 通过两根信号线来通知处理器外设的状态变化，是硬中断</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配的基本单位，独立运行的基本单位</p><p>由以下组成：</p><p>  进程控制块PCB，进程唯一存在标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级，CPU现场保护区（用户进程切换），占有的资源清单</p><p>  程序段</p><p>  数据段</p><p>状态：</p><p>  创建态（进程正在被创建）</p><p>就绪态（除了CPU，其他资源都有，一个系统中可有多个进程处于该状态）、</p><p>运行态（占有处理器正在运行）、</p><p>阻塞态（不具备运行条件，在等待某个时间完成）</p><p>  结束态（进程正在从系统中消失）</p><p>孤儿进程：父进程退出，子进程还在运行。将被init进程收养</p><p>僵尸进程：进程使用fork创建子进程，若子进程退出，而父进程没有调用wait或waitpid获取子进程状态信息，那子进程的进程描述符仍然保存在系统中</p><h3 id="进程间的通信方法"><a href="#进程间的通信方法" class="headerlink" title="进程间的通信方法"></a>进程间的通信方法</h3><p>  每个进程各有不同的用户地址空间，任何一个进程的全局变量在另一个进程看不见。所以，进程间的交换数据必须在内核：在内核中开辟出一块缓冲区，进程A把数据从用户空间拷贝到内核缓冲区，进程B再从内核缓冲区把数据读走。</p><p>不同进程间的通信本质：进程间可以看到一份公共资源；提供这资源的形式或提供者不同，通信方式也就不同</p><p>主要包括：管道&#x2F;匿名管道，消息队列、信号量、信号、共享内存、套接字socket</p><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>互斥量：互斥对象机制</p><p>信号量：允许同一时刻多线程访问同一资源，但要控制同一时刻最大线程数</p><p>事件：通过通知操作的方式来保持多线程同步</p><h3 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h3><p>当前运行的进程运行结束、当前运行进程阻塞、执行完系统调用等系统程序后返回用户进程、抢占式调度中有更高优先级的进行就绪、分时系统中，分给当前进程的时间片用完</p><h3 id="不能进行调度的时候"><a href="#不能进行调度的时候" class="headerlink" title="不能进行调度的时候"></a>不能进行调度的时候</h3><p>中断处理程序执行时，操作系统的内核程序临界区内、其他需要完全屏蔽中断的原子操作过程中</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>某个函数、数据库在并发环境中被调用时，能够正确的处理多个线程之间的共享变量，让程序功能正确完成</p><p>上下文就是这样的过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作</p><h3 id="进程同步的方法"><a href="#进程同步的方法" class="headerlink" title="进程同步的方法"></a>进程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程划分的任务，是一个进程内可调度的实体，CPU调度的基本单位，来保证程序的实时性，实现进程内部的并发</p><p>是操作系统可识别的最小执行和调度单位</p><h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p>互斥锁、读写锁、条件变量、记录锁、信号量、屏障</p><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p>用Volatile关键字，就是多个线程同时监听一个变量</p><p>Object类的wait和notify</p><p>JUC工具类CountDownLatch</p><h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>比线程更轻量级，不被操作系统管理，完全由程序控制（用户态执行）。这样能提升性能，不会像线程那样切换而消耗资源</p><p>单线程下的并发 </p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2022/05/24/MySQL-1/"/>
      <url>/2022/05/24/MySQL-1/</url>
      
        <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p> 连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、缓冲组件、优化器组件、插件式存储引擎、物理文件</p><h2 id="三大范式和反模式"><a href="#三大范式和反模式" class="headerlink" title="三大范式和反模式"></a>三大范式和反模式</h2><p>第一：属性不可分割，原子项</p><p>第二：原子性，即非主属性必完全依赖主属性</p><p>第三：原子性，非主属性必完全主属性，且不存在传递依赖</p><p>反模式：解决了旧问题，又产生了新问题。实际开发中，不会严格遵守三范式</p><h2 id="三种引擎"><a href="#三种引擎" class="headerlink" title="三种引擎"></a>三种引擎</h2><p><img src="/2022/05/24/MySQL-1/yinqin.png" alt="引擎"></p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><a href="https://xiaoerbutingbu.github.io/2022/05/11/InnoDB-1/">详情请看</a></p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存存放，hash索引（默认）</p><p>所有数据存在内存汇总，数据的处理速度快，但安全性不高，因对表的大小有要求，不能建太大的表。适用于需要很快的读写速度、安全性要求较低的</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快</p><p>若主要用于插入新记录和读出记录，该引擎就能实现处理的高效率。若应用的完整性、并发性要求较低，也可</p><p>每次查询具有原子性</p><p>B+树的索引结构</p><p>非聚集性索引，存储会有两个文件，一个索引文件，一个数据文件，其中索引文件的索引指向数据文件中的表数据</p><p>用一个变量保存了整个表的行数，而innodb是全表扫描</p><p>支持全文索引，innodb不支持全文索引（5.7以前）</p><p>可以被压缩后查询</p><p>所以MYISAM只缓存索引块，记录的直接是文件的OFFSET，定位比INNODB块。多以查询比较快</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制，是一种并发控制的方法，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p><em><strong>就是为了实现读写冲突不加锁。</strong></em></p><p>MVCC多版本并发控制：维持一个数据的多个版本，让读写操作没有冲突</p><p>在InnoDB中的实现主要是为了提高数据库并发性能</p><p>使用RC和RR隔离级别的事务，在执行普通selsect操作时，访问记录版本链的过程；让不同事务的读写、写操作并发执行，提高体统性能</p><h3 id="益处"><a href="#益处" class="headerlink" title="益处"></a>益处</h3><p>解决读写冲突的无锁并发控制</p><p>在并发读写时，可在读操作时不用阻塞写操作，写操作不用阻塞读操作，提供读写性能；解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>第一种：将数据记录的多个版本保存在数据库中，当这些版本数据不再需要时，垃圾回收器就回收这些记录</p><p>第二种：只在数据库中保存最新版本的数据，但是在使用undo时动态重构旧版本数据</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>3个隐式字段：分别记录</p><p>​                 最近修改事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</p><p>​                 指向这条记录的上一个版本；</p><p>​                 隐含自增ID，若数据表没有主键，就自动产生一个聚集索引</p><p>Undo日志：</p><p>​        Insert undo log：事务在insert新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>​        Update undo log：在update或delete时产生；事务回滚需要，快照读也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该该日志，才会被统一清除</p><p>Read View：</p><p>​         事务进行快照读操作的时候生产的读视图</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>适合索引的列是出现在where字句中的列或连接子句中指定的列</p><p>基础较小的类，索引效果差。</p><p>使用短索引：若对长字符串进行索引，应该指定要前缀长度，这样能够节省大量索引空间</p><p>不能过度索引，因为索引需要额外的磁盘空间，并降低写操作的性能。修改表的内容时，索引会进行更新甚至重构，索引的列越多，时间就越长。所以，只保持需要的索引有利于查询即可</p><p>存储引擎层实现，索引：帮助mysql高效获取数据的数据结构</p><p>提高数据库的性能，不用加内存，不用该程序，不同调sql</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>​每张表的主键构成一棵B+树，同时叶子节点存放的即为整张表的行记录数据，叶子节点也就是数据页</p><p>​将数据存储与索引放到一块，索引的叶子节点保存了行数据，&#x3D;&#x3D;必有且只有一个聚集索引&#x3D;&#x3D;。若有主键，主键即是；无主键用第一个唯一索引；若都没，会自动生成一个rowid作为隐藏的聚集索引。</p><p>​        结构：B+树：&#x3D;&#x3D;将所有数据都放在叶子节点&#x3D;&#x3D;，叶子节点形成一个列表；非叶子只存放键值，每个数据叶中的有效数据就多了，可以减少IO次数。按键值的大小顺序存放在同一层的叶子节点上</p><p>​    因为相对于二叉树（会有左倾右倾的情况），B+树层级更少，搜索效率高</p><p>​    因为B树：无论叶子节点还是非叶子，都保存数据，所以存储值减少，指针就减少，要同样保存大量数据，只能增加树的高度，导致性能降低，要查找就要遍历整个树</p><p>​    Hash索引只支持等值匹配，不支持排序操作</p><h4 id="辅助索引（非聚集索引）"><a href="#辅助索引（非聚集索引）" class="headerlink" title="辅助索引（非聚集索引）"></a>辅助索引（非聚集索引）</h4><p>与聚集索引不同的是，叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点索引行中还包含一个书签（用来让Innodb知道哪里可以找到与之对应的行数据）</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>把无序的数据变成有序的查询</p><p>创建了索引的列的内容进行排序</p><p>对排序结果倒排索引</p><p>在倒排表内容上拼上数据地址链</p><p>查询时，先拿倒排表内容，再取出数据地址链，从而拿到数据</p><h3 id="主要分类"><a href="#主要分类" class="headerlink" title="主要分类"></a>主要分类</h3><p>普通索引、唯一索引（hash）、主键索引、组合索引、全文索引（full text），BTREE，RTREE</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka常见问题</title>
      <link href="/2022/05/23/kafka-1/"/>
      <url>/2022/05/23/kafka-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka比RocketMQ吞吐量高的原因"><a href="#Kafka比RocketMQ吞吐量高的原因" class="headerlink" title="Kafka比RocketMQ吞吐量高的原因"></a>Kafka比RocketMQ吞吐量高的原因</h3><p>kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息没有发送到Broker而是<em><strong>在生产者缓存起来</strong></em>，然后直接向业务返回成功。当缓存的消息达到了一定的数量时再分批量发送给Broker。这样就减少了网络IO，从而提高了消息发送的吞吐量，但若消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用该机制提高了性能却降低了可靠性</p><h3 id="Kafka的pull和Push的优缺点"><a href="#Kafka的pull和Push的优缺点" class="headerlink" title="Kafka的pull和Push的优缺点"></a>Kafka的pull和Push的优缺点</h3><p>pull表示消费者主动拉取，可批量拉也可单条拉，所有pull可由消费者自己控制，根据自己的消息处理能力来进行控制，但消费者不能及时知道是否有消息，拉的消息可能为空</p><p>push表示broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就消费多少消息，可能会造成网络堵塞，消费者压力大等问题</p><h3 id="kafka的rebalance机制"><a href="#kafka的rebalance机制" class="headerlink" title="kafka的rebalance机制"></a>kafka的rebalance机制</h3><p>consumer group中的消费者与topic下的partion重新匹配的过程</p><p>产生rebalance的时间： consumer group 中的成员个数发生变化， consumer消费超时，group订阅的topic个数发生变化，group订阅的topic的分区数发生变化</p><p>coordinator（协调者）：是partition的leader节点所在的broker，负责监控group中的consumer的存活，consumer维持到coordinator的心跳，判断consumer的消费超时。    通过心跳返回通知consumer进行rebalance；consumer请求coordinator加入组，coordinator选举产生leader consumer；leader consuemr从coordinator获取所有的consumer，发送syncGroup（分配信息）给到coordinator；coordinator通过心跳机制将syncGroup下发给consumer</p><p>leader consumer监控topic的变化，通知coordinator触发rebalance</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="/2022/05/23/kafka-1/jiagou.png" alt="image-20220501201317495"></p><p>consumer group：消费者组，消费者组内每个消费者负责消费不同分区的数据，提供消费能力。逻辑上的一个订阅者</p><p>topic：理解为一个队列，topic将消息分类，生产者和消费者面向同一个topic</p><p>partition：为了实现拓展性，提供并发能力，一个topic以多个partition的方式分布到多个broker上，每个partition是一个有序的队列。一个topic的每个partition都有若干个副本，一个leader和若干个follower。生产者发送数据的对象，以及消费者消费数据的对象都是leader。follower负责实时从leader中同步数据，保证和leader数据的同步。leader故障，某个follower会成为新的leader</p><h3 id="zookeeper作用"><a href="#zookeeper作用" class="headerlink" title="zookeeper作用"></a>zookeeper作用</h3><p>&#x2F;brokers&#x2F;ids：临时节点，保存所有broker节点信息，存储broker的物理地址、版本信息、启动时间等，节点名称为brokerID，broker定时发送心跳到zk，若断开该brokerID会被删除</p><p>&#x2F;brokers&#x2F;topic：临时节点，节点保存broker节点下所有的topic信息，每一个topic节点下包含一个固定的partition节点，partitions的子节点就是topic的分区，每个分区下保存一个state节点，保存着当前leader分区和ISR的brokerID，leader创建state节点，若leader宕机，该节点会被删除，直到新的leader产生，重新生成state节点</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;owners&#x2F;[topic]&#x2F;[broker_id-partition_id]：维护消费者和分区的注册关系。 比如：consumer下有c1，c2，c3分别与topic下的p1，p2，p3相连，该节点就是记录消费者消费的哪个分区关系。若c1宕机了，p1就没有消费端，就触发rebalance</p><p>&#x2F;consumer&#x2F;[group_id]&#x2F;offsets&#x2F;[topic]&#x2F;[broker_id-partition_id]：分区消息的消费进度offset。partition第一次拉取了consumer的第一条消息，第二次就拉取第二条，该节点就记录这个信息  </p><p>client通过topic找到topic树下的state节点，获取leader的brokerID，到broker树找到broker的物理地址，但是client不会直连zk，而是通过配置的broker获取到zk中的信息</p><h3 id="高性能的原因"><a href="#高性能的原因" class="headerlink" title="高性能的原因"></a>高性能的原因</h3><p>指读写性能</p><p>kafka<em><strong>不基于内存</strong></em>，而是硬盘存储，因此消息堆积能力更强，硬盘容量大。文件系统</p><p>顺序写：利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的，节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition物理上分为多个segment存储方便删除</p><p>传统：读取磁盘文件数据到内核缓冲区；将内核缓冲区的数据copy到用户缓冲区；将用户缓冲区的数据copy到socket的发送缓冲区；将socket发送缓冲区的数据发送到网卡，进行传输</p><p>零拷贝：直接将内核缓冲区的数据发送到网卡传输；使用的是操作系统的指令支持</p><p>kafka不太依赖jvm，主要理由操作系统的pageCache，由操作系统决定把数据从pageCache刷到磁盘，若生产消费速率相当，则直接用pageCache交换数据，不需要经过磁盘IO</p><h3 id="消息高可靠的解决方案"><a href="#消息高可靠的解决方案" class="headerlink" title="消息高可靠的解决方案"></a>消息高可靠的解决方案</h3><p>消息发送：</p><p>​ack：0、不重试；1、leader写入成功就返回了；all&#x2F;-1、等待ISR同步完再返回（ISR列表中的follow全部同步完成）</p><p>​unclean.leader.election.enable：false，禁止选举ISR以外的follower为leader。若为true，即允许leader从OSR中选举，即使ack为all，消息也可能丢失，因为leader从OSR中选的话，该follow与之前的leader相比已经差了很大了 </p><p>​tries&gt;1，重试次数</p><p>​min.insync.replicas&gt;1：最小同步副本数，没满足该值前，不提供读写服务、写操作异常</p><p>消费：</p><p>​手工提交offset；</p><p>broker：</p><p>​减少刷盘间隔；事务消息</p><h3 id="消息丢失的场景和解决"><a href="#消息丢失的场景和解决" class="headerlink" title="消息丢失的场景和解决"></a>消息丢失的场景和解决</h3><p>场景：</p><p>​ack&#x3D;0：即producer发送消息完后，不管发送结果了，若发送失败数据也就丢失了</p><p>​ack&#x3D;1，leader crash：producer发送消息后，只等待lead写入成功就返回了，leader crash了，这时follow没来得及同步，消息就丢失了</p><p>​unclean.leader.election.enable 配置为true：即允许OSR节点作为leader，producer发送完消息，只等待leader写入成功就返回了，但leader crash而ISR没有follower，leader就会从OSR选举，而OSR的信息本来就落后于leader，就造成信息发生丢失</p><p>解决：</p><p>发送端</p><p>​ack&#x3D;all&#x2F;-1，tries&gt;1,unclean.leader.election.enable配置为false ：producer发送完消息，等待follower同步完再返回，若异常则重试，副本的数量可能影响吞吐量</p><p>​不允许选举ISR以外的副本作为leader</p><p>​配置：min.insync.replicas&gt;1：<em><strong>副本指定必须确认写操作成功的最小副本数量</strong></em>。若不能满足这个最小值，则生产者将引发一个异常</p><p>​min.insync.relicas和ack跟搭嘎的持久性保证，确保如果大多数副本没有收到写操作，则生产者将引发异常</p><p>​失败的offset单独记录：producer发送消息，会自动重试，遇到不可恢复异常会抛出，这时可以捕获异常记录到数据库或缓存，进行单独处理</p><p>消费端</p><p>​先commit再处理消息，如果在处理消息的时候异常了，但是offset已经提交了，该消息对于该消费者就是丢失了，再也不会被消费到</p><p>​<em><strong>而若先处理，没来得及commit就宕机了，消息就会被重复消费</strong></em></p><p>broker</p><p>​减少刷盘间隔</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="/2022/05/22/IO/"/>
      <url>/2022/05/22/IO/</url>
      
        <content type="html"><![CDATA[<h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><h3 id="阻塞式I-x2F-O"><a href="#阻塞式I-x2F-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h3><p>用户线程发出IO请求后，内核会查看数据是否就绪，若没有就绪，就会等待数据就绪，而一直处于阻塞状态并交出CPU资源</p><h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><p>用户线程发出一个请求后会立刻得到一个结果，若结果是error就再次发起请求，直到得到结果。在此期间会一直占用CPU，因为会一直询问内核数据是否就绪</p><h3 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h3><p>一种机制</p><p>用的较多，NIO就是</p><p>总有一个线程轮询多个socket状态，只有当真正有读写事件时，才真正调用实际的IO读写操作。因为只需要一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不用维护这些，只有真的socket读写事件进行时才使用IO资源。</p><p>该模型用到了select、poll函数，两个函数可以同时阻塞多个I&#x2F;O操作</p><p>函数方法</p><p>selsect：监视的文件描述符分三类，调用select函数会阻塞，直到描述符就绪或超时</p><p>​         缺陷：单线程打开的FD有限制；对socket进行线性扫描（轮询）IO，效率低；限定大小，因为保存文件描述符的bitmaps是1024</p><p>​         阻塞函数，没数据阻塞</p><p>​        一开始是收集文件描述符给内核看哪儿有数据（提高了效率，不然用户态判断会因为切换而浪费资源），有数据的话，FD置位，select函数返回，后面就遍历FD，判断哪个置位并读出数据再处理</p><p>poll：本质与select无区别；将用户给的数组拷贝进内核，查询每个fd对应设备的状态</p><p>若遍历fd都没有就绪设备就挂起当前线程，直到设备就绪或主动超时，被唤醒后再次遍历fd</p><p>​             没有最大连接次数（因为恢复revents）；大量fd数组复制进内核（有些无意义）；若报告的fd没处理，那下次poll会再次报告fd</p><p>​           有超时时间，5个FD拷贝到内核态并监听数据</p><p>​           有数据时内核会对revents字段置位，poll返回，遍历找置位读数据</p><p>Epoll：没有描述符的限制；可水平触发和边缘触发；</p><p>没有最大并发连接的限制；效率提升，不是轮询方式；内存拷贝</p><p>​             连接数较多且很多的不活跃连接时，epoll效率更好；反之，epoll因需要回调，所以性能此时会低</p><p>​             创建了epfd白板，再epoll_ctr，写了结构体；用户态和内核态共享fd内存（不像上面还需要拷贝）；水平触发：重排置位（有数据的放到前面），返回值为有多少个数据，遍历就遍历前几个，进行处理</p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>用户线程发起IO请求，会给对应的socket注册一个信号函数，线程再继续执行，当用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际IO请求操作</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>用户线程发起请求后，就可做其他事，当接收到数据内核返回的成功信号时，就表示IO操作已经完成，可以直接去使用数据</p><h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p>本身是指数据 从源头到目的地</p><p>其中的输入输出流都是在外部文件和内存之间数据的流通</p><p>分为两种：字符流和字节流。InputStream和OutputStream，Reader，Writer</p><h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>底层设备只接收字节数据，字符流是字节流的包装，字符流则是直接接收字符串，它会在内部转成字节，再写入底层设备</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>同步阻塞，服务器实现模式为一个连接一个线程</p><p>服务端：通过serverSocket注册端口；服务器通过调用accept方法用于监听客户端socket请求；从socket中获取字节输入或者输出进行数据读写</p><p>客户端：通过socket独享请求域服务端的连接；从socket得到字节输入或字节输出流进行数据的读写</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>同步非阻塞式，核心类：</p><p>​                 Buffer（缓冲区）为所有原始类型提供缓存支持，是一个容器，连续的数组 </p><p>​                 Charset字符集编码解决解码方案</p><p>​                 Channel（通道）一个新的原始I&#x2F;O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备、程序或是网络的连接</p><p>数据source：需要读取，使用：InputStream、Reader。对应了 硬盘、内存、键盘（System.in）</p><p>数据destination：就是需要写入，使用OutputStram、Writer对应了 硬盘、内存、控制台（System.out）</p><h3 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h3><p>BIO：同步阻塞式IO，就平常使用的，模式简单使用方便，并发处理能力低</p><p>​    是一个连接一个线程</p><p>​    适用于连接数目较小且固定的架构，对服务器资源要求较高</p><p>NIO：同步非阻塞IO，客户端和服务器端通过Channel通讯，多路复用</p><p>​    一个请求一个线程</p><p>​    适用于连接数目多且连接较短的架构，比如聊天服务器</p><p>AIO：NIO的升级，异步非阻塞IO，异步IO操作基于事件和回调机制</p><p>一个有效请求一个线程</p><p>适用于连接数据木多且连接较长的架构，比如相册服务器</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础-类加载</title>
      <link href="/2022/05/21/JVM-2/"/>
      <url>/2022/05/21/JVM-2/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h1><p>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件结构</p><p>ClassLoader只负责class文件的加载，至于是否可以运行，则由ExecutionEngine决定</p><p>加载的类信息存放于一块称为方法区的内存空间，除了类信息外，方法区还有存放运行时常量池的信息，可能还包含字符串自变量和数字常量</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>​    通过一个类的全限定名获取定义此类的二进制字节流（字节码文件）</p><p>​    将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>​    在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><p>​    补充：加载.class文件的方式</p><p>​         从本地系统中直接加载</p><p>​         通过网络获取，典型场景：web Applet</p><p>​         从zip压缩包中读取，成为日后jar，war格式的基础</p><p>​         运行时计算生成，使用最多的是：动态代理技术</p><p>​         由其他文件生成，典型：JSP应用</p><p>​         从专有数据库中提取.class文件，少见</p><p>​         从加密文件获取，典型：防class文件被反编译的保护措施</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>​    验证：目的确保class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性不会危害虚拟机自身安全</p><p>​          主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</p><p>​    准备：为类变量分配并且设置该类变量的默认初始值，即零值</p><p>此处不包含用修饰的static，因为final在编译时就已经会分配了，准备阶段会显示初始化</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中</p><p>​    解析：将常量池的符号引用（不一定已加在内存）转换为直接引用的过程</p><p>​          解析操作往往会伴随着JVM在执行完初始化之后再执行</p><p>​          符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个简介定位到目标的句柄。</p><p>​          解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    初始化过程就是执行类构造器方法<clinit>过程</clinit></p><p>​    也就是只对static修饰的初始化</p><p>​    该方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来</p><p>​    构造器方法中指令按语句在源文件中出现的顺序执行</p><p>​    <clinit>方法不同于类构造器，jvm会保证子类的<clinit>方法执行之前，父类的<clinit>已经执行完毕</clinit></clinit></clinit></p><p>​    虚拟机必须保证一个类的<clinit>方法在多线程下被同步加锁</clinit></p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器：引导类加载器，自定义加载器</p><p>所有派生于抽象类ClassLoader的类加载器都划分于自定义加载器</p><p>Java核心类库都是引导类加载器加载的</p><h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><p>​    该类由c&#x2F;c++实现，嵌套在JVM内部</p><p>​    用来加载java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path），提供JVM自身需要的类</p><p>​    并不继承java.lang.ClassLoader，没有父加载器</p><p>​    加载拓展类和应用程序类加载器，并指定为他们的父类加载器</p><p>​    为了安全，Bootstrap启动类加载器只加载名为java、javax、sun等开头的类</p><p>拓展类加载器（Extension ClassLoader）</p><p>Java编写，由sun.misc.Launcher$ExtClassLoader实现</p><p>派生于ClassLoader类</p><p>父类加载器为启动类加载器</p><p>​    如果用户创建的JAR放在此目录下，也会自动由拓展类加载器加载</p><p>系统类加载器（应用程序类加载器）</p><p>​    Java编写</p><p>​    父类加载器为拓展类加载器</p><p>​    负责加载环境变量classpath或系统属性，java.class.path指定路径下的类库</p><p>​    该类加载程序中默认的类加载器</p><h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><p>为什么要自定义类加载器</p><p>​    隔离加载类</p><p>​    修改类加载的方式</p><p>​    拓展加载源</p><p>​    防止源码泄露</p><p>实现步骤</p><p>​    通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</p><p>​    JDK1.2之前，在自定义加载类时，总会继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。JDK1.2以后，不再建议用户覆盖loadClass方法，而是建议把自定义的类加载逻辑写在findclass方法中    </p><p>​    若没有复杂需求，可直接继承URLClassLoadr类，这就可避免自己去编写findClass方法及其获取字节码流的方式，使自定义类加载器的简洁</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础-虚拟机栈</title>
      <link href="/2022/05/20/JVM-1/"/>
      <url>/2022/05/20/JVM-1/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h1><img src="/2022/05/20/JVM-1/zucheng.png" alt="组成" style="zoom:150%;"><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>一种快速有效的分配存储方式，<em><strong>访问速度仅次于程序计数器；</strong></em></p><p>线程私有</p><p>  JVM直接对java栈的操作：</p><p>​            每个方法的执行，伴随着进栈（入栈，压栈）</p><p>​            执行结果后的出栈工作</p><p>  不存在垃圾回收的问题</p><p>  栈中的数据都是以栈帧的格式存在，<em><strong>这个线程上正在执行的每个方法都各自对应一个栈帧</strong></em>。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。每一个方法执行结束就对应着一个栈帧从虚拟机栈从入栈到出栈</p><p>栈就只有 压栈 和 出栈</p><p>不同线程中所包含的线帧是不允许相互引用的，即不可能在一个栈帧之中引用另一个线程中的栈帧</p><p>若当前方法调用其他方法，方法返回的时候，当前栈帧会传回此方法的执行结果给前一个栈帧，然后虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p><p>方法的结束方式：正常结束和抛出异常（未被捕获处理）</p><h2 id="栈帧内部结构"><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h2><p><img src="/2022/05/20/JVM-1/zhangzhen.png" alt="zhanzhen"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>  定义为一个数字数组，主要用于<em><strong>存储方法参数和定义在方法体内的局部变量</strong></em></p><p>  因是建立在线程的栈上，是<em><strong>私有</strong></em>的，所以不存在数据安全问题</p><p>  所需的容量的大小是在编译期确定下来的</p><p>  方法嵌套使用的次数由栈的大小决定。越大，次数越多</p><p>  局部变量表中的变量只在当前方法调用中有效。方法调用结束，该表也会随之销毁</p><p>  里面最基本的存储单元Slot（变量槽）：</p><p>​    参数值的存放总是在局部变量数组的index0开始，到数组长度-1结束</p><p>局部变量表最基本的存储单元</p><p>​    局部变量表里，32位以内的类型只占用一个slot，64位占两个</p><p>​    当一个实例方法被调用，它的方法参数和方法体内部定义的局部变量将会按照顺序复制到局部变量表中的每一个slot上</p><p>​    若当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处。</p><p>  Slot重复利用：栈帧中的局部变量表中的槽位是可以重用，为了节省资源。</p><p>  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表直接或间接引用的对象都不会被回收</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>  是一个以字长为单位的数组，但是以后进先出的操作数栈（表达式栈），方法执行过程中，根据字节码指令，进行入栈、出栈操作。</p><p>  进行数据运算的</p><p>  并非采用访问索引的方式来进行数据访问</p><p>  若被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</p><p>Java虚拟机的解释引擎是基于栈（操作数栈）的执行引擎</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>  一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用就是为了支持当前方法的代码能够实现动态连接</p><p>  Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中，动态链接作用就是将这些符号引用转换为调用方法的直接引用</p><p>  常量池：提供一些符号和常量，便于指令的识别</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的PC寄存器的值。（交给执行引擎，让其执行后续操作）</p><p>调用者的PC计数器的值作为返回地址，即调用该方法的指令作为下一条指令的地址</p><p>正常完成与异常完成的区别：异常完成出口退出不会给他上层调用者产生任何的返回值</p><p>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</p><h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>不一定有。比如：对程序调试提供支持的信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/2022/05/19/redis_c/"/>
      <url>/2022/05/19/redis_c/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>持久化就是指redis会把内存中的数据写入到硬盘中，redis重启的时候加载这些数据，就最大限度的降低惠存丢失带来的影响。</p><p><em><strong>因为数据全部在内存，若宕机、进程退出，若没有持久化机制，数据就会全部丢失</strong></em>。有了持久化后，redis在下次重启的时候就会进行数据</p><p>备份的执行过程：redis会单独创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上一次持久化好的文件。整个过程，主进程是不进行任何I&#x2F;O操作，就确保了极高的性能，若要大规模的数据恢复，且对于数据恢复的完整性不是很敏感，那RDB方式要比AOF方式更高效。缺点就是最后一次 持久化后数据可能丢失</p><h1 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h1><h2 id="RDB快照（默认）"><a href="#RDB快照（默认）" class="headerlink" title="RDB快照（默认）"></a>RDB快照（默认）</h2><p>​    将当前redis中的数据<em><strong>生成快照二进制的形式</strong></em>保存到硬盘，保存的文件后缀是rdb；redis重启时可以读取快照文件恢复数据。有手动触发和自动触发两种。记录结果</p><h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>​    创建命令：SAVE和BGSAVE（推荐，因为可在不阻塞服务器进程情况下执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save：会阻塞Redis服务，直到RDB持久化完成，当Rredis里面存储了大量数据的时候，就造成较长时间的阻塞，不建议用</span><br><span class="line">bgsave：一般不会阻塞，进行会执行fork操作创建子进程负责，不会阻塞Redis服务进程。Redis服务的阻塞只发生在fork阶段，一般时间很短</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bgsave的流程：</span><br><span class="line">执行besave命令，Redis进程会判断当前是否存在正在执行的RDB或AOF子线程，若存在就直接结束</span><br><span class="line">Redis进程执行fork操作创建子线程，fork操作过程中redis进程会被阻塞</span><br><span class="line">fork完成后，bgsave就结束了，redis进程就不会被阻塞，其他命令就可以被响应</span><br><span class="line">子进程根据redis进程的内存生成快照文件，并替换原有的RDB文件</span><br><span class="line">子进程通过信号量通知Redis进程已完成</span><br></pre></td></tr></table></figure><h3 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h3><p>在配置文件中设置save的相关配置，如save 5 1，就表示在5s内数据被修改1次时自动触发bgsave操作</p><p>当从节点做全量复制时，主节点会自动执行bgsave操作，并且把生成的RDB文件发送给从节点</p><p>执行 “debug reload”命令时，会触发</p><p>执行“shutdown”，若没有开启AOF持久化也会触发bgsave操作</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：节省磁盘空间，恢复速度快（有向的持久化文件，重启redis，数据就可恢复），方便备份，可最大化redis性能</p><p>  缺点：虽然在fork中使用了写时拷贝技术，但若数据庞大，还是较耗性能；在备份周期，意外down掉的话，就会丢失最后一次快照后的所有改变；</p><p>  较适合大数据集恢复速度的，能承受数分钟内的数据丢失</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>  以日志的形式来<em><strong>记录每个写操作</strong></em>，只追加文件，不改写文件。随着AOF越来越大，需要定期对其重写，达到压缩的目的。默认关闭</p><p>  保存redis服务器执行的所有写命令来记录数据库数据。记录过程</p><p>  优点：备份机制更稳健，丢失数据的概率更低；可读的日志形式，通过AOF更稳健，可处理误操作。</p><p>  缺点：比RDB占用更多磁盘空间；恢复备份速度慢；每次读写都同步的话，有一定的性能压力；存在个别bug，造成不能恢复</p><p>  较适合对业务数据敏感的，不能承受数分钟内的数据丢失</p><h3 id="文件同步的策略"><a href="#文件同步的策略" class="headerlink" title="文件同步的策略"></a>文件同步的策略</h3><p>alawas：每次写入缓存区都要同步到AOF文件中，硬盘的操作比较慢，限制了Redis高并发</p><p>no：每次写入缓存区后不进行同步，同步到AOF文件的操作由操作系统负责，每次同步AOF文件的周期不可控，而且增大了每次同步的硬盘的数据量。</p><p>eversec：每次写入缓存区后，由专门的线程每秒钟同步一次，做到了兼顾性能和数据安全。是建议的同步策略，也是默认的策略。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认AOF不开启，需要修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendonly改为yes，开启AOF</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名字</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># AOF文件的写入方式</span></span><br><span class="line"><span class="comment"># everysec 每个一秒将缓存区内容写入文件 默认开启的写入方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># 运行AOF重写时AOF文件大小的增长率的最小值</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment"># 运行AOF重写时文件大小的最小值</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><img src="/2022/05/19/redis_c/changjing.png" alt="场景"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础</title>
      <link href="/2022/05/18/http-1/"/>
      <url>/2022/05/18/http-1/</url>
      
        <content type="html"><![CDATA[<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>是一个在计算机世界专门在 两点 之间 传输 文字、图片、音频、视频等 超文本 数据的 约定和规范</p><p>简单、灵活和易于拓展、应用广泛和跨平台</p><p>不安全</p><p>基于TCP&#x2F;IP,并且使用了【请求-应答】的通信模式</p><h3 id="五大状态码"><a href="#五大状态码" class="headerlink" title="五大状态码"></a>五大状态码</h3><p><img src="/http-1/zhuangtaima.png" alt="image-20220709112213938"></p><p>204：与200基本相同，只是响应头没有body数据</p><p>206：返回的body不是资源的全部，而是其中一部分</p><p>301：永久重定向，请求的资源不存在了，需用新的URL</p><p>302：临时重定向，需要另一URL访问</p><p>304：不具备跳转的含义，资源未修改，重定向已存在的缓冲文件</p><p>400：客户端请求的报文有错，笼统的错误</p><p>403：服务器禁止访问资源，不是客户端请求错误</p><p>404：请求的资源不存在或未找到</p><p>500：服务器错误，笼统</p><p>501：客户端请求的功能不支持</p><p>502：服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器错误</p><p>503：服务器当前忙，暂时无法响应服务器</p><h3 id="工作过程（浏览器输入url后的操作）"><a href="#工作过程（浏览器输入url后的操作）" class="headerlink" title="工作过程（浏览器输入url后的操作）"></a>工作过程（浏览器输入url后的操作）</h3><p>浏览器解析url，生成一个http请求</p><p>根据url从本地文件查找是否有映射ip，浏览器查看缓存（依次找浏览器缓存、系统缓存、路由器缓存）；若没有则域名解析（DNS解析），获取相应的IP地址</p><p>与服务器建立连接</p><p>​    TCP连接的建立（包含三次握手）</p><p>浏览器发起http请求，请求数据包</p><p>服务器收到请求并响应http请求，浏览器得到html源码</p><p>浏览器解析html代码，并请求html代码中的资源</p><p>TCP断开连接（四次挥手）</p><p>浏览器对页面进行渲染呈现给用户</p><h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><p>因为当顺序发送的请求序列中的一个请求因某种原因被阻塞，后面排队的所有请求也一同被阻塞，客户端也就一直请求不到资源</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>支持C&#x2F;S模式、简单、灵活易于拓展、应用广泛和跨平台</p><p>无状态、明文传输、不安全</p><h3 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h3><p>GET：从服务器获取资源，可以是静态的文本、页面、图片视频</p><p>POST：向URL指定的资源提交数据，放在报文的body</p><h3 id="请求头结构"><a href="#请求头结构" class="headerlink" title="请求头结构"></a>请求头结构</h3><p>由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号</p><p>User-Agent：产生请求的浏览器类型</p><p>Accept：客户端可识别的内容类型列表</p><p>Host：请求的主机名</p><h3 id="响应头格式"><a href="#响应头格式" class="headerlink" title="响应头格式"></a>响应头格式</h3><p>状态行：状态码、八本</p><p>响应头部：</p><p>​         Server：应用程序软件的名称和版本</p><p>​         Content-Type：发送给接受者的实体正文的媒体类型</p><p>​         Accept-Language：描述资源所用的自然语言</p><p>​         Content-Length：实体正文长度</p><p>响应正文：</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="HTTP1-0和1-1"><a href="#HTTP1-0和1-1" class="headerlink" title="HTTP1.0和1.1"></a>HTTP1.0和1.1</h4><p>HTTP&#x2F;1.0性能上，每发起一个请求都要新建一次TCP连接（三次握手），而且是串行，做了没有用TCP连接和断开</p><p>长连接：HTTP&#x2F;1.1采取的，只要任意一端没有明确的提出断开连接，则保持TCP连接状态</p><p>错误状态响应码：1.1中新增加了24个错误状态响应码</p><p>缓存处理：1.1引用了更多缓存控制策略</p><p> 1.1的性能：<em><strong>长连接、管道网络传输、队头阻塞</strong></em></p><p>管道网络传输：在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不用等其回来，就可以发第二个请求出去</p><p>队头阻塞：顺序发送的请求序列中，一个请求因为某种原因被阻塞时，后面排队的所有请求都阻塞了</p><p><img src="/http-1/1.0-1.1.png" alt="image-20220709114337819"></p><p>HTTP1.1的瓶颈：</p><p>最大的问题就是高延迟：因为延迟难以下降；并发连接优先；队头阻塞；HTTP头部巨大且重复；不支持服务器推送消息</p><ul><li>请求&#x2F;响应头部未经压缩就发送，首部信息越多，延迟越大。只能压缩body部分</li><li>发送冗长的首部。每次都发送相同的首部浪费较多</li><li>没有请求优先级</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h5 id="HTTP1-1-优化"><a href="#HTTP1-1-优化" class="headerlink" title="HTTP1.1 优化"></a>HTTP1.1 优化</h5><p>尽量避免HTTP请求（缓存技术）</p><p>在需要发HTTP请求，减少次数（减少重定向，合并请求，延迟发送）</p><p>​收到合并请求就是合并资源，以一个大资源的请求替换多个小资源的请求；当大资源中的小资源发生变化，客户端就要重新下载整个完整的大资源</p><p>​     延迟发送：只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源</p><p>减少服务器的HTTP响应大小</p><h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h4><p>通过<em><strong>静态表和哈夫曼编码</strong></em>的方式，将体积压缩了近一半，针对后续的请求头部也可建立动态表（会占用内存而影响并发能力）</p><p>  <em><strong>实现了Stream并发，多个Stream只需复用一个TCP连接，节约了TCP和TLS握手时间，以及减少了TCP慢启动阶段对流量的影响。</strong></em></p><p>  服务器支持主动推送资源，大大提升了消息的传输信息</p><p>  HTTP&#x2F;2是基于TCP协议来传输数据，TCP层必须保证收到的字节数据是完成且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用。有队头阻塞问题，TCP和TLS的握手时延迟，网络迁移需要重新连接</p><h5 id="相比于HTTP-x2F-1-1的改进"><a href="#相比于HTTP-x2F-1-1的改进" class="headerlink" title="相比于HTTP&#x2F;1.1的改进"></a>相比于HTTP&#x2F;1.1的改进</h5><p>&#x3D;&#x3D;头部压缩&#x3D;&#x3D;：会压缩头，若头一样，会消除重复的部分</p><p>&#x3D;&#x3D;二进制格式&#x3D;&#x3D;：全面采用二进制格式并同城为帧（头信息帧，数据帧）。对计算机友好，提高传输效率</p><p><img src="/http-1/1.0-1.1-2.png" alt="image-20220709152032970"></p><p>&#x3D;&#x3D;数据流&#x3D;&#x3D;：数据包不是按顺序发送，每个请求或回应的所有数据包称为数据流。每个数据流里面有独一无二的编号，客户端发送的编号为奇数，服务器端发送的为偶数。多个stream复用一个TCP达到并发效果</p><p>&#x3D;&#x3D;多路复用&#x3D;&#x3D;：2.0是可以在一个连接中并发多个请求或回应，而不用按顺序对应</p><p>&#x3D;&#x3D;服务器推送&#x3D;&#x3D;：服务器也可以主动向客户端发</p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>因为多个HTTP都在复用一个TCP链接，所以一旦发生丢包，都会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求就必须这个丢的包被传回来</p><h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><p>传输层的TCP换成UDP，并在UDP协议开发了QUIC协议保证了数据的可靠传输。</p><p>QUIC</p><p>  无队头阻塞</p><p>  建立连接速度块</p><p>  连接迁移</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>SSL&#x2F;TLS协议基本流程：</p><p>  客户端向服务器所要并验证服务器的公钥</p><p>  双方协商生产‘会话密钥’</p><p>  双方采用‘会话密钥’进行加密通信</p><h4 id="SSL-x2F-TLS协议建立流程"><a href="#SSL-x2F-TLS协议建立流程" class="headerlink" title="SSL&#x2F;TLS协议建立流程"></a>SSL&#x2F;TLS协议建立流程</h4><p>1 客户端向服务器发加密通信请求（ClientHello）</p><p> 发送：客户端支持的SSL&#x2F;TLS版本、客户端产生的随机数还会用于生产‘会话密钥’、客户端支持的密码套件列表</p><p>2 服务器收到客户端请求后，客户端发出响应。</p><p>回应的内容：SSL&#x2F;TLS协议版本，若浏览器不支持就关闭加密通道；服务器产生的随机数后面用于生产；确认的密码套件列表（如RSA加密算法）；服务器的数字证书</p><p>3 客户端收到回应后，通过浏览器或操作系统中的CA公钥确认数字证书的真实性</p><p>  若没有问题，客户端从数字证书拿出公钥并使用加密报文，向服务器发送：一个随机数（服务器公钥加密）、加密通信算法那改变通知、客户端握手结束</p><p>4 服务器收到客户端的三个随机数后，通过加密算法得到‘密钥’，向客户端发最后的信息：加密通信算法改变通知、服务器握手结束通知</p><h4 id="RSA算法缺陷"><a href="#RSA算法缺陷" class="headerlink" title="RSA算法缺陷"></a>RSA算法缺陷</h4><p>最大的问题是不支持向前加密。因为客户端传递随机数给服务器端时使用的是公钥加密，服务端收到后会用私钥解密得到随机数，一旦服务端私钥泄露了，过去被第三方拦截的锁有TLS通讯密文都会破解</p><p>所以出现了DH算法</p><h4 id="HTTPS优化"><a href="#HTTPS优化" class="headerlink" title="HTTPS优化"></a>HTTPS优化</h4><p>硬件优化：</p><p>  因为https协议是计算密集型，而不是I&#x2F;O密集型，所以CPU要尽可能的好</p><p>软件优化</p><p>  软件升级：将正在使用的软件设计到最新版本。但会花费人力、时间，可能会影响上线</p><p>  协议优化（密钥交换过程优化）：就是密钥交换过程优化：即尽可能选用ECDHE密钥交换，消息忘返时间减短，安全性提高，具备前向安全性</p><p>​TLS升级：简化握手步骤。比如TLS1.3把Hello和公钥交换合并为一个消息</p><p>证书优化：传输优化：选择椭圆曲线证书而不是RSA证书，因为密钥长度短的多</p><p>​验证优化：</p><p>会话复用</p><p>​    SessionID：客户端和服务端首次TLS握手连接后，双方会在内存缓存会话密钥，并用唯一SessionID标识。服务器的内存压力越来越大，客户端再次连接不一定命中上次访问过的服务器</p><p>​    Session Ticket：服务器不缓存每个客户端的会话密钥，缓存工作交给客户端。对于集群服务器，要确保每台服务器加密‘会话密钥’的密钥一致</p><p>证书优化</p><p>证书传输优化：证书选择椭圆曲线证书而不是RSA证书。相同安全长度下，ECC比RSA短</p><p>  证书验证优化：</p><p>CRL：由CA定期更新，实时性较差，吊销证书越多，列表会越来越大，下载速度越慢</p><p>OCSP：是向CA发送查询请求，让CA返回证书的有效状态</p><h3 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h3><table><thead><tr><th align="center">http</th><th align="center">https</th></tr></thead><tbody><tr><td align="center">有安全风险问题</td><td align="center">TCP和HTTP层间加入了SSL&#x2F;TLS安全协议，报文能加密传输</td></tr><tr><td align="center">建立相对简单，TCP三次握手后就进行http报文</td><td align="center">TCP三次握手后还要SSL&#x2F;TLS的握手才能加密报文传输</td></tr><tr><td align="center">端口号80</td><td align="center">端口号443</td></tr><tr><td align="center">不需要数字证书证明身份</td><td align="center">需要向CA申请数字证书来保证服务器的身份可信</td></tr></tbody></table><h3 id="HTTPS解决HTTPS的风险"><a href="#HTTPS解决HTTPS的风险" class="headerlink" title="HTTPS解决HTTPS的风险"></a>HTTPS解决HTTPS的风险</h3><p>因为在HTTP与TCP层之间加入了SSL&#x2F;TLS协议</p><p>窃听风险：混合加密。混合加密的方式实现机密性</p><p>篡改风险：校验机制。摘要算法实现完整性，能生成独一无二的‘指纹’，用于校验数据的完整性，解决篡改风险</p><p>冒充风险：身份证书。要服务器公钥放入数字证书中</p><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>实现信息的机密性，解决窃听风险</p><p>HTTPS采用的是对称加密和非对称加密结合的‘混合加密’</p><ul><li><p>在通信建立前采用非对称加密的方式交换‘会话秘钥’，后续就不再使用非对称加密</p></li><li><p>在通信过程中全部使用对称加密的‘会话秘钥’的方式加密明文数据</p><img src="http-1/hunhe.png" alt="image-20220709115118267" style="zoom: 67%;"></li></ul><p>混合加密的原因：</p><p>  对称加密只用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换</p><p>  非对称加密用两个密钥，公钥和私钥，公钥可任意分发而私钥保密，解决密钥交换问题。速度慢</p><p>使用对称加密而不用非对称加密的原因：因为非对称加密解密算法效率较低，不适合客户端和服务端的高频率通信过程。</p><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>用来实现完整性，解决篡改风险</p><p><img src="/http-1/zhaiyao.png" alt="image-20220709120309951"></p><p>客户端在发送明文之前会通过算法算出明文的‘指纹’，发送时‘指纹+明文’一起加密成密文后发送给服务器，服务器解密后用相同摘要算法算出发送过来的明文，通过比较自己算出的‘指纹’和从客户端来的‘指纹’是否相同</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>客户端向服务器要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密</p><p>将服务器公钥放在数字证书，证书可信即公钥可信</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP基础</title>
      <link href="/2022/05/17/TCP/"/>
      <url>/2022/05/17/TCP/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>TCP是传输层控制协议</p><p><img src="/2022/05/17/TCP/chuanshu.png"></p><p>在运输层的可靠数据传输的服务，面向连接【1对1】、可靠的【一个报文一定能到达接收端】、基于字节流的传输层通信协议</p><p>经常用于FTP文件传输；HTTP&#x2F;HTTPS</p><p>头部包含端口号、序列号</p><p>唯一确定一个TCP连接：TCP四元组（源地址、源端口、目的地址、目的端口）</p><p><img src="/2022/05/17/TCP/jiegou.png" alt="结构"></p><p>标志位</p><p>URG：表示TCP包的紧急指针域有效，<em><strong>保证TCP连接不被中断</strong></em></p><p>ACK：应答域有效</p><p>PSH：push操作，让到达接收端的数据包能直接传给应用程序</p><p>RST：连接复位请求</p><p>SYN：建立连接</p><p>FIN：断开连接</p><h1 id="如何保证可靠性"><a href="#如何保证可靠性" class="headerlink" title="如何保证可靠性"></a>如何保证可靠性</h1><p>  应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传送</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><p>  流量控制：控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率</p><p>  拥塞控制：网络拥塞时，减少数据发送。慢启动（每收到 一个ACK，拥塞窗口就+1，直到增加到门限状态变量），拥塞避免（超过慢启动门限后进行，每个ACK，cwnd+1），拥塞发生（超时重传，快速重传（cwnd&#x3D;cwnd&#x2F;2,ssthresh&#x3D;cwnd）），快速恢复<br>   超时重传：TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；数据包丢失或确认应答丢失会发生该情况。定时器太长，重发就满了，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时</p><p>  QRQ协议：为实现可靠重传，每发完一个分组后就停止发，收到对方发的确认后再发下一个</p><p>重传机制：</p><p>  超时重传：如上</p><p>  快速重传：以数据驱动重传。收到三个相同ACK报文时，立刻重传丢失报文段</p><p>滑动窗口：</p><p>  TCP头部有一个字段交Window（窗口大小），接收端告诉发送端子机还有多少缓冲区可接收数据，于是发送端就根据这个发送数据。大小为0时，就会阻止发送方发送数据</p><p>解决窗口关闭：TCP为每个链接设有一个持续定时器，只要TCP连接一方收到对方的零窗口通知，就启动该定时器，定时器超时的话就发送窗口检测报文，而对方确认该报文时给出自己接收窗口大小</p><h1 id="黏包"><a href="#黏包" class="headerlink" title="黏包"></a>黏包</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多个数据包被连续存储在连续的缓存中，在对数据包读取时由于无法确定发生方的发送边界，而采用某一估测值大小来读出数据。双方size不一致就会让发送方发送的若干包数据到接收方接收时沾成一包，从接收缓冲区看，后一包的数据的头紧接着前一包数据的尾</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>TCP若连续几次发送的数据很少，那TCP根据优化算法把这些数据合成一包一次发送，接收方就收到了粘包数据</p><p>  TCP协议有MISS，若数据包过长就会被分开传输。接收方就收到粘包数据</p><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>TCP短连接就不用考虑</p><p>若数据无结构，发送放就只管发，接收方只管接，也不用考虑</p><p>双方建立长连接，要在连接一段是时间内发送不同数据结构：</p><p>​         发送端的每个数据包添加包首部，首部中应该至少包含数据包的长度。这样接收方就能知道数据包的实际长度</p><p>​         发送端将每个数据包封装为固定长度（不够的，0补充），接收端每次就从接收缓冲区中读取固定长度的数据就行，也就拆开了数据包</p><p>​         可在数据包之间设置边界</p><h1 id="与UDP的比较"><a href="#与UDP的比较" class="headerlink" title="与UDP的比较"></a>与UDP的比较</h1><table><thead><tr><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">面向连接</td><td align="center">无连接</td></tr><tr><td align="center">提供可靠服务</td><td align="center">尽最大努力交付</td></tr><tr><td align="center">面向字节流</td><td align="center">数据报文段</td></tr><tr><td align="center">每一条TCP连接都是点到点</td><td align="center">支持一对一，一对多，多对多的交互通信</td></tr><tr><td align="center">首部开销20字节</td><td align="center">首部开销8字节</td></tr><tr><td align="center">全双工可靠通信</td><td align="center">不可靠通信</td></tr><tr><td align="center">常用于FTP文件传输、HTTP&#x2F;HTTPS</td><td align="center">包总量较少信息，视频、音频等多媒体通信，广播通信</td></tr><tr><td align="center">传输较慢，所需资源较多</td><td align="center">传出快，所需资源少</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile</title>
      <link href="/2022/05/16/volatile/"/>
      <url>/2022/05/16/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>是java提供的一个轻量级的同步机制。java中有两种内在的同步机制：同步块和volatile变量，与synchronized相比，volatile更轻量，<em><strong>不会引起线程上下文切换和调度</strong></em>，但是同步性也较差</p><h1 id="并发编程的基本概念"><a href="#并发编程的基本概念" class="headerlink" title="并发编程的基本概念"></a>并发编程的基本概念</h1><p>原子性：一个或多个操作，要么全部执行且过程中不会打断，要么就都不执行。即拒绝多线程操作，同一时刻就只有一个线程进行操作。整个操作中，不会被线程调度器中断的操作，都可以认为是原子性</p><p>可见性：当多个线程去访问一个变量的时候，一个线程修改了一个或多个变量后，其他线程能够立刻看到这些被修改后的值。多线程环境下，一个线程对共享变量的操作对于其它线程是不可见的。volatile来保证可见性，变量被其修饰后，线程本地的内存就会无效，线程对该变量修改后就会同步更新到主内存中，其它线程读取变量时，就会从主内存中读取。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行</p><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>JMM决定一个线程对共享变量的写入在什么时候对另一个线程是可见的。JMM定义了线程和主内存之间的抽象空间：共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的操作必须在工作内存中进行，而不能直接读写主内存中的变量</p><img src="/2022/05/16/volatile/JMM.png" alt="JMM" style="zoom:50%;"><p>对于普通的共享变量，线程A将其修改为某个值的过程在本地内存A中，并没有同步到主内存中；而线程B已经缓存了该变量的旧值，也就导致了共享变量的值不一样。加锁（lock或synchronized）可以解决这样的问题，但是太重量级，影响效率，所以使用volatile</p><p>JMM是个<em><strong>抽象的内存模型</strong></em></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>保证共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量</p><p>该关键字能保证修改的值能立即被更新到主存</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JVM底层volatile是采用<em><strong>内存屏障</strong></em>实现，观察加入volatile关键字和没有加的关键字所产生的汇编代码发现，加入后的会有一个lock指令，实际上相当于一个内存屏障</p><p>内存屏障的作用：</p><p>​能确保指令重排时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障后面的；即执行到内存屏障这句指令时，前面的操作就已经完成</p><p>​会强调对缓存的修改操作立即写入主内存</p><p>​若是写操作，会让其它CPU中对应的缓存行无效，即必须从主内存中读取变量</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>可见性：对一个volatile变量的读，总能看到（任意线程）对该volatile变量最后的写入</p><p>防止指令重排的问题。</p><p>Java虚拟机中，每个线程对应一个工作内存，并共享主内存的数据</p><p>JMM：线程解锁前，必把共享变量的值刷新回主内存；加锁前，必须读主内存的值到自己的工作内存；加锁和解锁是同一把锁</p><h2 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h2><p>JMM会分别限制两种类型的重排序：编译重排序和处理器重排序</p><p>编译重排序：当第二个操作是volatile写时，不管第一个，都不能重排序；当第一个是读时，不管第二个，都不能重排序；第一个写，第二个读，不能</p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><p>对变量的写入操作不依赖变量的当前值或能确保只有单个线程改变变量的值</p><p>该变量不会与其他状态变量一起纳入不变性条件中</p><p>访问变量时不需要加锁</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p>volatile保证了<em><strong>可见性</strong></em>，提供了一定的<em><strong>有序性</strong></em>，<em><strong>不保证原子性</strong></em>。</p><h1 id="单例模式的双重锁为什么要写volatile"><a href="#单例模式的双重锁为什么要写volatile" class="headerlink" title="单例模式的双重锁为什么要写volatile"></a>单例模式的双重锁为什么要写volatile</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//在并发情况下，若没有volatile关键字，该行会出问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton();//分解为三行</span><br><span class="line"></span><br><span class="line">a. memory = allocate() //分配内存</span><br><span class="line"></span><br><span class="line">b. ctorInstanc(memory) //初始化对象</span><br><span class="line"></span><br><span class="line">c. instance = memory //设置instance指向刚分配的地址</span><br></pre></td></tr></table></figure><p>若没有volatile，可能会出现重排序的情况。多线程环境下，可能执行了a，c，没有执行b，A线程执行了c导致instance指向了一个地址，所以判断instance不会null，会直接返回一个初始化对象</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2022/05/15/String/"/>
      <url>/2022/05/15/String/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h1><p>String中使用了final关键字修饰字符数组保存字符串，所以Stirng对象是不可变的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java9之后，String、StringBuilder、StringBuffer都改用byte数组存储</span><br><span class="line">为什么从char字符改为byte字符？</span><br><span class="line">因为节省内存空间，byte占一个字节（8位），char占用两个字节，所以节省了一半的内存空间。降低了gc的压力，针对初始化的字符，对字符长度进行判断而选择不同的编码方式</span><br></pre></td></tr></table></figure><p>StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在该类中也是使用字符数组保存字符串char [] value，但是没有用final关键字修饰，所以这两种对象是可变的</p><p>AbstractStringBuilder类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This no-arg constructor is necessary for serialization of subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an AbstractStringBuilder of the specified capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>因为String类的不可变性，才让JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量中的同一个对象。这样<em><strong>节约内存又提升性能</strong></em></p><p>也因为不可变性，保证了字符串对象在<em><strong>多线程环境下是线程安全的</strong></em>。若String可变，那么会引发严重的安全问题。<em><strong>因为字符串不可变，所以值不能被修改，若字符串是可变的，那么可以通过改变引用地址指向的值去改变字符串的值，也就有安全漏洞</strong></em></p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>String因为不可变，可以<em><strong>理解</strong></em>为常量，线程安全。AbstractStringBuilder是StringBuilder和StringBuffer的公共父类。其中StirngBuffer加了同步锁或者调用的方法加了同步锁，线程安全。StringBuilder并没有对方法加同步锁，线程非安全</p><h1 id="Buffer和Builder"><a href="#Buffer和Builder" class="headerlink" title="Buffer和Builder"></a>Buffer和Builder</h1><p>都是AbstractStringBuilder的子类，但是StringBuffer的几乎所有方法都使用synchronized实现了同步，线程比较安全，在多线程系统中可以保证数据同步。</p><p>而StringBuilder没有实现同步，线程不安全，但是正因如此，效率更高</p><h2 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h2><p>二者的构造方法，默认都是16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer.java </span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">       append(str);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//StringBuilder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">       append(str);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过append方法中的ensureCapacityInternal方法可以触发扩容newCapacity获得新的容量大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value,</span><br><span class="line">                    newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//计划的扩容为 当前的容量*2+2.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            ? hugeCapacity(minCapacity)</span><br><span class="line">            : newCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/2022/05/14/thread/"/>
      <url>/2022/05/14/thread/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>新建(new)，就绪(runnable)，运行(running)，阻塞(block)，死亡(dead)</p><p>新建：使用new创建一个线程，此时仅由jvm为其分配内存，并初始化其成员变量的值</p><p>就绪：调用了start()方法，jvm为其创建方法调用栈和程序计数器</p><p>运行：就绪状态获取了cpu，开始执行run方法</p><p>阻塞：因某种原因放弃了cpu的使用，暂时停止运行，直到进入可运行状态</p><p>​    等到阻塞:运行o.wait()方法，JVM会把线程放入等待队列</p><p>   同步阻塞:运行的线程获取对象的同步锁时，若该锁被占用，则JVM把该线程放入锁池</p><p>​    其他阻塞:运行sleep()或t.join()或I&#x2F;O请求，JVM把该线程设为阻塞状态</p><p>死亡：正常结束或异常结束或调用线程的stop()方法（该方法易导致死锁）</p><p>Blocked和waiting的区别：线程可以通过notify进入waiting状态，进入后就等待唤醒才有获取cpu的时间片段来继续执行；blocked状态是无法进入同步方法&#x2F;代码完成的，因为无法获取相关联的锁</p><h1 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h1><p>继承Thead类</p><p>​自定义类继承Thread类，重写run()方法，创建线程对象并启动线程（start()方法，不是run；线程不能多次启动，只能执行一次）</p><p>实现Runnable接口</p><p>​自定义类实现Runnable接口，重写run()方法，创建自定义类对象，创建Thread类的对象，并把创建的自定义类的对象作为构造参数传递，启动线程</p><p>使用Callable和Future创建线程</p><p>​ 创建Callable接口的实现类，并实现call()方法，再创建该实现类的实例。使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值。使用FutureTask对象作为Thread对象的target创建并启动线程。调用FutrueTask对象的get()方法来获得子线程执行结束后的返回值</p><p>线程池实现</p><p>实现线程间共享数据：线程间共享对象，然后wait&#x2F;notify&#x2F;nofifyAll</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>  线程数小于核心线程数—&gt;核心线程数</p><p>  线程数大于核心线程数 —&gt;将多余的放入任务队列</p><p>  任务队列满了，就启动最大线程数</p><p>  最大线程数也达到后，就启动拒绝策略</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p> ThreadPoolExecutor.AbortPolicy：线程池默认的，即丢弃任务并抛出RejectedExecutionException异常</p><p>  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃</p><p>  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</p><p>  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务（不会丢弃任务，最后所有的任务都执行了，并不会抛出异常）</p><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>通过构造方法ThreadPoolExecutor</p><p><img src="/2022/05/14/thread/executors.png" alt="image-20220427110329004"></p><p>构造方法参数</p><p><img src="/2022/05/14/thread/threadPoolExecutor.png" alt="image-20220514145815343"></p><p>  CorePoolSize：核心线程数，默认状况下核心线程会一直存活；</p><p>  maximumPoolSize:线程池所能容纳的最大线程数。超过将被阻塞</p><p>  keepAliveTime:非核心线程的闲置时间超过时间，超过就会被回收</p><p>  unit：指定keepApliveTime的单位。但allowCoreThreadTimeOut设为true就无效</p><p>  workQueue：线程池的任务队列</p><p>  threadFactory：线程工厂，提供创建新线程时使用的工厂</p><p> handler：拒绝策略。当工作队列的任务和线程中的线程均到最大限制，就触发拒绝策略</p><h2 id="拒绝策略-1"><a href="#拒绝策略-1" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>  ThreadPoolExecutor.AbortPolicy：线程池默认的，即丢弃任务并抛出RejectedExecutionException异常</p><p>  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃</p><p>  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</p><p>  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务（不会丢弃任务，最后所有的任务都执行了，并不会抛出异常）</p><h2 id="execute-和submit"><a href="#execute-和submit" class="headerlink" title="execute()和submit()"></a>execute()和submit()</h2><p> Execute()用于提交不需要返回值的任务，so 不能判断线程池任务是否成功执行；Submit()用于提交需要返回值的任务</p><p>Execute是只能提交Runnable类型的任务，submit可以提交Runnable和Callable类型</p><p>Execute可以抛出异常，submit不排除异常（可以通过Future的get将任务执行时的异常抛出）</p><h1 id="为什么调用了start-后必须调用run-方法"><a href="#为什么调用了start-后必须调用run-方法" class="headerlink" title="为什么调用了start()后必须调用run()方法"></a>为什么调用了start()后必须调用run()方法</h1><p>new 一个 thread，线程进入新建状态，调用start()方法，会启动一个线程并使线程进入就绪状态，当分配时间片后就可以运行。Start会执行线程的准备工作，再自动执行run()。这才是真正的多线程工作。但直接run()，会吧其当成一个main线程下普通方法执行</p><p>总之：调用start()方法可启动线程并使线程进入就绪状态，直接run不会以多线程方式执行。但是执行start方法，线程不一定马上创建，因为底层是操作系统，是否创建线程需要看情况。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashmap</title>
      <link href="/2022/05/13/hashmap/"/>
      <url>/2022/05/13/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p><em><strong>主干是entry数组</strong></em>，每个entry保存了key和value。要添加键值对的时候会根据一个hash算法计算key后的值，再通过数组大小n-1&amp;hash值之后，得到一个数组的下标，然后往那个位置塞入这个entry。</p><p>默认大小16，负载因子0.75；当数量达到16* 0.75&#x3D;12时，就会扩容，扩容设计到rehash、复制数据等操作，很消耗性能，<em><strong>提前预估大小</strong></em></p><p>在JDK1.8以前：以数组和链表的形式组成。当数据越多，查询效率O(N)会越来越大。并且是<em><strong>先扩容再进行插入</strong></em></p><p>在JDK1.8后：引入了红黑树，链表元素超过阈值8时，链表转为红黑树；&lt;&#x3D;6时，树还原成链表。原因：红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；而且是先插入，再看size是否大于阈值，大于则扩容</p><p><img src="/2022/05/13/hashmap/jiegou.png" alt="image-20220427110202488"></p><h1 id="负载因子0-75"><a href="#负载因子0-75" class="headerlink" title="负载因子0.75"></a>负载因子0.75</h1><p>作用就是扩容机制的阈值。若是1.0，hashmap就会有大量冲突，底层的红黑树会很复杂，查询效率很低，空间利用率上去，时间效率降低；若是0.5，hash冲突减少，底层的链表长度和红黑树的高度会降低，时间效率提升，空间利用率降低。0.75就比较适中，空间利用率较高，避免比较多的冲突</p><h1 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h1><p>JDK1.7：</p><p>​判断当前数组是否要初始化</p><p>​    若key为空，则put一个空值进去</p><p>​通过hash()函数计算key哈希值，并得到其下标</p><p>​将hash、key、value等信息封装成一个entry对象</p><p>​根据当前下标位置上的节点情况，采用不同方法放置此节点（若key和传入的key相等则覆盖原来的key，反之增新增一个entry对象）。链表和红黑树的情况放置</p><p>JDK1.8:</p><p>​ 实际是调用putval方法，计算的key的hash值、key、value都放过去</p><p>判断底层的table表是否空，空就扩容到16；根据key计算hashcode，再通过hash值得到table表的下标索引；</p><p>若当前位置没有节点，就挂上去。</p><p>若有节点，先判断表里的key和输入的key或者内容是否相同，相同就赋值给e</p><p>​            若不相同，则判断是否是红黑树，若是则根据红黑树的原理加 </p><p>​                          也不是红黑树，则遍历链表，链表没有一个key相同，则放在最后；存在相同就覆盖</p><p>​    判断是否需要扩容</p><p>put源码1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//计算键的哈希值，放值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="comment">//链表数组；链表对象；           长度； 索引</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="comment">// tab是否为空或者长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 是：就执行扩容方法，数组的长度是扩容后的长度</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 获取tab的第i个元素，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 为空就赋值给第i个</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//就会有两种情况，hash值重复、碰撞了</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断key值是否重复了</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//就直接把上一个的值覆盖</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//判断tab[i]是否是红黑树 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据红黑树的性质插入值</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是红黑树就是链表，就开始遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//判断是否是最后一个或者是否是空，是空就插入进链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//判断链表的长度是否是大于8的，若是则转为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//key是否存在，存在就覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e不为空，就将e添加到tab中</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//当前的数量是否大于阈值，大于就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>流程图</p><p><img src="/2022/05/13/hashmap/put-liucheng.png" alt="image-20220513124451221"></p><h1 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h1><p>JDK1.7</p><p>​通过hash()计算key的哈希值，得到其下标，判断该位置是否是链表；不是就根据key、value的hashcode是否相等返回值。为链表就遍历直到 key和hashcode相等就返回。遍历完也没有就返回null</p><p>JDK1.8：</p><p>创建一个Node节点 e，调用getNode方法，传参计算的hash值和key值</p><p>  计算hashcode得到桶，桶空就返回null；判断桶的第一个位置的key是否为查询的key，是就返回value；不是就判断下一个是红黑树还是链表，就根据红黑树和链表进行查找（都是遍历，查找）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="comment">//判断是否为空，判断key对应的链表节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断链表头部元素是否是key值对应的真实value</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//链表是否含有下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//是否红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//根据红黑树的逻辑查找对应的value</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//根据hash和key值判断下一个元素是否是key值对应的真实value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//什么都没找到，就为null值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="与HashTable的比较"><a href="#与HashTable的比较" class="headerlink" title="与HashTable的比较"></a>与HashTable的比较</h1><table><thead><tr><th align="center">HashMap</th><th align="center">HashTable</th></tr></thead><tbody><tr><td align="center">继承的AbstractMap</td><td align="center">继承的Dictionary</td></tr><tr><td align="center">Null可以作为键（只有一个），也可以作为值（多个）</td><td align="center">不支持Null key和Null value</td></tr><tr><td align="center">线程不安全，多线程并发可能导致死锁。但也因此效率更高</td><td align="center">线程安全，因每个方法都有Synchronize方法</td></tr><tr><td align="center">默认初始化大小16，每次扩容为原来的2倍</td><td align="center">默认初始化大小11，每次扩容为原来的2*N+1</td></tr><tr><td align="center">计算hash值的方法不同</td><td align="center">计算hash值方法不同</td></tr><tr><td align="center">遍历方法的内部实现不同</td><td align="center">遍历内部实现不同</td></tr><tr><td align="center">没有contains方法</td><td align="center">有contains方法</td></tr></tbody></table><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手四次挥手基础</title>
      <link href="/2022/05/12/threefour/"/>
      <url>/2022/05/12/threefour/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>建立可靠的通信信道，也就是<em><strong>双方确认自己与对方发送与接收是正常的</strong></em></p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端随机初始化序号，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SEBT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><p><img src="/2022/05/12/threefour/woshou.png" alt="image-20220512090045815"></p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1），等待服务器发FIN报文；当服务器端确定数据（读到结束符EOF）已发送完成，则向客户端发FIN报文，延迟一段时间 再发ACK报文（处理一些最后的请求）；客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传）；服务器端收到ACK就关闭，客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/05/12/threefour/huishou.png" alt="image-20220512090215143"></p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以阻止重复历史连接的初始化（最主要，若是两次握手就不能判断）：若是历史连接，客户端发送的报文就是RST报文，反之则是ACK报文</p><p>同步双方的初始序列号：</p><p>避免资源浪费：  若服务端阻塞，发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：就没办法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</p><h1 id="握手是三次，挥手是四次"><a href="#握手是三次，挥手是四次" class="headerlink" title="握手是三次，挥手是四次"></a>握手是三次，挥手是四次</h1><p>当服务器端收到SYN连接请求报文后，可以直接发SYN+ACK报文，ACK是应答，SYN是同步的。关闭时，服务器端收到FIN时，有可能不会立即关闭SOCKET，所以只能先回一个ACK报文</p><p>但在抓包时，服务器接收到FIN后，服务器端同时要关闭链接，这样ACK和FIN一起发送节省了一个包。从抓包方面看，就是“三次挥手”</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB基础</title>
      <link href="/2022/05/11/InnoDB-1/"/>
      <url>/2022/05/11/InnoDB-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>现mysql 5.5后默认引擎，兼顾高可靠性和高性能性的通用存储引擎</p><p>若要对事务的完整性要求较高、要求实现并发的话，InnoDB有大优势；若频繁更新、删除操作也可，因为支持事务的提交和回滚</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>​    DML遵循ACID模型，支持<em><strong>事务</strong></em>。<em><strong>行级锁</strong></em>（加锁开销最大，加锁慢，会出现死锁），提供并发性能；支持<em><strong>外键</strong></em>FOREIGN KEY约束，保证数据的完整性和正确性。</p><p><em><strong>数据块要缓存</strong></em>；寻址要映射到块，再到行；要维护MVCC一致，所以Innodb在select的时候要维护的东西比较多</p><p>delete表的时是一行一行删除，而myisam则是先drop表，再重建表</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>聚集索引：</p><p>​将数据存储与索引放到一块，索引的叶子节点保存了行数据，必有且只有一个聚集索引。若有主键，主键即是；无主键用第一个唯一索引；若都没，会自动生成一个rowid作为隐藏的聚集索引。</p><p>索引结构：</p><p>​B+树：将所有数据都放在叶子节点，叶子节点形成一个列表，非叶子只存放键值，每个数据叶中的有效数据就多了，可以减少IO次数</p><p>​    因为相对于二叉树（会有左倾右倾的情况），B+树层级更少，搜索效率高</p><p>​    因为B树：无论叶子节点还是非叶子，都保存数据，所以存储值减少，指针就减少，要同样保存大量数据，只能增加树的高度，导致性能降低，要查找就要遍历整个树</p><p>​    Hash索引只支持等值匹配，不支持排序操作</p><p>二级索引：将数据与索引分开，索引结构的叶子节点关联的是对应的主键</p><h1 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h1><p>TableSpace(表空间)：可以看成Innodb逻辑存储的最高层，所有的数据都存放在表空间内</p><p>Segment（段）：分为数据段、索引段、回滚段。Innodb是索引组织表，数据段是B+树的叶子节点，索引段为B+的非叶子节点。段用来管理多个区</p><p>Extent（区）：表空间的单元结构，每个区默认1M。innodb引擎页大小为16K。连续的页组成</p><p>Page（页）：每个默认16KB，存储引擎磁盘管理的最小单位。数据页、undo页、系统页、事务数据页</p><p>Row（行）：存放的数据</p><h1 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h1><p>Buffer Pool（缓冲池）：</p><p>内存的速度弥补磁盘速度较慢对数据库性能的影响。</p><p>​数据库进度页的操作，先将从磁盘读到的页存放在缓冲池中，下次再读相同的页时，判断是否在缓冲池，若在就直接读取该页（命中），否在就读取磁盘上的页</p><p>​主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据。增删时，先操作缓冲池的页（没有，则从磁盘加载），再以Checkpoint的机制刷新到磁盘，也就<em><strong>减少磁盘IO，加快处理速度，提升了效率</strong></em>。</p><p>​    页为单位，默认16KB，索引页、数据页、undo页、插入缓冲、自适应哈希表页等。<em><strong>页与页之间形成了双向链表，同时使用LRU算法淘汰不常用的数据</strong></em>；每页的内部使用单向链表进行连接，因为数据是分散到Buffer Pool中，需要把这些分散的内存连接。</p><p><img src="/2022/05/11/InnoDB-1/22.png" alt="22"></p><h5 id="优化的LRU算法"><a href="#优化的LRU算法" class="headerlink" title="优化的LRU算法"></a>优化的LRU算法</h5><p>出现原因：因为实际生产中，会存在全表扫描的情况，若数据量较大，可能会将Buffer Pool中存下来的热点数据全部替换，性能就会极具下降。所以 <em><strong>缓冲池污染</strong></em></p><p>优化后的链表被分为两个部分，分别占用Buffer Pool的四分之三（New Sublist）和四分之一（Old Sublist）。</p><p>New Sublist：存放较为频繁的页</p><p>Old Sublist：存放不频繁的页，会在后续Buffer Pool剩余空间不足，或者有新的页加入时被移除     </p><p>Change Buffer（更改缓冲区）：执行DML时，操作的数据不在buffer pool中就不会操作磁盘，会将数据变更存在此处，在未来数据被读取时，再将数据合并恢复到缓冲池，再将合并后的数据写到磁盘</p><p>意义：可以在缓冲池中间进行合并处理，减少磁盘IO。因为二级索引一般非唯一，并且以相对随机的顺序插入二级索引。</p><p>Log Buffer（日志缓冲区）：用来保存要写入到磁盘中的log日志，默认16MB，日志缓冲区的日志可自己配置定期刷新到磁盘中。若日志缓冲区较大，就可存储更多Redo log，所以事务提交前就不需要将Redo Log刷入磁盘，只需要丢到Log Buffer。</p><p><em><strong>较大的Log Buffer可更好的支持事务的运行。若事务有大量更新、插入或删除行，可适当增加Log Buffer，可有效减少磁盘的IO操作</strong></em></p><p><img src="/2022/05/11/InnoDB-1/jiegou.png" alt="image-20220511134406227"></p><h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p>有多个内存块，可以认为这些内存块组成了一个大的内存池</p><p>负责： 维护所有进程；线程需要访问的多个内部数据结构</p><p>​缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前这这里缓存</p><p>​重做日志缓冲</p><p><img src="/2022/05/11/InnoDB-1/11.png" alt="1"></p><p>其中后台线程的主要作用是 负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下，Innodb能恢复到正常运行状态</p><h1 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h1><p>后台线程有多种，以完成不同的任务：</p><p>​Master Thread：核心，负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性（脏页的刷新，合并插入缓冲，UNDO页的回收）</p><p>​IO Thread：Innodb用AIO来处理IO请求，所以IO Thread负责将IO请求回调处理</p><p>​Pruge Thread：事务被提交后，undolog可能不需要，所以Pruge Thread来回收已经使用并分配的undo页</p><p>​Page Cleaner Thread：之前版本中脏页的刷新操作都放入到单独的线程中来完成。以减轻Masterr Thread的工作及用户查询线程的阻塞，提高性能</p><h1 id="保证ACID"><a href="#保证ACID" class="headerlink" title="保证ACID"></a>保证ACID</h1><p>Redo log（重做日志）：保证持久性。记录的是事务提交时数据页的物理修改。记录的是物理日志</p><p>​    重做日志缓冲：在内存   重做日志文件：在磁盘</p><p>​    当事务提交后把所有信息都存到日志文件，用于刷新脏页到磁盘；发生错误，进行数据恢复使用</p><p>​    在脏页信息发生错误时进行数据恢复，也就是持久性。</p><p>Undo log（回滚日志）：保证原子性。记录数据被修改前的操作。逻辑日志</p><p>​             作用：提供回滚和MVCC</p><p>​             Delete时，undo log里记录insert；update时，会记录反向的update语句 </p><p>​         当事务提交时不会立即删除，因为可能用于MVCC</p><p>​         采用段的方式进行管理和记录</p><h1 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h1><p>通过MVCC。</p><p>MVCC会给每行元祖加一些辅助字段，记录版本号和删除版本号，每一个事务启动都有一个唯一的递增的版本号。每开启一个事务，事务版本号就会递增</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized基础</title>
      <link href="/2022/05/10/synchronized-1/"/>
      <url>/2022/05/10/synchronized-1/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>解决多个线程之间访问资源的同步性，该关键字可保证修饰的方法或代码块在任意时刻只能有一个线程执行。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>JVM是通过进入、退出对象监视器来实现对方法、同步块的同步，而对象监视器的本质依赖于底层操作系统的互斥锁实现，能自动解锁</p><p>使用：</p><p>作用于普通方法时：锁的是对象的实例，即this对象，所谓的方法锁。进入同步代码块，要获得当前实例的锁</p><p>修饰静态方法时：锁的是这个类的所有class对象，即xxx.class  类锁。会作用于所有对象实例。进入同步代码要获得当前类对象的锁</p><p>修饰代码块（在方法中）时：锁的是synchronized(obj)，用户给定的对象，对象锁。进入同步代码要获得给定对象的锁</p><p><img src="/2022/05/10/synchronized-1/use.png" alt="use"></p><p>不能在类级别的（静态）代码块</p><p>特点：</p><p>  原子性、可见性（释放锁时，所有写入都会写回内存，获得锁就会从内存读取最新数据）、有序性；可重入性（对同一个线程在获得锁后，在调用其他需同样锁的代码时可直接调用）；重量级（底层是一个监视器对象完成。监视器锁的本质是依赖于操作系统的互斥锁实现）</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p> 偏向锁：Java6之后加的新锁。会偏向当前已经占领锁的线程 ，总是让一个线程多次获得。只在第一次请求锁时采用CAS操作并将锁对象的标记字段记录为当前线程地址。之后，持有该锁的线程无需加锁操作</p><p>​线程在进入同步代码块获得锁时，会检查对象头中是否存储了线程ID，若没有，判断一下偏向标志位是否为1，若不是1，说明该锁没有被任何线程获取，就CAS的方式替换mark word，将对象Mark word中的线程ID指向该线程，并将偏向标志位置位</p><p>  轻量锁：多个线程在不同时间请求同一把锁，即没有锁竞争。代码进入同步块时，若同步对象无锁，当前线程会在栈帧中创建一个锁记录区域，同时将锁对象头中的mark word拷贝到锁记录，再使用CAS将mark word 更新为指向锁记录的指针</p><p>  自旋锁：轻量级失败后，进行。基于大多数情况下，线程持有锁的时间都不会太长。因为线程间的切换操作系统需要从用户态到核心态，时间成本高。线程没有获取到锁的时候，虚拟机让线程做几个时间不太久的空循环（即自旋），循环后再次去尝试获取锁，若得到锁就进入临界区，反之就会被在操作系统层面挂起。<em><strong>提升了效率</strong></em>，最后没办法就只能升级为重量级锁</p><p>  锁消除：<em><strong>删除不必要的加锁</strong></em>。虚拟机在JIT编译时，扫描运行上下文，去除不可能存在共享资源竞争的锁。</p><p>  锁粗化：将多次连续的加锁、解锁操作合并为一次，将多个连续的锁拓展成一个更大的锁</p><p> 构造方法不能使用该关键字修饰，因为构造方法本身就线性安全</p><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p>是通过monitorenter获取锁，通过monitorexit释放锁</p><p>出现两个monitorexit：防止同步代码块中线程因异常退出，而锁没有释放，这必然会导致死锁。<em><strong>最后一个monitorexit保证在异常情况下，锁也可以得到释放，避免死锁</strong></em></p><h1 id="和Lock比较"><a href="#和Lock比较" class="headerlink" title="和Lock比较"></a>和Lock比较</h1><p>相同点：</p><p>  都是可重入锁；都保证了可见性和互斥性；都可以用于控制多线程对共享对象的访问</p><p>不同点</p><table><thead><tr><th align="center">ReetrantLock</th><th align="center">synchronized</th></tr></thead><tbody><tr><td align="center">默认也是非公平，但可以实现公平锁</td><td align="center">锁非公平</td></tr><tr><td align="center">只是lock接口下的实现类，是API层面的锁</td><td align="center">是JVM级别的锁</td></tr><tr><td align="center">显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作</td><td align="center">隐式获取锁和释放锁</td></tr><tr><td align="center">等待可中断、可实现公平锁、可实现选择性通知</td><td align="center"></td></tr><tr><td align="center">是可精确唤醒</td><td align="center">要么随机唤醒一个线程，要么唤醒所有等待的线程</td></tr></tbody></table><p>隐式锁和显示锁就是在使用的时候，使用者是否要手动写代码来控制获取锁和释放锁</p><p>公平锁实现：获取锁时，会先看sync队列是否在 等待获取资源的线程。没有就尝试获取锁，若有就将当前线程封装成node加入sync队列</p><p>非公平锁实现： 当线程争锁时，会进行一次CAS尝试获取锁，失败就进入acquir(1)函数，再尝试获取锁，若失败就将当前线程封装成node加入sync队列，就等前面线程执行完轮到自己</p><h1 id="和volatile比较"><a href="#和volatile比较" class="headerlink" title="和volatile比较"></a>和volatile比较</h1><table><thead><tr><th align="center">Synchronized</th><th align="center">Volatile</th></tr></thead><tbody><tr><td align="center">性能较差</td><td align="center">线程同步的轻量级实现，性能更好</td></tr><tr><td align="center">可以修饰方法以及代码块</td><td align="center">只能用于变量</td></tr><tr><td align="center">原子性、可见性都保证</td><td align="center">可保证数据的可见性，不保证原子性</td></tr><tr><td align="center">解决的是多线程之间访问资源的同步性</td><td align="center">解决变量在多个线程间的可见性</td></tr><tr><td align="center">因为是锁，可能造成线程阻塞</td><td align="center">不会线程阻塞</td></tr><tr><td align="center">标记的变量可以被编译器优化</td><td align="center">标记的变量不会被编译器优化</td></tr></tbody></table><p>内存屏障：是CPU的重排列指令引起的</p><p>Volatile通过内存屏障禁止指令重排序</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC基础</title>
      <link href="/2022/05/09/springmvc-1/"/>
      <url>/2022/05/09/springmvc-1/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><img src="/2022/05/09/springmvc-1/MVCP.png" alt="MVC" style="zoom:80%;"><p>是软件工程中的一种软件架构模式，它把软件系统分为模型、<strong>视图</strong>和<strong>控制器</strong>三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p>Model: 存储实体类。完成具体的业务操作，如：查询数据库，封装对象</p><p>View：页面展示（视图模式）。JSP、HTML等数据展示，用户可以看到的</p><p>Controller：页面逻辑处理，与用户监控。获取View的请求，调用模型将数据交给视图</p><p>流程：浏览器输入url后，就是发送请求到对象服务器，服务器根据url找到controller，控制器根据业务的逻辑从model获取数据，再把数据给特定的view，view就是客户看的到的结果</p><h2 id="为什么要使用MVC"><a href="#为什么要使用MVC" class="headerlink" title="为什么要使用MVC"></a>为什么要使用MVC</h2><p>可以使同一个程序使用不同的表现形式，若控制器反馈给模型的数据发生了变化，模型也要发生变化</p><p>因模型独立于视图，所以模型可以复用，模型可以独立的移植到别的地方使用</p><p>前后端代码分离，让项目开发的分工更加明确，提高了开发效率</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>一种基于java实现MVC设计模型的请求驱动类型的轻量级web框架。将负载的应用程序系统按照分层处理进行设计和规划，以降低开发难度，提供代码的可维护性。比其他的MVC框架更具有灵活性和拓展性</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/2022/05/09/springmvc-1/springmvcP.png" alt="springmvc"></p><p>框架主要就是围绕中央控制器dispatcherServlet展开</p><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p>前端控制器(dispatcherServlet)：接收请求，响应结果，将各个组件连通</p><p>处理器映射器：根据用户请求的URL找到对应的Handler</p><p>处理器适配器：按照HandlerAdapter的规则去编写，适配器才可以正确执行Handler</p><p>处理器：controller</p><p>视图解析器：视图的解析，根据视图逻辑名解析成真正的视图</p><p>视图：一个接口，支持不同的视图类型</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以支持各种视图技术，不局限于JSP</p><p>与spring框架继承</p><p>清晰的功能分配：前端控制器、请求到处理器映射、处理器适配器、视图解析器</p><p>支持各种请求资源的映射策略</p><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="建立Map-lt-urls-controller-gt-的关系"><a href="#建立Map-lt-urls-controller-gt-的关系" class="headerlink" title="建立Map&lt;urls,controller&gt;的关系"></a>建立Map&lt;urls,controller&gt;的关系</h3><p>入口类就是ApplicationObjectSupport的setApplicationContext方法，核心就是initApplicationContext</p><p><img src="/2022/05/09/springmvc-1/set.png" alt="image-20220509135611735"></p><p>AbstractDetectingUrlHandlerMapping实现了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException &#123;</span><br><span class="line">        <span class="built_in">super</span>.initApplicationContext();</span><br><span class="line">        detectHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">　　  * 建立当前ApplicationContext中的所有controller和url的对应关系</span></span><br><span class="line"><span class="comment">　　　 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">         <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">　　　　 <span class="comment">// 获取ApplicationContext容器中所有bean的Name</span></span><br><span class="line">       String[] beanNames = <span class="built_in">this</span>.detectHandlersInAncestorContexts?</span><br><span class="line">           BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class):</span><br><span class="line">           applicationContext.getBeanNamesForType(Object.class);</span><br><span class="line"> String[] var3 = beanNames;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> beanNames.length;</span><br><span class="line">        <span class="comment">// 遍历beanNames,并找到这些bean对应的url</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">             <span class="comment">// 找bean上的所有url(controller上的url+方法上的url),该方法由对应的子类实现</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">            String[] urls = <span class="built_in">this</span>.determineUrlsForHandler(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">                  <span class="comment">// 保存urls和beanName的对应关系,put it to Map&lt;urls,beanName&gt;,该方法在父类AbstractUrlHandlerMapping中实现</span></span><br><span class="line">                <span class="built_in">this</span>.registerHandler(urls, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled() &amp;&amp; !<span class="built_in">this</span>.getHandlerMap().isEmpty() || <span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.getHandlerMap().size() + <span class="string">&quot; mappings in &quot;</span> + <span class="built_in">this</span>.formatMappingName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           </span><br><span class="line">    <span class="comment">/** 获取controller中所有方法的url,由子类实现,典型的模板模式 **/</span></span><br><span class="line">　　<span class="keyword">protected</span> <span class="keyword">abstract</span> String[] determineUrlsForHandler(String var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后的determineUrlsForHandler是获取每个controller的url，不同子类不同的实现。此处分析BeanNameUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的url</span></span><br><span class="line"><span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">    <span class="comment">//用来保存url的容器</span></span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//判断beanName哪些是以&quot;/&quot;开头</span></span><br><span class="line">    <span class="keyword">if</span> (beanName.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        urls.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliases = <span class="built_in">this</span>.obtainApplicationContext().getAliases(beanName);</span><br><span class="line">    String[] var4 = aliases;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> aliases.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">        <span class="keyword">if</span> (alias.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            urls.add(alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br></pre></td></tr></table></figure><p>AbstractUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPaths, <span class="string">&quot;URL path array must not be null&quot;</span>);</span><br><span class="line">    String[] var3 = urlPaths;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> urlPaths.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">        <span class="built_in">this</span>.registerHandler((String)urlPath, (Object)beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPath, <span class="string">&quot;URL path must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(handler, <span class="string">&quot;Handler object must not be null&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedHandler</span> <span class="operator">=</span> handler;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">//将handler转为beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String)handler;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">            <span class="comment">//根据beanName获取bean，一对一对应到controller类</span></span><br><span class="line">            resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot map &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler) + <span class="string">&quot; to URL path [&quot;</span> + urlPath + <span class="string">&quot;]: There is already &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(mappedHandler) + <span class="string">&quot; mapped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Root mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setRootHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Default mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setDefaultHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//最终将结果put到map集合中，建立一一对应的关系</span></span><br><span class="line">        <span class="built_in">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Mapped [&quot;</span> + urlPath + <span class="string">&quot;] onto &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据url找到controller里处理请求方法"><a href="#根据url找到controller里处理请求方法" class="headerlink" title="根据url找到controller里处理请求方法"></a>根据url找到controller里处理请求方法</h3><p>因为找请求方法，所以看dispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//异步处理</span></span><br><span class="line">        <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//定义空的ModelAndView变量</span></span><br><span class="line">                <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//检查是否是文件上传的请求</span></span><br><span class="line">                    processedRequest = <span class="built_in">this</span>.checkMultipart(request);</span><br><span class="line">                    multipartRequestParsed = processedRequest != request;</span><br><span class="line">                    <span class="comment">//取得处理当前请求的controller（handler处理器），返回HandlerExecutionChain对象</span></span><br><span class="line">                    mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">                    <span class="comment">//handler不能为空</span></span><br><span class="line">                    <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//不同的controller类型交给不同的适配器</span></span><br><span class="line">                    <span class="comment">//若是bean，mappedHandler.getHandler()返回的对象</span></span><br><span class="line">                    <span class="comment">//若是method，返回的就是一个方法</span></span><br><span class="line">                    <span class="comment">//获取的就是handlerAdapter，方便后续找到对应的controller</span></span><br><span class="line">                    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">                    <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                        <span class="comment">//处理last-modified请求头</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">  <span class="comment">//拦截器预处理</span></span><br><span class="line">                    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">       <span class="comment">//通过适配器，处理请求</span></span><br><span class="line">  <span class="comment">//实际的处理器处理请求，返回结果视图对象</span></span><br><span class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">   <span class="comment">//结果视图对象处理</span></span><br><span class="line">                    <span class="built_in">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                    <span class="comment">//拦截器后置处理</span></span><br><span class="line">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">                    <span class="comment">//后面就是各种报错的判断反馈处理</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                    dispatchException = var20;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, var21);</span><br><span class="line">                <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, var23));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                <span class="built_in">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="与Struts2的区别"><a href="#与Struts2的区别" class="headerlink" title="与Struts2的区别"></a>与Struts2的区别</h2><table><thead><tr><th align="center">Struts2</th><th align="center">SpringMVC</th></tr></thead><tbody><tr><td align="center">filter为入口</td><td align="center">前端控制为入口</td></tr><tr><td align="center">基于类开发，传递参数通过类的属性，只能设置多例</td><td align="center">基于方法开发（一个url一个方法），请求参数传递到方法形参，可单例可多例</td></tr><tr><td align="center">值栈存储请求和响应的数据，OGNL存取数据</td><td align="center">通过参数解析器将request请求内容解析，给方法形参赋值，将数据视图封装成ModelAndView</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础</title>
      <link href="/2022/05/08/spring-1/"/>
      <url>/2022/05/08/spring-1/</url>
      
        <content type="html"><![CDATA[<h1 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h1><p><img src="/2022/05/08/spring-1/spring-model.png" alt="主要模块"></p><p>主要被分成：数据访问&#x2F;继承、web、AOP（面向切面编程）、工具、消息、测试</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>创建方式：构造器创建Bean<bean>标签、Setter方法、静态工厂方法创建bean、实例工厂方法创建bean</bean></p><p>获取bean：在初始化的时候保存ApplicationContext对象、通过Spring提供的工具类获取ApplicationContext对象、实现ApplicationContextAware接口、继承自抽象类ApplicationObjectSupport</p><p>配置Bean方式：基于XML配置、基于注解的配置、基于java的配置</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>默认下，spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例；所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为singleton，是所有bean的默认作用域</p><table><thead><tr><th align="center">类别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">在SpringIoc容器中仅存在一个bean实例,bean以单实例方式存在</td></tr><tr><td align="center">prototype</td><td align="center">每次调用getbean() 都将返回一个新的实例</td></tr><tr><td align="center">request</td><td align="center">每次Http请求都会创建一个新的bean,该作用域仅适合于WebApplicationContext 环境</td></tr><tr><td align="center">session</td><td align="center">同一个Http Session 共享一个bean,不同的Http Session使用不同的bean.该作用域仅适合 WebApplicationContext 环境</td></tr></tbody></table><p>singleton 默认值 当Ioc容器一创建就会创建bean实例,而且是单例的,每次得到的都是同一个<br>prototype 原型的 当Ioc容器一创建不实例化该bean,每次调用getBean() 方法时再实例化该bean,而且每次调用都是不同的bean实例<br>request 每次请求实例化一个bean<br>session 在一次会话中共享一个bean</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="创建前准备"><a href="#创建前准备" class="headerlink" title="创建前准备"></a>创建前准备</h3><p>​bean在开始加载之前，从上下文和配置中解析并查找bean有关的一些扩展实现。比如：init-method：容器在初始化时调用的；destroy-method：容器在销毁bean的时候会调用；BeanFactoryPostProcessor：加载过程中的前置、后置的一些处理拓展实现。</p><p>​这些类或配置时提供给开发者去实现bean加载过程中的拓展，在很多与spring集成的中间件常见。比如：Dubbo</p><h3 id="创建实例化"><a href="#创建实例化" class="headerlink" title="创建实例化"></a>创建实例化</h3><p>​通过反射去创建bean的实例对象，并且扫描和解析bean声明的一些属性</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>​若被实例化的bean存在依赖其他bean对象的一些情况，则需要对这些依赖的bean进行对象注入。比如：@Autowired、@Setter这样的配置形式。</p><p>​还会触发一些拓展的调用。比如：BeanPostProcessors：去实现bean初始化前后的拓展回调；</p><h3 id="容器缓存"><a href="#容器缓存" class="headerlink" title="容器缓存"></a>容器缓存</h3><p>​把bean缓存到容器里面以及spring的缓存中；这个阶段的bean就能被开发者拿去用。</p><h3 id="销毁实例"><a href="#销毁实例" class="headerlink" title="销毁实例"></a>销毁实例</h3><p>​当spring的应用上下文被关闭的时候，上下文中所有的bean会被销毁。若bean实现了诸如DisposableBean接口或者配置了destory-method属性的一些方法会在该阶段调用</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p> 一种设计思想，控制反转，<em><strong>将设计好的对象交给容器控制</strong></em>。在调用某个类时，容器会实例化，即容器控制对象的创建。</p><p>  IOC容器实例化过程中，一般不包含bean的依赖注入，bean的注册和依赖注入是两个过程，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xml中配置，在容器初始化的时候，这个bean就完成了初始化。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程基于IOC。简单说就是将部分重复的代码抽取出来，需要执行的时候用动态代理价技术。不修改代码进行功能增强。</p><p> 降低了耦合度，提高了程序的可重用性，同时提高了开发效率，实现业务和切入类的解耦</p><p>底层使用动态代理</p><p>与OOP相比，一个是横向一个纵向在</p><h1 id="涉及到的设计模式"><a href="#涉及到的设计模式" class="headerlink" title="涉及到的设计模式"></a>涉及到的设计模式</h1><p>IOC：工厂模式，单例模式，装饰器模式</p><p>AOP：代理模式，观察者模式（监听）</p><p>MVC:委派模式，适配者模式</p><p>JDBC：模板方法模式（RestTemplate）</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>有了IOC容器，对象间的依赖关系交给了spring，更专注业务逻辑代码</p><p>有AOP和OOP，很多功能更方便简单使用</p><p>简化开发</p><p>方便测试</p><p>声明式事务管理</p><p>减低API开发难度</p><p>低耦合</p><p>方便集成其他框架</p><h1 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h1><p>spring里面的核心功能是IOC容器，本质就是bean的容器、工厂，能去根据XML中声明的bean的配置去进行加载和初始化，然后beanFactory去生成我们所需要的各种各样的一个bean。</p><p>BeanFacory：是所有Spring Bean容器的顶级接口，为Spring的容器定义了一套规范，并提供像getBean等方法从容器中获取指定的Bean的实例；在产生bean的同时，提供解决bean之间依赖注入的能力；</p><p>FactoryBean：是一个工厂bean，接口，主要功能是去动态生成某一类型的bean的一个实例，即可以自定义一个bean并加载到IOC容器里，里面有个方法getObject就是实现动态构建bean的一个过程。OpenFeign组件客户端代理就是使用了FactoryBean实现</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2022/05/07/ThreadLocal-1/"/>
      <url>/2022/05/07/ThreadLocal-1/</url>
      
        <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/05/07/ThreadLocal-1/first.png" alt="结构"></p><p>线程本地存储机制，数据缓存到线程内部</p><p>当thread销毁时，threadLocal也会随之销毁，减少内存的使用</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>Synchronized用于线程间的数据共享，ThreadLocal用于<em><strong>数据隔离</strong></em>，最适合多实例的对象的访问。</p><p>保存该线程变量，这样每个线程都有自己的数据，就做到了不同线程间数据的隔离。即多线程环境下，对于共享变量访问的安全性。</p><p>为每个使用该变量的线程提供独立的变量副本，所以<em><strong>每个线程都可独立改变自己副本</strong></em>，而不影响其他线程对应的副本，从而没必要对该变量进行同步了。</p><p>  提供了线程安全的共享对象，在多线程中，可把不安全的变量封装进ThreadLocal</p><p>创建一个TheadLocal变量，那么访问这个变量的每个线程都会有这个线程的本地副本。</p><p><em><strong>解决了线程安全问题，避免了多线程竞争锁的开销</strong></em></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>连接ThreadLocalMap和Thread，来处理Thread的ThreadLocalMap属性</p><p>  ThreadLocalMap用来存储数据，类似于hashmap，存储ThreadLocal为key，需要隔 离的数据为value的Entry键值对数据结构。可以理解：ThreadLocal只是ThreadLocalMap封装，传递了变量值。ThreadLocalMap&lt;ThreadLocal,数据&gt;</p><p>  ThreadLocalMap是ThreadLocal内部类，由ThreadLocal创建，ThreadLocal本身就是一个代理工具</p><p>  每个thread对象都会存一个theadLocalMap</p><p>  这样不容易产生内存泄露</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//   获取当前线程对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//再获取该线程下的threadlocalmap对象map</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)<span class="comment">//  Map若存在，则将参数设置到Map中</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);<span class="comment">// 否则就创建map（createMap(Thread t,T value)）并设置初始值</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//首先获取线程</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//根据线程获取map；</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">// 若map不为空，则在map下以threadlocal的引用作为key来在map中获取对应的entry e；</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;<span class="comment">//若e不为mull，则返回e.value；</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();<span class="comment">//Map为空或e为空，则initialValue函数获取初始值value，用threadlocal的引用和value作为键和值创建一个新map</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());<span class="comment">//获取当前线程，根据线程获取一个map；</span></span><br><span class="line">         <span class="keyword">if</span> (m != <span class="literal">null</span>)<span class="comment">//若map部位空则移除当前threadlocal对象对应的entry</span></span><br><span class="line">             m.remove(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="InitialValue"><a href="#InitialValue" class="headerlink" title="InitialValue"></a>InitialValue</h2><p>默认就返回null。延迟方法可重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">      SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">          <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> supplier.get();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>ThreadLocal没有被外部强引用的情况下，垃圾回收时key就会被清理，value不会，因为前者为弱引用，后者为强引用。</p><p>在线程池中使用ThreadLocal可能内存泄露：在线程池中线程的存活时间太长，往往都是和程序同生共死，这样thread持有的ThreadLocalMap一直不会被回收，又因为是弱引用，所以ThreadLocal结束生命就可以被回收。而Entry中的value被Entry强引用，所以机制value生命周期结束，也不会被回收，导致内存泄露</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>每一个线程分配一个和JDBC连接Connection，保证每个线程的都在各自的Coonection上进行数据库的操作</p><p><em><strong>变量在线程内部共享，线程间无关</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TheadLocal </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="/2022/05/06/redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/06/redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="redis的基本性质"><a href="#redis的基本性质" class="headerlink" title="redis的基本性质"></a>redis的基本性质</h1><p>redis是<em><strong>完全基于内存</strong></em>，绝大部分请求是都是纯粹的内存操作</p><p>基于Reactor模式开发的网络处理器单多线程</p><p>6.0以前是单线程，利用队列技术将并发访问变为了串行访问，消除了传统数据库串行控制的开销</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>支持数据持久化，可以将内存的数据保存在磁盘中，重启的时候可以再次舒勇</p><p>提供各种数据结构进行存储</p><p>支持数据的备份</p><p>高性能、高并发，所以可以作为缓存</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>五种基础：</p><p>String：最基本的，动态字符串，存数字时底层是int；长字符串（长度&gt;39字节）raw；短字符串（长度&lt;39字节）embstr</p><p>利用key的生命周期做投票系统；String特点数据刷新；利用数值操作特征为分布式数据库自增。访问次数、点赞、转发量</p><hr><p>Hash：是一个键值对集合，是一个String类型的key和value的映射表。相当于hashmap。存放对象类型的数据，可避免键名冲突。 用户的购物车；hash作为商品秒杀技术对象完成商品秒杀系统</p><p>底层：ziplist（元素数量&lt;512，所有元素长度&lt;64字节）和哈希表。</p><hr><p>List：简单的字符串列表，底层是顺序的双向链表和ziplist（元素数量&lt;512，所有对象元素长度小于64字节）。可用于消息队列；顺序特性实现朋友圈点赞；顺序特性进行分布式日志顺序性展示</p><hr><p>Set:String类型的无序集合，底层哈希表和inset（所有元素是整数，元素数量小于512）</p><p>比如标签；黑白名单；获取所有业务的权限</p><hr><p>Zset（SortedSet）：ziplist（元素数量小于128，所有元素长度&lt;64）和跳表结合，value保证唯一性，又可为每个value代表权重的值。排行榜系统；带权重任务队列；根据权重进行排序</p><p>三种高级：</p><p>Bitmaps:String类型上的一组面向bit操作的集合，不是真的数据结构，优点就是存储信息可节省大量空间。一般用于实时分析，存储对象ID关联的节省空间且高性能的布尔信息。底层是String</p><hr><p>HyperLogLogs：用于计算唯一事物的概率数据结构。可用于计算用户每天在搜索框中执行唯一的搜索。底层是String</p><hr><p>GEO：存储用户给定的地理位置信息，并对这些信息操作。底层是zset</p><hr><p>Streams：内存版的kafka</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>速度快，支持丰富数据类型，支持事务、<em><strong>指令操作</strong></em>都是原子性的</p><p>容量收到物理内存限制，只适合较小数据量的高性能操作和运算上；</p><p>难在线扩容，在集群容量达到上限时在线扩容很复杂，所以运维人员在保证足够的空间</p><h1 id="redis6-0以后为什么引入多线程？"><a href="#redis6-0以后为什么引入多线程？" class="headerlink" title="redis6.0以后为什么引入多线程？"></a>redis6.0以后为什么引入多线程？</h1><p>多线程的情况下，线程切换换消耗CPU，<em><strong>CPU并不是redis的瓶颈</strong></em>。</p><p>引入多线程<em><strong>主要是为了提高网络IO读写性能</strong></em>：多线程只是在网络数据的读写这类耗时操作上使用，而执行命令仍是单线程顺序执行</p><p>redis将所有数据放在了内存中，对于小数据包，redis服务器已经处理80000到100000QPS，已经是极限，对大部分公司已经够用了</p><p>从redis自身角度，因为读写网络read&#x2F;write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p><ul><li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</li><li>使用多线程充分利用多核，典型的实现比如 Memcached</li></ul><p>小总结：</p><p>​可以充分利用服务器CPU资源，目前主线程只有一个核</p><p>​多线程可以分摊redis同步IO读写消耗</p><h1 id="redis6-0关于多线程"><a href="#redis6-0关于多线程" class="headerlink" title="redis6.0关于多线程"></a>redis6.0关于多线程</h1><p><em><strong>多线程默认是禁用的，只使用主线程</strong></em>。所以需要修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>仅仅是开启多线程是不生效，修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核使用2/3个线程，8核使设置6个线程</span></span><br></pre></td></tr></table></figure><p>实现机制：</p><p>​主线程负责接收建立连接请求，获取socket放入全局等待处理读处理队列</p><p>​主线程处理完读时间后，通过RR（Round Robin）将这些连接分配给这些IO线程</p><p>​主线程阻塞等待IO线程读取socket完毕</p><p>​主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但不执行</p><p>​主线程阻塞等待IO线程将数据收回，写socket完毕</p><p>​解除绑定，清空等待队列</p><h1 id="开启多线程后，是否有线程并发安全问题"><a href="#开启多线程后，是否有线程并发安全问题" class="headerlink" title="开启多线程后，是否有线程并发安全问题"></a>开启多线程后，是否有线程并发安全问题</h1><p>Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p><h1 id="redis经常提到IO多路复用，怎么理解？"><a href="#redis经常提到IO多路复用，怎么理解？" class="headerlink" title="redis经常提到IO多路复用，怎么理解？"></a>redis经常提到IO多路复用，怎么理解？</h1><p>这是IO模型的一种，即经典的Reactor设计模式，有时也称为异步阻塞IO。</p><p>多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>[Redis 6.0 新特性-多线程连环13问！](<a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis 6.0 新特性-多线程连环13问！ (qq.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis内存淘汰</title>
      <link href="/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
      <url>/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内存淘汰： 当内存的使用率到达了maxMemory的上限的时候，进行内存的释放。</p><p>redis提供了许多内存淘汰算法，主要分为4种：</p><p>​随机：随机移除某个key</p><p>​TTL算法：，在设置了过期时间的键里面去找更早过期时间的key进行有限的移除</p><p>​LRU算法：去移除最近很少使用的key。</p><p>​LFU算法：与LRU算法类似                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h1 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h1><p>​LRU算法会维护一个大小为16的侯选池，里面的数据会随着时间排序，每一次随机抽取5个key放入侯选池，当侯选池满了后，访问的时间间隔最大的key就从侯选池里面取出来并淘汰。这样就可以把真实的最少访问的key从内存里面淘汰。</p><p>​存在问题：若一个key很长时间没有访问，突然偶尔被访问，那LRU就会认为这是一个热点key就不会被淘汰。</p><h1 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h1><p>​相比于LRU算法，LFU增加了访问频率来统计数据的热点情况。</p><p>​主要设置是使用了两个双向链表形成了一个二维的双向链表，一个链表来保存访问频率，另一个保存访问频率相同的所有元素。当添加元素的时候，访问频次默认为1，找到相同频次的节点，然后添加到相同的频率节点对应的双向链表的头部，当元素被访问的时候，就增加对应key的访问频率，并把当前访问的节点移动到下一个频次的节点。</p><p>​可能出现某个数据前期的访问次数很多，但后续不再使用。若单纯按照这样的一个访问频次来进行淘汰的话，那这个key就很难被淘汰掉。该算法通过使用频率和上次访问的时间来标记数据的热度。若某个数据有读和写，那增加访问的频率；若一段时间内该数据没有读写，那就减少访问频率。</p><p>​经过LFU算法改进后就可以实现真正达到非热点数据的淘汰</p><p>​缺点：与LRU相比，增加了访问频次的维护以及实现的复杂度要比LRU更高</p><h1 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h1><p>定时策略：创建一个定时器，过期时间到，逻辑对键的删除</p><p>​对内存友好而CPU时间不好，redis还没有使用</p><p>惰性删除：过期键不管，每次从键空间获取键的时候，该键过期了删了，没过期就返回该键</p><p>​对内存不友好而CPU时间友好</p><p>定期删除：每隔一段时间就检查，删除过期键，由算法决定</p><p>​较为折中</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis和数据库的数据一致性</title>
      <link href="/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>redis用来实现应用和数据库之间读操作的缓存层，主要目的是去减少数据库的IO，并提升数据库的IO性能。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>当应用程序需要读取某个数据的时候，首先会尝试去redis里面加载，若命中就直接返回，反之就去数据库里面查询，查询到数据后再把数据缓存到redis里面。</p><h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>即一份数据同时保存在redis和数据库里面，当数据发生变化的时候需要同时更新数据库和redis，由于更新操作具有先后顺序且redis不像数据库中的多表事务操作（满足ACID的特性），所以会出现数据一致性的问题</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h2><p>此情况下，若缓存更新失败，就会导致数据库和redis的数据不一样。</p><p>线程1连接到数据库，读取到了数据A，此时线程1停顿，线程2连接到数据库将数据A更改为数据B，并将B写入了redis完成了线程2的操作，然后线程1将读取到的数据A写入redis即把B覆盖。此时，数据库里面的数据为B，而redis里的数据为A</p><h2 id="先删除缓存后更新数据库"><a href="#先删除缓存后更新数据库" class="headerlink" title="先删除缓存后更新数据库"></a>先删除缓存后更新数据库</h2><p>理想情况下是应用下次访问redis的时候，发现redis里面是空值，就会从数据库里加载并保存至数据库，理论上可行。但在极端情况下，由于删除redis和更新数据库的两个操作均不是原子操作，所以还是会出现数据不一致</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>基于RocketMQ的可靠性消息通信实现数据的最终一致性</p><p>通过Canal组件监控数据库里面的binlog的日志，把更新后的数据同步到redis里面</p><p>采用延时双删的原则：先淘汰缓存，再写数据库，休眠一会儿后再淘汰缓存。因为存在了延时时间，目的就是为了先把查到的数据写入redis再删redis</p><h1 id="redis的线程安全问题"><a href="#redis的线程安全问题" class="headerlink" title="redis的线程安全问题"></a>redis的线程安全问题</h1><h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h2><p>是一个线程安全的K-V数据库，即在redis-server端去执行指令的时候不要任何的同步机制，不存在任何线程安全的问题，虽然6.0之后增加了多线程的模型，但该模型只是去处理网络的IO事件，对于指令的执行还是采用主线程来处理的，所以并不会存在多个线程同时去执行操作指令的情况。</p><p>没有采用多线程执行指令：</p><p>​本身可能出现的性能瓶颈点无非是网络IO、CPU、内存，但是CPU不是redis的瓶颈，所以就没必要采用多线程执行指令</p><p>​若采用多线程，那么所有指令就必须要考虑线程安全的问题，也就需要加锁来解决，这种方式反而会对性能造成更大的影响</p><h2 id="redis-client"><a href="#redis-client" class="headerlink" title="redis-client"></a>redis-client</h2><p>里面的指令操作都是原子性，但若有多个redis客户端同时执行多个指令就无法保证原子性。</p><p>比如：两个client同时去获取server上的key1，同时去修改和写入，因为多线程下原子性不能保证以及多进程的情况下共享资源访问的竞争问题也不能保证数据安全性</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>尽可能使用redis里面的原子指令</p><p>对个客户端的资源访问加锁</p><p>通过lua脚本实现多个指令的操作，去满足原子性</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis理解和分布式锁</title>
      <link href="/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="对redis的理解"><a href="#对redis的理解" class="headerlink" title="对redis的理解"></a>对redis的理解</h1><p>redis是一个高性能的基于Key-Value结构存储的NoSQL开源数据库，绝大部分都采用redis实现分布式缓存，从而去提高数据的的检索效率。</p><p>redis流行的原因：</p><p>​1 基于内存存储，在进行数据IO操作的时候能达到很高的QPS（官方给的10w）</p><p>​2 提供了非常丰富的数据存储结构，比如String、list、hash、set、zset</p><p>​3 底层采用单线程实现数据的IO，所以在数据算法层面不需要考虑并发安全性，从而让底层算法的时间复杂度基本都是常量复杂度</p><p>​4 虽然是内存存储，但却可以支持持久化，避免因服务器故障而导致的数据丢失问题</p><p>综上，redis一般是用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响，redis还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供了解决方案</p><h1 id="实现分布式锁中-zookeeper和redis的比较"><a href="#实现分布式锁中-zookeeper和redis的比较" class="headerlink" title="实现分布式锁中 zookeeper和redis的比较"></a>实现分布式锁中 zookeeper和redis的比较</h1><p>分布式锁：核心目的是为了解决在同一个时刻有多个进程或线程来访问共享资源所带来的安全性问题。锁又分为共享锁（在同一个时刻允许多个线程或进程访问共享资源，适用于幂等性场景，从而避免重复加锁的性能开销）和排它锁（同一个时刻只允许一个线程或进程访问该共享资源，适用于非幂等性场景）</p><p>实现分布式锁的最常用中间件就是zookeeper和redis</p><p>redis实现分布式锁方式：</p><p>​1 基于redis本身提供的指令：SET key value NX PX millisecounds。设置key的时候，若key已经存在与服务器上了会返回一个0，表示无法设置，否则就返回1表示设置成功。程序就根据0和1判断状态，从而表示去获得锁</p><p>​2 基于redission客户端实现，redission提供了分布式锁的封装方法，只需要调用封装好的api，<em><strong>lock()</strong></em> 和 ***unlock()***方法，就可以实现锁的抢占和释放。redission的所有指令都是通过lua脚本去实现，该脚本可以保证所有执行指令的原则性。另外，redission提供了一个watchdog，它会在我们获取锁后每隔10s去把key的时间延长，就避免锁的过期。</p><p>redis的缺点：</p><p>​在获得锁的时候，很简单，若获取不到锁就一直去尝试获取，会影响程序性能</p><p>​是一个&#x3D;&#x3D;AP模型&#x3D;&#x3D;，也就是可用性模型，集群模式中，存在数据一致性，会导致锁出现问题。即使使用了redlock算法实现分布式锁，但在某些复杂的场景下也不能保证锁的一定可用</p><p>zookeeper实现分布式锁：</p><p>​1 有序节点实现：每个线程或进程都到zookeeper上的<em><strong>lock</strong></em>目录下去创建一个临时有序节点，去表示抢占锁，所有创建的节点都会按照先后顺序生成带有有序编号的节点，线程创建节点后获取<em><strong>lock</strong></em>节点下的所有子节点，判断当前线程创建的节点是否是所有子节点里序号最小的，若是就获取锁成功。反之就需要对当前线程的前一个节点建立事件监听，当被监听的节点释放后，则触发回调告诉当前线程从而再次去尝试抢占锁</p><p> 使用redis还是比较常见，因为实际开发中极端情况少，redis本身的性能又高，在高并发中比较合适。</p><p>zookeeper是一个分布的协调组件，是&#x3D;&#x3D;一个CP模型&#x3D;&#x3D;所以更适合实现分布式锁。当获取不到锁就添加监听器，不用一直获取，就减少了性能。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java不可变类</title>
      <link href="/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/"/>
      <url>/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p><strong>不可变类</strong>：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p><p><strong>可变类</strong>：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><h1 id="不可变类优点"><a href="#不可变类优点" class="headerlink" title="不可变类优点"></a>不可变类优点</h1><p>主要有两点，效率和安全</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>当一个对象是不可变的，那么需要拷贝这个对象的内容时，就不用复制它的本身而只是复制它的地址，复制地址（通常一个指针的大小）只需要很小的内存空间，具有非常高的效率。同时，对于引用该对象的其他变量也不会造成影响。而且保证了hashCode 的唯一性，因此可以放心地进行缓存而不必每次重新计算新的哈希码。而哈希码被频繁地使用, 比如在hashMap 等容器中。将hashCode 缓存可以提高以不变类实例为key的容器的性能。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>是指线程安全</p><p>在多线程情况下，一个可变对象的值很可能被其他进程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况同时省去了同步加锁等过程，因此不可变类是线程安全的。</p><p>当然，不可变类也有缺点：不可变类的&#x3D;&#x3D;每一次“改变”都会产生新的对象，因此在使用中不可避免的会产生很多垃圾&#x3D;&#x3D;</p><h1 id="不可变类的设计"><a href="#不可变类的设计" class="headerlink" title="不可变类的设计"></a>不可变类的设计</h1><p>类使用final修饰，保证类不被继承</p><p>所有成员变量都被private和final修饰</p><p>不提供成员变量的setter方法</p><p>通过构造器初始化所有成员，进行深拷贝</p><p>在getter方法中，不直接返回对象本身，而是克隆对象并返回对象的拷贝内容</p><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>String源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="type">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="type">char</span> result[] = <span class="keyword">new</span> <span class="title class_">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可观察到</p><p>​String类被final修饰，就不能被继承</p><p>​内部变量所有成员都设置为私有变量</p><p>​没有setter方法</p><p>​&#x3D;&#x3D;传入可变数组时，进行copy而不是直接将数组赋值给内部变量&#x3D;&#x3D;</p><p>​获取value时不是直接返回对象引用，而是返回对象的copy</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​String不能被修改，让JVM可实现字符串常量池，该常量池可在运行时节约内存空间，不同字符串指向相同自变量时都指向字符串常量池中的同一对象，&#x3D;&#x3D;即提升了性能，节约了资源&#x3D;&#x3D;，更因为不可变性保证了线程安全</p><h2 id="String是否真的不可变"><a href="#String是否真的不可变" class="headerlink" title="String是否真的不可变"></a>String是否真的不可变</h2><p>虽然String对象将value设置为final,并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">char</span>[] valueCharArr = (<span class="type">char</span>[]) valueField.get(str);</span><br><span class="line">            valueCharArr[<span class="number">0</span>] = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">            valueField.set(str, <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = ABCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = GBCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = 12</span><br><span class="line">hashCode = 2001986</span><br></pre></td></tr></table></figure><p>由打印结果可知，字符串str的值发生了改变，哈希值没有发生变化。即通过反射可以修改“不可变”对象</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不可变类是实例创建后就不可以改变成员遍历的值。这种特性使得不可变类提供了线程安全的特性但同时也带来了对象创建的开销，每更改一个属性都是重新创建一个新的对象。JDK内部也提供了很多不可变类如Integer、Double、String等。</p><p>String的不可变特性主要为了满足<em><strong>常量池的使用</strong></em>、<em><strong>线程安全</strong></em>、<em><strong>类加载</strong></em>、<em><strong>提高运行速度</strong></em>、<em><strong>避免网络问题</strong></em>。合理使用不可变类可以带来极大的好处。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不可变类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
