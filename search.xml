<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO</title>
      <link href="/2022/05/22/IO/"/>
      <url>/2022/05/22/IO/</url>
      
        <content type="html"><![CDATA[<h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><h3 id="阻塞式I-x2F-O"><a href="#阻塞式I-x2F-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h3><p>用户线程发出IO请求后，内核会查看数据是否就绪，若没有就绪，就会等待数据就绪，而一直处于阻塞状态并交出CPU资源</p><h3 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h3><p>用户线程发出一个请求后会立刻得到一个结果，若结果是error就再次发起请求，直到得到结果。在此期间会一直占用CPU，因为会一直询问内核数据是否就绪</p><h3 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h3><p>一种机制</p><p>用的较多，NIO就是</p><p>总有一个线程轮询多个socket状态，只有当真正有读写事件时，才真正调用实际的IO读写操作。因为只需要一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不用维护这些，只有真的socket读写事件进行时才使用IO资源。</p><p>该模型用到了select、poll函数，两个函数可以同时阻塞多个I&#x2F;O操作</p><p>函数方法</p><p>selsect：监视的文件描述符分三类，调用select函数会阻塞，直到描述符就绪或超时</p><p>​         缺陷：单线程打开的FD有限制；对socket进行线性扫描（轮询）IO，效率低；限定大小，因为保存文件描述符的bitmaps是1024</p><p>​         阻塞函数，没数据阻塞</p><p>​        一开始是收集文件描述符给内核看哪儿有数据（提高了效率，不然用户态判断会因为切换而浪费资源），有数据的话，FD置位，select函数返回，后面就遍历FD，判断哪个置位并读出数据再处理</p><p>poll：本质与select无区别；将用户给的数组拷贝进内核，查询每个fd对应设备的状态</p><p>若遍历fd都没有就绪设备就挂起当前线程，直到设备就绪或主动超时，被唤醒后再次遍历fd</p><p>​             没有最大连接次数（因为恢复revents）；大量fd数组复制进内核（有些无意义）；若报告的fd没处理，那下次poll会再次报告fd</p><p>​           有超时时间，5个FD拷贝到内核态并监听数据</p><p>​           有数据时内核会对revents字段置位，poll返回，遍历找置位读数据</p><p>Epoll：没有描述符的限制；可水平触发和边缘触发；</p><p>没有最大并发连接的限制；效率提升，不是轮询方式；内存拷贝</p><p>​             连接数较多且很多的不活跃连接时，epoll效率更好；反之，epoll因需要回调，所以性能此时会低</p><p>​             创建了epfd白板，再epoll_ctr，写了结构体；用户态和内核态共享fd内存（不像上面还需要拷贝）；水平触发：重排置位（有数据的放到前面），返回值为有多少个数据，遍历就遍历前几个，进行处理</p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>用户线程发起IO请求，会给对应的socket注册一个信号函数，线程再继续执行，当用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际IO请求操作</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>用户线程发起请求后，就可做其他事，当接收到数据内核返回的成功信号时，就表示IO操作已经完成，可以直接去使用数据</p><h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p>本身是指数据 从源头到目的地</p><p>其中的输入输出流都是在外部文件和内存之间数据的流通</p><p>分为两种：字符流和字节流。InputStream和OutputStream，Reader，Writer</p><h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>底层设备只接收字节数据，字符流是字节流的包装，字符流则是直接接收字符串，它会在内部转成字节，再写入底层设备</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>同步阻塞，服务器实现模式为一个连接一个线程</p><p>服务端：通过serverSocket注册端口；服务器通过调用accept方法用于监听客户端socket请求；从socket中获取字节输入或者输出进行数据读写</p><p>客户端：通过socket独享请求域服务端的连接；从socket得到字节输入或字节输出流进行数据的读写</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>同步非阻塞式，核心类：</p><p>​                 Buffer（缓冲区）为所有原始类型提供缓存支持，是一个容器，连续的数组 </p><p>​                 Charset字符集编码解决解码方案</p><p>​                 Channel（通道）一个新的原始I&#x2F;O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备、程序或是网络的连接</p><p>数据source：需要读取，使用：InputStream、Reader。对应了 硬盘、内存、键盘（System.in）</p><p>数据destination：就是需要写入，使用OutputStram、Writer对应了 硬盘、内存、控制台（System.out）</p><h3 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h3><p>BIO：同步阻塞式IO，就平常使用的，模式简单使用方便，并发处理能力低</p><p>​    是一个连接一个线程</p><p>​    适用于连接数目较小且固定的架构，对服务器资源要求较高</p><p>NIO：同步非阻塞IO，客户端和服务器端通过Channel通讯，多路复用</p><p>​    一个请求一个线程</p><p>​    适用于连接数目多且连接较短的架构，比如聊天服务器</p><p>AIO：NIO的升级，异步非阻塞IO，异步IO操作基于事件和回调机制</p><p>一个有效请求一个线程</p><p>适用于连接数据木多且连接较长的架构，比如相册服务器</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础-类加载</title>
      <link href="/2022/05/21/JVM-2/"/>
      <url>/2022/05/21/JVM-2/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h1><p>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件结构</p><p>ClassLoader只负责class文件的加载，至于是否可以运行，则由ExecutionEngine决定</p><p>加载的类信息存放于一块称为方法区的内存空间，除了类信息外，方法区还有存放运行时常量池的信息，可能还包含字符串自变量和数字常量</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>​    通过一个类的全限定名获取定义此类的二进制字节流（字节码文件）</p><p>​    将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>​    在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><p>​    补充：加载.class文件的方式</p><p>​         从本地系统中直接加载</p><p>​         通过网络获取，典型场景：web Applet</p><p>​         从zip压缩包中读取，成为日后jar，war格式的基础</p><p>​         运行时计算生成，使用最多的是：动态代理技术</p><p>​         由其他文件生成，典型：JSP应用</p><p>​         从专有数据库中提取.class文件，少见</p><p>​         从加密文件获取，典型：防class文件被反编译的保护措施</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>​    验证：目的确保class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性不会危害虚拟机自身安全</p><p>​          主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</p><p>​    准备：为类变量分配并且设置该类变量的默认初始值，即零值</p><p>此处不包含用修饰的static，因为final在编译时就已经会分配了，准备阶段会显示初始化</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中</p><p>​    解析：将常量池的符号引用（不一定已加在内存）转换为直接引用的过程</p><p>​          解析操作往往会伴随着JVM在执行完初始化之后再执行</p><p>​          符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个简介定位到目标的句柄。</p><p>​          解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    初始化过程就是执行类构造器方法<clinit>过程</clinit></p><p>​    也就是只对static修饰的初始化</p><p>​    该方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来</p><p>​    构造器方法中指令按语句在源文件中出现的顺序执行</p><p>​    <clinit>方法不同于类构造器，jvm会保证子类的<clinit>方法执行之前，父类的<clinit>已经执行完毕</clinit></clinit></clinit></p><p>​    虚拟机必须保证一个类的<clinit>方法在多线程下被同步加锁</clinit></p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器：引导类加载器，自定义加载器</p><p>所有派生于抽象类ClassLoader的类加载器都划分于自定义加载器</p><p>Java核心类库都是引导类加载器加载的</p><h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><p>​    该类由c&#x2F;c++实现，嵌套在JVM内部</p><p>​    用来加载java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path），提供JVM自身需要的类</p><p>​    并不继承java.lang.ClassLoader，没有父加载器</p><p>​    加载拓展类和应用程序类加载器，并指定为他们的父类加载器</p><p>​    为了安全，Bootstrap启动类加载器只加载名为java、javax、sun等开头的类</p><p>拓展类加载器（Extension ClassLoader）</p><p>Java编写，由sun.misc.Launcher$ExtClassLoader实现</p><p>派生于ClassLoader类</p><p>父类加载器为启动类加载器</p><p>​    如果用户创建的JAR放在此目录下，也会自动由拓展类加载器加载</p><p>系统类加载器（应用程序类加载器）</p><p>​    Java编写</p><p>​    父类加载器为拓展类加载器</p><p>​    负责加载环境变量classpath或系统属性，java.class.path指定路径下的类库</p><p>​    该类加载程序中默认的类加载器</p><h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><p>为什么要自定义类加载器</p><p>​    隔离加载类</p><p>​    修改类加载的方式</p><p>​    拓展加载源</p><p>​    防止源码泄露</p><p>实现步骤</p><p>​    通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</p><p>​    JDK1.2之前，在自定义加载类时，总会继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。JDK1.2以后，不再建议用户覆盖loadClass方法，而是建议把自定义的类加载逻辑写在findclass方法中    </p><p>​    若没有复杂需求，可直接继承URLClassLoadr类，这就可避免自己去编写findClass方法及其获取字节码流的方式，使自定义类加载器的简洁</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础-虚拟机栈</title>
      <link href="/2022/05/20/JVM-1/"/>
      <url>/2022/05/20/JVM-1/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h1><img src="/2022/05/20/JVM-1/zucheng.png" alt="组成" style="zoom:150%;"><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>一种快速有效的分配存储方式，<em><strong>访问速度仅次于程序计数器；</strong></em></p><p>线程私有</p><p>  JVM直接对java栈的操作：</p><p>​            每个方法的执行，伴随着进栈（入栈，压栈）</p><p>​            执行结果后的出栈工作</p><p>  不存在垃圾回收的问题</p><p>  栈中的数据都是以栈帧的格式存在，<em><strong>这个线程上正在执行的每个方法都各自对应一个栈帧</strong></em>。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。每一个方法执行结束就对应着一个栈帧从虚拟机栈从入栈到出栈</p><p>栈就只有 压栈 和 出栈</p><p>不同线程中所包含的线帧是不允许相互引用的，即不可能在一个栈帧之中引用另一个线程中的栈帧</p><p>若当前方法调用其他方法，方法返回的时候，当前栈帧会传回此方法的执行结果给前一个栈帧，然后虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p><p>方法的结束方式：正常结束和抛出异常（未被捕获处理）</p><h2 id="栈帧内部结构"><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h2><p><img src="/2022/05/20/JVM-1/zhangzhen.png" alt="zhanzhen"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>  定义为一个数字数组，主要用于<em><strong>存储方法参数和定义在方法体内的局部变量</strong></em></p><p>  因是建立在线程的栈上，是<em><strong>私有</strong></em>的，所以不存在数据安全问题</p><p>  所需的容量的大小是在编译期确定下来的</p><p>  方法嵌套使用的次数由栈的大小决定。越大，次数越多</p><p>  局部变量表中的变量只在当前方法调用中有效。方法调用结束，该表也会随之销毁</p><p>  里面最基本的存储单元Slot（变量槽）：</p><p>​    参数值的存放总是在局部变量数组的index0开始，到数组长度-1结束</p><p>局部变量表最基本的存储单元</p><p>​    局部变量表里，32位以内的类型只占用一个slot，64位占两个</p><p>​    当一个实例方法被调用，它的方法参数和方法体内部定义的局部变量将会按照顺序复制到局部变量表中的每一个slot上</p><p>​    若当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处。</p><p>  Slot重复利用：栈帧中的局部变量表中的槽位是可以重用，为了节省资源。</p><p>  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表直接或间接引用的对象都不会被回收</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>  是一个以字长为单位的数组，但是以后进先出的操作数栈（表达式栈），方法执行过程中，根据字节码指令，进行入栈、出栈操作。</p><p>  进行数据运算的</p><p>  并非采用访问索引的方式来进行数据访问</p><p>  若被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</p><p>Java虚拟机的解释引擎是基于栈（操作数栈）的执行引擎</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>  一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用就是为了支持当前方法的代码能够实现动态连接</p><p>  Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中，动态链接作用就是将这些符号引用转换为调用方法的直接引用</p><p>  常量池：提供一些符号和常量，便于指令的识别</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的PC寄存器的值。（交给执行引擎，让其执行后续操作）</p><p>调用者的PC计数器的值作为返回地址，即调用该方法的指令作为下一条指令的地址</p><p>正常完成与异常完成的区别：异常完成出口退出不会给他上层调用者产生任何的返回值</p><p>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</p><h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>不一定有。比如：对程序调试提供支持的信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/2022/05/19/redis_c/"/>
      <url>/2022/05/19/redis_c/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>持久化就是指redis会把内存中的数据写入到硬盘中，redis重启的时候加载这些数据，就最大限度的降低惠存丢失带来的影响。</p><p><em><strong>因为数据全部在内存，若宕机、进程退出，若没有持久化机制，数据就会全部丢失</strong></em>。有了持久化后，redis在下次重启的时候就会进行数据</p><p>备份的执行过程：redis会单独创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上一次持久化好的文件。整个过程，主进程是不进行任何I&#x2F;O操作，就确保了极高的性能，若要大规模的数据恢复，且对于数据恢复的完整性不是很敏感，那RDB方式要比AOF方式更高效。缺点就是最后一次 持久化后数据可能丢失</p><h1 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h1><h2 id="RDB快照（默认）"><a href="#RDB快照（默认）" class="headerlink" title="RDB快照（默认）"></a>RDB快照（默认）</h2><p>​    将当前redis中的数据<em><strong>生成快照二进制的形式</strong></em>保存到硬盘，保存的文件后缀是rdb；redis重启时可以读取快照文件恢复数据。有手动触发和自动触发两种。记录结果</p><h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>​    创建命令：SAVE和BGSAVE（推荐，因为可在不阻塞服务器进程情况下执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save：会阻塞Redis服务，直到RDB持久化完成，当Rredis里面存储了大量数据的时候，就造成较长时间的阻塞，不建议用</span><br><span class="line">bgsave：一般不会阻塞，进行会执行fork操作创建子进程负责，不会阻塞Redis服务进程。Redis服务的阻塞只发生在fork阶段，一般时间很短</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bgsave的流程：</span><br><span class="line">执行besave命令，Redis进程会判断当前是否存在正在执行的RDB或AOF子线程，若存在就直接结束</span><br><span class="line">Redis进程执行fork操作创建子线程，fork操作过程中redis进程会被阻塞</span><br><span class="line">fork完成后，bgsave就结束了，redis进程就不会被阻塞，其他命令就可以被响应</span><br><span class="line">子进程根据redis进程的内存生成快照文件，并替换原有的RDB文件</span><br><span class="line">子进程通过信号量通知Redis进程已完成</span><br></pre></td></tr></table></figure><h3 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h3><p>在配置文件中设置save的相关配置，如save 5 1，就表示在5s内数据被修改1次时自动触发bgsave操作</p><p>当从节点做全量复制时，主节点会自动执行bgsave操作，并且把生成的RDB文件发送给从节点</p><p>执行 “debug reload”命令时，会触发</p><p>执行“shutdown”，若没有开启AOF持久化也会触发bgsave操作</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：节省磁盘空间，恢复速度快（有向的持久化文件，重启redis，数据就可恢复），方便备份，可最大化redis性能</p><p>  缺点：虽然在fork中使用了写时拷贝技术，但若数据庞大，还是较耗性能；在备份周期，意外down掉的话，就会丢失最后一次快照后的所有改变；</p><p>  较适合大数据集恢复速度的，能承受数分钟内的数据丢失</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>  以日志的形式来<em><strong>记录每个写操作</strong></em>，只追加文件，不改写文件。随着AOF越来越大，需要定期对其重写，达到压缩的目的。默认关闭</p><p>  保存redis服务器执行的所有写命令来记录数据库数据。记录过程</p><p>  优点：备份机制更稳健，丢失数据的概率更低；可读的日志形式，通过AOF更稳健，可处理误操作。</p><p>  缺点：比RDB占用更多磁盘空间；恢复备份速度慢；每次读写都同步的话，有一定的性能压力；存在个别bug，造成不能恢复</p><p>  较适合对业务数据敏感的，不能承受数分钟内的数据丢失</p><h3 id="文件同步的策略"><a href="#文件同步的策略" class="headerlink" title="文件同步的策略"></a>文件同步的策略</h3><p>alawas：每次写入缓存区都要同步到AOF文件中，硬盘的操作比较慢，限制了Redis高并发</p><p>no：每次写入缓存区后不进行同步，同步到AOF文件的操作由操作系统负责，每次同步AOF文件的周期不可控，而且增大了每次同步的硬盘的数据量。</p><p>eversec：每次写入缓存区后，由专门的线程每秒钟同步一次，做到了兼顾性能和数据安全。是建议的同步策略，也是默认的策略。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认AOF不开启，需要修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendonly改为yes，开启AOF</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名字</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># AOF文件的写入方式</span></span><br><span class="line"><span class="comment"># everysec 每个一秒将缓存区内容写入文件 默认开启的写入方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># 运行AOF重写时AOF文件大小的增长率的最小值</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment"># 运行AOF重写时文件大小的最小值</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><img src="/2022/05/19/redis_c/changjing.png" alt="场景"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础</title>
      <link href="/2022/05/18/http-1/"/>
      <url>/2022/05/18/http-1/</url>
      
        <content type="html"><![CDATA[<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>是一个在计算机世界专门在 两点 之间 传输 文字、图片、音频、视频等 超文本 数据的 约定和规范</p><p>简单、灵活和易于拓展、应用广泛和跨平台</p><p>不安全</p><p>基于TCP&#x2F;IP,并且使用了【请求-应答】的通信模式</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>HTTP1.0默认使用短连接。每发起一个请求，都要新建TCP连接（三次握手），而且是串行请求，做了无谓的TCP连接建立和断开，增加了开销；</p><p>HTTP1.1就提出了长连接的通信方式（持久连接），减少了服务器的负载。特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态</p><h4 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h4><p>因为采用了长连接，所以管道网络传输成为了可能</p><p>即在同一个TCP连接中，客户端可以发起多个请求，只要第一个请求发出去，不会等其回来就可以发第二个请求出去，也就减少正特的响应时间</p><h4 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h4><p>因为当顺序发送的请求序列中的一个请求因某种原因被阻塞，后面排队的所有请求也一同被阻塞，客户端也就一直请求不到资源</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>支持C&#x2F;S模式、简单快速、灵活、无连接、无状态</p><h4 id="请求头结构"><a href="#请求头结构" class="headerlink" title="请求头结构"></a>请求头结构</h4><p>由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号</p><p>User-Agent：产生请求的浏览器类型</p><p>Accept：客户端可识别的内容类型列表</p><p>Host：请求的主机名</p><h4 id="响应头格式"><a href="#响应头格式" class="headerlink" title="响应头格式"></a>响应头格式</h4><p>状态行：状态码、八本</p><p>响应头部：</p><p>​         Server：应用程序软件的名称和版本</p><p>​         Content-Type：发送给接受者的实体正文的媒体类型</p><p>​         Accept-Language：描述资源所用的自然语言</p><p>​         Content-Length：实体正文长度</p><p>响应正文：</p><h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><h5 id="HTTP1-0和1-1"><a href="#HTTP1-0和1-1" class="headerlink" title="HTTP1.0和1.1"></a>HTTP1.0和1.1</h5><p>长连接：同上</p><p>错误状态响应码：1.1中新增加了24个错误状态响应码</p><p>缓存处理：1.1引用了更多缓存控制策略</p><p>带宽优化及网络连接的使用</p><h5 id="HTTP1-1-优化"><a href="#HTTP1-1-优化" class="headerlink" title="HTTP1.1 优化"></a>HTTP1.1 优化</h5><p>尽量避免HTTP请求（缓存技术）</p><p>在需要发HTTP请求，减少次数（减少重定向，合并请求，延迟发送）</p><p>合并请求就是合并资源，以一个大资源的请求替换多个小资源的请求；当大资源中的小资源发生变化，客户端就要重新下载整个完整的大资源</p><p>  延迟发送：只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源</p><p>减少服务器的HTTP响应大小</p><h5 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h5><p>通过静态表和哈夫曼编码的方式，将体积压缩了近一半，针对后续的请求头部也可建立动态表（会占用内存而影响并发能力）</p><p>  实现了Stream并发，多个Stream只需复用一个TCP连接，节约了TCP和TLS握手时间，以及减少了TCP慢启动阶段对流量的影响。</p><p>  服务器支持主动推送资源，大大提升了消息的传输信息</p><p>  HTTP&#x2F;2是基于TCP协议来传输数据，TCP层必须保证收到的字节数据是完成且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用。有队头阻塞问题，TCP和TLS的握手时延迟，网络迁移需要重新连接</p><h5 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h5><p>传输层的TCP换成UDP，并在UDP协议开发了QUIC协议保证了数据的可靠传输。</p><p>QUIC</p><p>  无队头阻塞</p><p>  建立连接速度块</p><p>  连接迁移</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP基础</title>
      <link href="/2022/05/17/TCP/"/>
      <url>/2022/05/17/TCP/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在运输层的可靠数据传输的服务，面向连接【1对1】、可靠的【一个报文一定能到达接收端】、基于字节流的传输层通信协议</p><p>头部包含端口号、序列号</p><p>唯一确定一个TCP连接：TCP四元组（源地址、源端口、目的地址、目的端口）</p><p><img src="/2022/05/17/TCP/jiegou.png" alt="结构"></p><p>标志位：</p><p>URG：表示TCP包的紧急指针域有效，保证TCP连接不被中断</p><p>ACK：应答域有效</p><p>PSH：push操作，让到达接收端的数据包能直接传给应用程序</p><p>RST：连接复位请求</p><p>SYN：建立连接</p><p>FIN：断开连接</p><h1 id="如何保证可靠性"><a href="#如何保证可靠性" class="headerlink" title="如何保证可靠性"></a>如何保证可靠性</h1><p>应用数据都被分割成TCP认为最适合发送的数据包</p><p>  给发送的每一个包进行编号，接收方对数据包排序，把有序数据传给应用层</p><p>  校验和：保持首部和数据的校验和，检测数据是否有变化</p><p>  流量控制：控制协议是可变大小的滑动窗口协议（防止发送方无脑的发送），以控制发送方发送效率</p><p>  拥塞控制：网络拥塞时，减少数据发送。慢启动（每收到一个ACK，拥塞窗口就+1，直到增加到门限状态变量），拥塞避免（超过慢启动门限后进行，每个ACK，cwnd+1），拥塞发生（超时重传，快速重传），快速恢复</p><p>  超时重传：TCP发出一个段后，启动一个定时器，若不能及时收到确认，就重新发这个报文；数据包丢失或确认应答丢失会发生该情况。定时器太长，重发就满了，没效率，性能差；太短，可能没有丢就重发了，会增加网络拥塞，导致更多超时</p><p>  QRQ协议：为实现可靠重传，每发完一个分组后就停止发，收到对方发的确认后再发下一个</p><p>重传机制：</p><p>​       超时重传：如上</p><p>​      快速重传：以数据驱动重传。收到三个相同ACK报文时，立刻重传丢失报文段</p><p>滑动窗口：</p><p>  TCP头部有一个字段交Window（窗口大小），接收端告诉发送端子机还有多少缓冲区可接收数据，于是发送端就根据这个发送数据。大小为0时，就会阻止发送方发送数据</p><p>解决窗口关闭：TCP为每个链接设有一个持续定时器，只要TCP连接一方收到对方的零窗口通知，就启动该定时器，定时器超时的话就发送窗口检测报文，而对方确认该报文时给出自己接收窗口大小</p><h1 id="黏包"><a href="#黏包" class="headerlink" title="黏包"></a>黏包</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多个数据包被连续存储在连续的缓存中，在对数据包读取时由于无法确定发生方的发送边界，而采用某一估测值大小来读出数据。双方size不一致就会让发送方发送的若干包数据到接收方接收时沾成一包，从接收缓冲区看，后一包的数据的头紧接着前一包数据的尾</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>TCP若连续几次发送的数据很少，那TCP根据优化算法把这些数据合成一包一次发送，接收方就收到了粘包数据</p><p>  TCP协议有MISS，若数据包过长就会被分开传输。接收方就收到粘包数据</p><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>TCP短连接就不用考虑</p><p>若数据无结构，发送放就只管发，接收方只管接，也不用考虑</p><p>双方建立长连接，要在连接一段是时间内发送不同数据结构：</p><p>​         发送端的每个数据包添加包首部，首部中应该至少包含数据包的长度。这样接收方就能知道数据包的实际长度</p><p>​         发送端将每个数据包封装为固定长度（不够的，0补充），接收端每次就从接收缓冲区中读取固定长度的数据就行，也就拆开了数据包</p><p>​         可在数据包之间设置边界</p><h1 id="与UDP的比较"><a href="#与UDP的比较" class="headerlink" title="与UDP的比较"></a>与UDP的比较</h1><table><thead><tr><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">面向连接</td><td align="center">无连接</td></tr><tr><td align="center">提供可靠服务</td><td align="center">尽最大努力交付</td></tr><tr><td align="center">面向字节流</td><td align="center">数据报文段</td></tr><tr><td align="center">每一条TCP连接都是点到点</td><td align="center">支持一对一，一对多，多对多的交互通信</td></tr><tr><td align="center">首部开销20字节</td><td align="center">首部开销8字节</td></tr><tr><td align="center">全双工可靠通信</td><td align="center">不可靠通信</td></tr><tr><td align="center">常用于FTP文件传输、HTTP&#x2F;HTTPS</td><td align="center">包总量较少信息，视频、音频等多媒体通信，广播通信</td></tr><tr><td align="center">传输较慢，所需资源较多</td><td align="center">传出快，所需资源少</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile</title>
      <link href="/2022/05/16/volatile/"/>
      <url>/2022/05/16/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>是java提供的一个轻量级的同步机制。java中有两种内在的同步机制：同步块和volatile变量，与synchronized相比，volatile更轻量，<em><strong>不会引起线程上下文切换和调度</strong></em>，但是同步性也较差</p><h1 id="并发编程的基本概念"><a href="#并发编程的基本概念" class="headerlink" title="并发编程的基本概念"></a>并发编程的基本概念</h1><p>原子性：一个或多个操作，要么全部执行且过程中不会打断，要么就都不执行。即拒绝多线程操作，同一时刻就只有一个线程进行操作。整个操作中，不会被线程调度器中断的操作，都可以认为是原子性</p><p>可见性：当多个线程去访问一个变量的时候，一个线程修改了一个或多个变量后，其他线程能够立刻看到这些被修改后的值。多线程环境下，一个线程对共享变量的操作对于其它线程是不可见的。volatile来保证可见性，变量被其修饰后，线程本地的内存就会无效，线程对该变量修改后就会同步更新到主内存中，其它线程读取变量时，就会从主内存中读取。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行</p><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>JMM决定一个线程对共享变量的写入在什么时候对另一个线程是可见的。JMM定义了线程和主内存之间的抽象空间：共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的操作必须在工作内存中进行，而不能直接读写主内存中的变量</p><img src="/2022/05/16/volatile/JMM.png" alt="JMM" style="zoom:50%;"><p>对于普通的共享变量，线程A将其修改为某个值的过程在本地内存A中，并没有同步到主内存中；而线程B已经缓存了该变量的旧值，也就导致了共享变量的值不一样。加锁（lock或synchronized）可以解决这样的问题，但是太重量级，影响效率，所以使用volatile</p><p>JMM是个<em><strong>抽象的内存模型</strong></em></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>保证共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量</p><p>该关键字能保证修改的值能立即被更新到主存</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JVM底层volatile是采用<em><strong>内存屏障</strong></em>实现，观察加入volatile关键字和没有加的关键字所产生的汇编代码发现，加入后的会有一个lock指令，实际上相当于一个内存屏障</p><p>内存屏障的作用：</p><p>​能确保指令重排时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障后面的；即执行到内存屏障这句指令时，前面的操作就已经完成</p><p>​会强调对缓存的修改操作立即写入主内存</p><p>​若是写操作，会让其它CPU中对应的缓存行无效，即必须从主内存中读取变量</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>可见性：对一个volatile变量的读，总能看到（任意线程）对该volatile变量最后的写入</p><p>防止指令重排的问题。</p><p>Java虚拟机中，每个线程对应一个工作内存，并共享主内存的数据</p><p>JMM：线程解锁前，必把共享变量的值刷新回主内存；加锁前，必须读主内存的值到自己的工作内存；加锁和解锁是同一把锁</p><h2 id="内存语义的实现"><a href="#内存语义的实现" class="headerlink" title="内存语义的实现"></a>内存语义的实现</h2><p>JMM会分别限制两种类型的重排序：编译重排序和处理器重排序</p><p>编译重排序：当第二个操作是volatile写时，不管第一个，都不能重排序；当第一个是读时，不管第二个，都不能重排序；第一个写，第二个读，不能</p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><p>对变量的写入操作不依赖变量的当前值或能确保只有单个线程改变变量的值</p><p>该变量不会与其他状态变量一起纳入不变性条件中</p><p>访问变量时不需要加锁</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p>volatile保证了<em><strong>可见性</strong></em>，提供了一定的<em><strong>有序性</strong></em>，<em><strong>不保证原子性</strong></em>。</p><h1 id="单例模式的双重锁为什么要写volatile"><a href="#单例模式的双重锁为什么要写volatile" class="headerlink" title="单例模式的双重锁为什么要写volatile"></a>单例模式的双重锁为什么要写volatile</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//在并发情况下，若没有volatile关键字，该行会出问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton();//分解为三行</span><br><span class="line"></span><br><span class="line">a. memory = allocate() //分配内存</span><br><span class="line"></span><br><span class="line">b. ctorInstanc(memory) //初始化对象</span><br><span class="line"></span><br><span class="line">c. instance = memory //设置instance指向刚分配的地址</span><br></pre></td></tr></table></figure><p>若没有volatile，可能会出现重排序的情况。多线程环境下，可能执行了a，c，没有执行b，A线程执行了c导致instance指向了一个地址，所以判断instance不会null，会直接返回一个初始化对象</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2022/05/15/String/"/>
      <url>/2022/05/15/String/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h1><p>String中使用了final关键字修饰字符数组保存字符串，所以Stirng对象是不可变的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java9之后，String、StringBuilder、StringBuffer都改用byte数组存储</span><br><span class="line">为什么从char字符改为byte字符？</span><br><span class="line">因为节省内存空间，byte占一个字节（8位），char占用两个字节，所以节省了一半的内存空间。降低了gc的压力，针对初始化的字符，对字符长度进行判断而选择不同的编码方式</span><br></pre></td></tr></table></figure><p>StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在该类中也是使用字符数组保存字符串char [] value，但是没有用final关键字修饰，所以这两种对象是可变的</p><p>AbstractStringBuilder类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This no-arg constructor is necessary for serialization of subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an AbstractStringBuilder of the specified capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>因为String类的不可变性，才让JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量中的同一个对象。这样<em><strong>节约内存又提升性能</strong></em></p><p>也因为不可变性，保证了字符串对象在<em><strong>多线程环境下是线程安全的</strong></em>。若String可变，那么会引发严重的安全问题。<em><strong>因为字符串不可变，所以值不能被修改，若字符串是可变的，那么可以通过改变引用地址指向的值去改变字符串的值，也就有安全漏洞</strong></em></p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>String因为不可变，可以<em><strong>理解</strong></em>为常量，线程安全。AbstractStringBuilder是StringBuilder和StringBuffer的公共父类。其中StirngBuffer加了同步锁或者调用的方法加了同步锁，线程安全。StringBuilder并没有对方法加同步锁，线程非安全</p><h1 id="Buffer和Builder"><a href="#Buffer和Builder" class="headerlink" title="Buffer和Builder"></a>Buffer和Builder</h1><p>都是AbstractStringBuilder的子类，但是StringBuffer的几乎所有方法都使用synchronized实现了同步，线程比较安全，在多线程系统中可以保证数据同步。</p><p>而StringBuilder没有实现同步，线程不安全，但是正因如此，效率更高</p><h2 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h2><p>二者的构造方法，默认都是16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer.java </span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">       append(str);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//StringBuilder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">       append(str);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过append方法中的ensureCapacityInternal方法可以触发扩容newCapacity获得新的容量大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value,</span><br><span class="line">                    newCapacity(minimumCapacity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//计划的扩容为 当前的容量*2+2.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            ? hugeCapacity(minCapacity)</span><br><span class="line">            : newCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/2022/05/14/thread/"/>
      <url>/2022/05/14/thread/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>新建(new)，就绪(runnable)，运行(running)，阻塞(block)，死亡(dead)</p><p>新建：使用new创建一个线程，此时仅由jvm为其分配内存，并初始化其成员变量的值</p><p>就绪：调用了start()方法，jvm为其创建方法调用栈和程序计数器</p><p>运行：就绪状态获取了cpu，开始执行run方法</p><p>阻塞：因某种原因放弃了cpu的使用，暂时停止运行，直到进入可运行状态</p><p>​    等到阻塞:运行o.wait()方法，JVM会把线程放入等待队列</p><p>   同步阻塞:运行的线程获取对象的同步锁时，若该锁被占用，则JVM把该线程放入锁池</p><p>​    其他阻塞:运行sleep()或t.join()或I&#x2F;O请求，JVM把该线程设为阻塞状态</p><p>死亡：正常结束或异常结束或调用线程的stop()方法（该方法易导致死锁）</p><p>Blocked和waiting的区别：线程可以通过notify进入waiting状态，进入后就等待唤醒才有获取cpu的时间片段来继续执行；blocked状态是无法进入同步方法&#x2F;代码完成的，因为无法获取相关联的锁</p><h1 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h1><p>继承Thead类</p><p>​自定义类继承Thread类，重写run()方法，创建线程对象并启动线程（start()方法，不是run；线程不能多次启动，只能执行一次）</p><p>实现Runnable接口</p><p>​自定义类实现Runnable接口，重写run()方法，创建自定义类对象，创建Thread类的对象，并把创建的自定义类的对象作为构造参数传递，启动线程</p><p>使用Callable和Future创建线程</p><p>​ 创建Callable接口的实现类，并实现call()方法，再创建该实现类的实例。使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值。使用FutureTask对象作为Thread对象的target创建并启动线程。调用FutrueTask对象的get()方法来获得子线程执行结束后的返回值</p><p>线程池实现</p><p>实现线程间共享数据：线程间共享对象，然后wait&#x2F;notify&#x2F;nofifyAll</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>  线程数小于核心线程数—&gt;核心线程数</p><p>  线程数大于核心线程数 —&gt;将多余的放入任务队列</p><p>  任务队列满了，就启动最大线程数</p><p>  最大线程数也达到后，就启动拒绝策略</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p> ThreadPoolExecutor.AbortPolicy：线程池默认的，即丢弃任务并抛出RejectedExecutionException异常</p><p>  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃</p><p>  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</p><p>  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务（不会丢弃任务，最后所有的任务都执行了，并不会抛出异常）</p><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>通过构造方法ThreadPoolExecutor</p><p><img src="/2022/05/14/thread/executors.png" alt="image-20220427110329004"></p><p>构造方法参数</p><p><img src="/2022/05/14/thread/threadPoolExecutor.png" alt="image-20220514145815343"></p><p>  CorePoolSize：核心线程数，默认状况下核心线程会一直存活；</p><p>  maximumPoolSize:线程池所能容纳的最大线程数。超过将被阻塞</p><p>  keepAliveTime:非核心线程的闲置时间超过时间，超过就会被回收</p><p>  unit：指定keepApliveTime的单位。但allowCoreThreadTimeOut设为true就无效</p><p>  workQueue：线程池的任务队列</p><p>  threadFactory：线程工厂，提供创建新线程时使用的工厂</p><p> handler：拒绝策略。当工作队列的任务和线程中的线程均到最大限制，就触发拒绝策略</p><h2 id="拒绝策略-1"><a href="#拒绝策略-1" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>  ThreadPoolExecutor.AbortPolicy：线程池默认的，即丢弃任务并抛出RejectedExecutionException异常</p><p>  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃</p><p>  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</p><p>  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务（不会丢弃任务，最后所有的任务都执行了，并不会抛出异常）</p><h2 id="execute-和submit"><a href="#execute-和submit" class="headerlink" title="execute()和submit()"></a>execute()和submit()</h2><p> Execute()用于提交不需要返回值的任务，so 不能判断线程池任务是否成功执行；Submit()用于提交需要返回值的任务</p><p>Execute是只能提交Runnable类型的任务，submit可以提交Runnable和Callable类型</p><p>Execute可以抛出异常，submit不排除异常（可以通过Future的get将任务执行时的异常抛出）</p><h1 id="为什么调用了start-后必须调用run-方法"><a href="#为什么调用了start-后必须调用run-方法" class="headerlink" title="为什么调用了start()后必须调用run()方法"></a>为什么调用了start()后必须调用run()方法</h1><p>new 一个 thread，线程进入新建状态，调用start()方法，会启动一个线程并使线程进入就绪状态，当分配时间片后就可以运行。Start会执行线程的准备工作，再自动执行run()。这才是真正的多线程工作。但直接run()，会吧其当成一个main线程下普通方法执行</p><p>总之：调用start()方法可启动线程并使线程进入就绪状态，直接run不会以多线程方式执行。但是执行start方法，线程不一定马上创建，因为底层是操作系统，是否创建线程需要看情况。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashmap</title>
      <link href="/2022/05/13/hashmap/"/>
      <url>/2022/05/13/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p><em><strong>主干是entry数组</strong></em>，每个entry保存了key和value。要添加键值对的时候会根据一个hash算法计算key后的值，再通过数组大小n-1&amp;hash值之后，得到一个数组的下标，然后往那个位置塞入这个entry。</p><p>默认大小16，负载因子0.75；当数量达到16* 0.75&#x3D;12时，就会扩容，扩容设计到rehash、复制数据等操作，很消耗性能，<em><strong>提前预估大小</strong></em></p><p>在JDK1.8以前：以数组和链表的形式组成。当数据越多，查询效率O(N)会越来越大。并且是<em><strong>先扩容再进行插入</strong></em></p><p>在JDK1.8后：引入了红黑树，链表元素超过阈值8时，链表转为红黑树；&lt;&#x3D;6时，树还原成链表。原因：红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；而且是先插入，再看size是否大于阈值，大于则扩容</p><p><img src="/2022/05/13/hashmap/jiegou.png" alt="image-20220427110202488"></p><h1 id="负载因子0-75"><a href="#负载因子0-75" class="headerlink" title="负载因子0.75"></a>负载因子0.75</h1><p>作用就是扩容机制的阈值。若是1.0，hashmap就会有大量冲突，底层的红黑树会很复杂，查询效率很低，空间利用率上去，时间效率降低；若是0.5，hash冲突减少，底层的链表长度和红黑树的高度会降低，时间效率提升，空间利用率降低。0.75就比较适中，空间利用率较高，避免比较多的冲突</p><h1 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h1><p>JDK1.7：</p><p>​判断当前数组是否要初始化</p><p>​    若key为空，则put一个空值进去</p><p>​通过hash()函数计算key哈希值，并得到其下标</p><p>​将hash、key、value等信息封装成一个entry对象</p><p>​根据当前下标位置上的节点情况，采用不同方法放置此节点（若key和传入的key相等则覆盖原来的key，反之增新增一个entry对象）。链表和红黑树的情况放置</p><p>JDK1.8:</p><p>​ 实际是调用putval方法，计算的key的hash值、key、value都放过去</p><p>判断底层的table表是否空，空就扩容到16；根据key计算hashcode，再通过hash值得到table表的下标索引；</p><p>若当前位置没有节点，就挂上去。</p><p>若有节点，先判断表里的key和输入的key或者内容是否相同，相同就赋值给e</p><p>​            若不相同，则判断是否是红黑树，若是则根据红黑树的原理加 </p><p>​                          也不是红黑树，则遍历链表，链表没有一个key相同，则放在最后；存在相同就覆盖</p><p>​    判断是否需要扩容</p><p>put源码1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//计算键的哈希值，放值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="comment">//链表数组；链表对象；           长度； 索引</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="comment">// tab是否为空或者长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 是：就执行扩容方法，数组的长度是扩容后的长度</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 获取tab的第i个元素，判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 为空就赋值给第i个</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//就会有两种情况，hash值重复、碰撞了</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断key值是否重复了</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//就直接把上一个的值覆盖</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//判断tab[i]是否是红黑树 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据红黑树的性质插入值</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是红黑树就是链表，就开始遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//判断是否是最后一个或者是否是空，是空就插入进链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//判断链表的长度是否是大于8的，若是则转为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//key是否存在，存在就覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e不为空，就将e添加到tab中</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//当前的数量是否大于阈值，大于就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>流程图</p><p><img src="/2022/05/13/hashmap/put-liucheng.png" alt="image-20220513124451221"></p><h1 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h1><p>JDK1.7</p><p>​通过hash()计算key的哈希值，得到其下标，判断该位置是否是链表；不是就根据key、value的hashcode是否相等返回值。为链表就遍历直到 key和hashcode相等就返回。遍历完也没有就返回null</p><p>JDK1.8：</p><p>创建一个Node节点 e，调用getNode方法，传参计算的hash值和key值</p><p>  计算hashcode得到桶，桶空就返回null；判断桶的第一个位置的key是否为查询的key，是就返回value；不是就判断下一个是红黑树还是链表，就根据红黑树和链表进行查找（都是遍历，查找）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="comment">//判断是否为空，判断key对应的链表节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断链表头部元素是否是key值对应的真实value</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//链表是否含有下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//是否红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//根据红黑树的逻辑查找对应的value</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//根据hash和key值判断下一个元素是否是key值对应的真实value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//什么都没找到，就为null值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="与HashTable的比较"><a href="#与HashTable的比较" class="headerlink" title="与HashTable的比较"></a>与HashTable的比较</h1><table><thead><tr><th align="center">HashMap</th><th align="center">HashTable</th></tr></thead><tbody><tr><td align="center">继承的AbstractMap</td><td align="center">继承的Dictionary</td></tr><tr><td align="center">Null可以作为键（只有一个），也可以作为值（多个）</td><td align="center">不支持Null key和Null value</td></tr><tr><td align="center">线程不安全，多线程并发可能导致死锁。但也因此效率更高</td><td align="center">线程安全，因每个方法都有Synchronize方法</td></tr><tr><td align="center">默认初始化大小16，每次扩容为原来的2倍</td><td align="center">默认初始化大小11，每次扩容为原来的2*N+1</td></tr><tr><td align="center">计算hash值的方法不同</td><td align="center">计算hash值方法不同</td></tr><tr><td align="center">遍历方法的内部实现不同</td><td align="center">遍历内部实现不同</td></tr><tr><td align="center">没有contains方法</td><td align="center">有contains方法</td></tr></tbody></table><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手四次挥手基础</title>
      <link href="/2022/05/12/threefour/"/>
      <url>/2022/05/12/threefour/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>建立可靠的通信信道，也就是<em><strong>双方确认自己与对方发送与接收是正常的</strong></em></p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>一开始，服务端和客户端都是closed状态。先是服务端主动监听某个端口，处于LISTEN状态。</p><p>客户端随机初始化序号，将此序号置于TCP首部的‘序号’字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SEBT状态</p><p>服务器端收到SYN报文后，首先服务端也随机初始化自己序号，并填入TCP首部的‘序号’字段中，其次把TCP首部的‘确认应答号’字段填入，再把SYN和ACK标志位置为1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态</p><p>客户端收到服务端报文后，再向服务端回应最后的应答报文，应答报文TCP首部ACK标志位置位1，其次‘确认应答号’字段填入，最后把报文发送服务端，这个报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态。服务器收到客户端的应答报文后也进入ESTABLESHED状态</p><p>简单说：客户端发送链接请求报文；服务端接收连接后回复ACK报文，并分配资源；客户端接收了ACK报文后向服务端发送ACK报文，并分配资源</p><p>客户端和服务端初始化序列号不能一样：防止历史报文被下一个相同元祖的连接接收</p><p><img src="/2022/05/12/threefour/woshou.png" alt="image-20220512090045815"></p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>客户端发起中断连接请求，就是发FIN报文（FIN位置置位1），等待服务器发FIN报文；当服务器端确定数据（读到结束符EOF）已发送完成，则向客户端发FIN报文，延迟一段时间 再发ACK报文（处理一些最后的请求）；客户端收到FIN报文后发送ACK报文（若服务器端没有收到则可以重传）；服务器端收到ACK就关闭，客户端等待了2MSL（最大报文生存时间，因为最后一个ACK可能会丢失）后没收到回复就关闭</p><p><img src="/2022/05/12/threefour/huishou.png" alt="image-20220512090215143"></p><h1 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h1><p>因为三次握手才可以阻止重复历史连接的初始化（最主要，若是两次握手就不能判断）：若是历史连接，客户端发送的报文就是RST报文，反之则是ACK报文</p><p>同步双方的初始序列号：</p><p>避免资源浪费：  若服务端阻塞，发送了多个SYN报文，那么服务器收到请求后会建立多个无效链接</p><p>两次的话：就没办法确定客户端的接收能力，就可能让客户端单方面觉得连接已建立，序列号得不到确认</p><p>三次握手的过程就是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤。若是两次就只有一方选择的序列号得不到确认</p><p>主要目的就是保证连接是双工的，保证双方得知自己和对方收发能力正常</p><h1 id="握手是三次，挥手是四次"><a href="#握手是三次，挥手是四次" class="headerlink" title="握手是三次，挥手是四次"></a>握手是三次，挥手是四次</h1><p>当服务器端收到SYN连接请求报文后，可以直接发SYN+ACK报文，ACK是应答，SYN是同步的。关闭时，服务器端收到FIN时，有可能不会立即关闭SOCKET，所以只能先回一个ACK报文</p><p>但在抓包时，服务器接收到FIN后，服务器端同时要关闭链接，这样ACK和FIN一起发送节省了一个包。从抓包方面看，就是“三次挥手”</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB基础</title>
      <link href="/2022/05/11/InnoDB-1/"/>
      <url>/2022/05/11/InnoDB-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>现mysql 5.5后默认引擎，兼顾高可靠性和高性能性的通用存储引擎</p><p>若要对事务的完整性要求较高、要求实现并发的话，InnoDB有大优势；若频繁更新、删除操作也可，因为支持事务的提交和回滚</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>​    DML遵循ACID模型，支持<em><strong>事务</strong></em>。<em><strong>行级锁</strong></em>（加锁开销最大，加锁慢，会出现死锁），提供并发性能；支持<em><strong>外键</strong></em>FOREIGN KEY约束，保证数据的完整性和正确性。</p><p><em><strong>数据块要缓存</strong></em>；寻址要映射到块，再到行；要维护MVCC一致，所以Innodb在select的时候要维护的东西比较多</p><p>delete表的时是一行一行删除，而myisam则是先drop表，再重建表</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>聚集索引：</p><p>​将数据存储与索引放到一块，索引的叶子节点保存了行数据，必有且只有一个聚集索引。若有主键，主键即是；无主键用第一个唯一索引；若都没，会自动生成一个rowid作为隐藏的聚集索引。</p><p>索引结构：</p><p>​B+树：将所有数据都放在叶子节点，叶子节点形成一个列表，非叶子只存放键值，每个数据叶中的有效数据就多了，可以减少IO次数</p><p>​    因为相对于二叉树（会有左倾右倾的情况），B+树层级更少，搜索效率高</p><p>​    因为B树：无论叶子节点还是非叶子，都保存数据，所以存储值减少，指针就减少，要同样保存大量数据，只能增加树的高度，导致性能降低，要查找就要遍历整个树</p><p>​    Hash索引只支持等值匹配，不支持排序操作</p><p>二级索引：将数据与索引分开，索引结构的叶子节点关联的是对应的主键</p><h1 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h1><p>TableSpace(表空间)：可以看成Innodb逻辑存储的最高层，所有的数据都存放在表空间内</p><p>Segment（段）：分为数据段、索引段、回滚段。Innodb是索引组织表，数据段是B+树的叶子节点，索引段为B+的非叶子节点。段用来管理多个区</p><p>Extent（区）：表空间的单元结构，每个区默认1M。innodb引擎页大小为16K。连续的页组成</p><p>Page（页）：每个默认16KB，存储引擎磁盘管理的最小单位。数据页、undo页、系统页、事务数据页</p><p>Row（行）：存放的数据</p><h1 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h1><p>Buffer Pool（缓冲池）：</p><p>主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据。增删时，先操作缓冲池的数据（没有，则从磁盘加载），再以一定频率刷新到磁盘，也就减少磁盘IO，加快处理速度</p><p>​    页为单位，链表数据结构管理Page。空闲page（未被使用），被使用page（数据没有被修改过），脏页（被使用过，数据与磁盘的数据不同）</p><p>Change Buffer（更改缓冲区）：执行DML时，操作的数据不在buffer pool中就不会操作磁盘，会将数据变更存在此处，在未来数据被读取时，再将数据合并恢复到缓冲池，再将合并后的数据写到磁盘</p><p>意义：可以在缓冲池中间进行合并处理，减少磁盘IO。因为二级索引一般非唯一，并且以相对随机的顺序插入二级索引。</p><p>Log Buffer（日志缓冲区）：用来保存要写入到磁盘中的log日志数据，默认16MB，日志缓冲区的日志会定期刷新到磁盘中。</p><p>后台线程：将缓冲池中的数据在合适的时候刷新到磁盘</p><p>Master thread：核心，负责调度其他线程，将缓冲池中的数据异步刷新到磁盘中，保持数据一致性，包括脏页的刷新、合并插入缓存，undo页的回收</p><p>​    IO thread：负责IO请求的回调</p><p><img src="/2022/05/11/InnoDB-1/jiegou.png" alt="image-20220511134406227"></p><h1 id="保证ACID"><a href="#保证ACID" class="headerlink" title="保证ACID"></a>保证ACID</h1><p>Redo log（重做日志）：保证持久性。记录的是事务提交时数据页的物理修改。记录的是物理日志</p><p>​    重做日志缓冲：在内存   重做日志文件：在磁盘</p><p>​    当事务提交后把所有信息都存到日志文件，用于刷新脏页到磁盘；发生错误，进行数据恢复使用</p><p>​    在脏页信息发生错误时进行数据恢复，也就是持久性。</p><p>Undo log（回滚日志）：保证原子性。记录数据被修改前的操作。逻辑日志</p><p>​             作用：提供回滚和MVCC</p><p>​             Delete时，undo log里记录insert；update时，会记录反向的update语句 </p><p>​         当事务提交时不会立即删除，因为可能用于MVCC</p><p>​         采用段的方式进行管理和记录</p><h1 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h1><p>通过MVCC。</p><p>MVCC会给每行元祖加一些辅助字段，记录版本号和删除版本号，每一个事务启动都有一个唯一的递增的版本号。每开启一个事务，事务版本号就会递增</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized基础</title>
      <link href="/2022/05/10/synchronized-1/"/>
      <url>/2022/05/10/synchronized-1/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>解决多个线程之间访问资源的同步性，该关键字可保证修饰的方法或代码块在任意时刻只能有一个线程执行。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>JVM是通过进入、退出对象监视器来实现对方法、同步块的同步，而对象监视器的本质依赖于底层操作系统的互斥锁实现，能自动解锁</p><p>使用：</p><p>作用于普通方法时：锁的是对象的实例，即this对象，所谓的方法锁。进入同步代码块，要获得当前实例的锁</p><p>修饰静态方法时：锁的是这个类的所有class对象，即xxx.class  类锁。会作用于所有对象实例。进入同步代码要获得当前类对象的锁</p><p>修饰代码块（在方法中）时：锁的是synchronized(obj)，用户给定的对象，对象锁。进入同步代码要获得给定对象的锁</p><p><img src="/2022/05/10/synchronized-1/use.png" alt="use"></p><p>不能在类级别的（静态）代码块</p><p>特点：</p><p>  原子性、可见性（释放锁时，所有写入都会写回内存，获得锁就会从内存读取最新数据）、有序性；可重入性（对同一个线程在获得锁后，在调用其他需同样锁的代码时可直接调用）；重量级（底层是一个监视器对象完成。监视器锁的本质是依赖于操作系统的互斥锁实现）</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p> 偏向锁：Java6之后加的新锁。会偏向当前已经占领锁的线程 ，总是让一个线程多次获得。只在第一次请求锁时采用CAS操作并将锁对象的标记字段记录为当前线程地址。之后，持有该锁的线程无需加锁操作</p><p>​线程在进入同步代码块获得锁时，会检查对象头中是否存储了线程ID，若没有，判断一下偏向标志位是否为1，若不是1，说明该锁没有被任何线程获取，就CAS的方式替换mark word，将对象Mark word中的线程ID指向该线程，并将偏向标志位置位</p><p>  轻量锁：多个线程在不同时间请求同一把锁，即没有锁竞争。代码进入同步块时，若同步对象无锁，当前线程会在栈帧中创建一个锁记录区域，同时将锁对象头中的mark word拷贝到锁记录，再使用CAS将mark word 更新为指向锁记录的指针</p><p>  自旋锁：轻量级失败后，进行。基于大多数情况下，线程持有锁的时间都不会太长。因为线程间的切换操作系统需要从用户态到核心态，时间成本高。线程没有获取到锁的时候，虚拟机让线程做几个时间不太久的空循环（即自旋），循环后再次去尝试获取锁，若得到锁就进入临界区，反之就会被在操作系统层面挂起。<em><strong>提升了效率</strong></em>，最后没办法就只能升级为重量级锁</p><p>  锁消除：<em><strong>删除不必要的加锁</strong></em>。虚拟机在JIT编译时，扫描运行上下文，去除不可能存在共享资源竞争的锁。</p><p>  锁粗化：将多次连续的加锁、解锁操作合并为一次，将多个连续的锁拓展成一个更大的锁</p><p> 构造方法不能使用该关键字修饰，因为构造方法本身就线性安全</p><h1 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h1><p>是通过monitorenter获取锁，通过monitorexit释放锁</p><p>出现两个monitorexit：防止同步代码块中线程因异常退出，而锁没有释放，这必然会导致死锁。<em><strong>最后一个monitorexit保证在异常情况下，锁也可以得到释放，避免死锁</strong></em></p><h1 id="和Lock比较"><a href="#和Lock比较" class="headerlink" title="和Lock比较"></a>和Lock比较</h1><p>相同点：</p><p>  都是可重入锁；都保证了可见性和互斥性；都可以用于控制多线程对共享对象的访问</p><p>不同点</p><table><thead><tr><th align="center">ReetrantLock</th><th align="center">synchronized</th></tr></thead><tbody><tr><td align="center">默认也是非公平，但可以实现公平锁</td><td align="center">锁非公平</td></tr><tr><td align="center">只是lock接口下的实现类，是API层面的锁</td><td align="center">是JVM级别的锁</td></tr><tr><td align="center">显示获取和释放锁，在使用时避免程序异常无法释放锁，需要在finally控制块中进行解锁操作</td><td align="center">隐式获取锁和释放锁</td></tr><tr><td align="center">等待可中断、可实现公平锁、可实现选择性通知</td><td align="center"></td></tr><tr><td align="center">是可精确唤醒</td><td align="center">要么随机唤醒一个线程，要么唤醒所有等待的线程</td></tr></tbody></table><p>隐式锁和显示锁就是在使用的时候，使用者是否要手动写代码来控制获取锁和释放锁</p><p>公平锁实现：获取锁时，会先看sync队列是否在 等待获取资源的线程。没有就尝试获取锁，若有就将当前线程封装成node加入sync队列</p><p>非公平锁实现： 当线程争锁时，会进行一次CAS尝试获取锁，失败就进入acquir(1)函数，再尝试获取锁，若失败就将当前线程封装成node加入sync队列，就等前面线程执行完轮到自己</p><h1 id="和volatile比较"><a href="#和volatile比较" class="headerlink" title="和volatile比较"></a>和volatile比较</h1><table><thead><tr><th align="center">Synchronized</th><th align="center">Volatile</th></tr></thead><tbody><tr><td align="center">性能较差</td><td align="center">线程同步的轻量级实现，性能更好</td></tr><tr><td align="center">可以修饰方法以及代码块</td><td align="center">只能用于变量</td></tr><tr><td align="center">原子性、可见性都保证</td><td align="center">可保证数据的可见性，不保证原子性</td></tr><tr><td align="center">解决的是多线程之间访问资源的同步性</td><td align="center">解决变量在多个线程间的可见性</td></tr><tr><td align="center">因为是锁，可能造成线程阻塞</td><td align="center">不会线程阻塞</td></tr><tr><td align="center">标记的变量可以被编译器优化</td><td align="center">标记的变量不会被编译器优化</td></tr></tbody></table><p>内存屏障：是CPU的重排列指令引起的</p><p>Volatile通过内存屏障禁止指令重排序</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC基础</title>
      <link href="/2022/05/09/springmvc-1/"/>
      <url>/2022/05/09/springmvc-1/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><img src="/2022/05/09/springmvc-1/MVCP.png" alt="MVC" style="zoom:80%;"><p>是软件工程中的一种软件架构模式，它把软件系统分为模型、<strong>视图</strong>和<strong>控制器</strong>三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p>Model: 存储实体类。完成具体的业务操作，如：查询数据库，封装对象</p><p>View：页面展示（视图模式）。JSP、HTML等数据展示，用户可以看到的</p><p>Controller：页面逻辑处理，与用户监控。获取View的请求，调用模型将数据交给视图</p><p>流程：浏览器输入url后，就是发送请求到对象服务器，服务器根据url找到controller，控制器根据业务的逻辑从model获取数据，再把数据给特定的view，view就是客户看的到的结果</p><h2 id="为什么要使用MVC"><a href="#为什么要使用MVC" class="headerlink" title="为什么要使用MVC"></a>为什么要使用MVC</h2><p>可以使同一个程序使用不同的表现形式，若控制器反馈给模型的数据发生了变化，模型也要发生变化</p><p>因模型独立于视图，所以模型可以复用，模型可以独立的移植到别的地方使用</p><p>前后端代码分离，让项目开发的分工更加明确，提高了开发效率</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>一种基于java实现MVC设计模型的请求驱动类型的轻量级web框架。将负载的应用程序系统按照分层处理进行设计和规划，以降低开发难度，提供代码的可维护性。比其他的MVC框架更具有灵活性和拓展性</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/2022/05/09/springmvc-1/springmvcP.png" alt="springmvc"></p><p>框架主要就是围绕中央控制器dispatcherServlet展开</p><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p>前端控制器(dispatcherServlet)：接收请求，响应结果，将各个组件连通</p><p>处理器映射器：根据用户请求的URL找到对应的Handler</p><p>处理器适配器：按照HandlerAdapter的规则去编写，适配器才可以正确执行Handler</p><p>处理器：controller</p><p>视图解析器：视图的解析，根据视图逻辑名解析成真正的视图</p><p>视图：一个接口，支持不同的视图类型</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>可以支持各种视图技术，不局限于JSP</p><p>与spring框架继承</p><p>清晰的功能分配：前端控制器、请求到处理器映射、处理器适配器、视图解析器</p><p>支持各种请求资源的映射策略</p><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="建立Map-lt-urls-controller-gt-的关系"><a href="#建立Map-lt-urls-controller-gt-的关系" class="headerlink" title="建立Map&lt;urls,controller&gt;的关系"></a>建立Map&lt;urls,controller&gt;的关系</h3><p>入口类就是ApplicationObjectSupport的setApplicationContext方法，核心就是initApplicationContext</p><p><img src="/2022/05/09/springmvc-1/set.png" alt="image-20220509135611735"></p><p>AbstractDetectingUrlHandlerMapping实现了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException &#123;</span><br><span class="line">        <span class="built_in">super</span>.initApplicationContext();</span><br><span class="line">        detectHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">　　  * 建立当前ApplicationContext中的所有controller和url的对应关系</span></span><br><span class="line"><span class="comment">　　　 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">         <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">　　　　 <span class="comment">// 获取ApplicationContext容器中所有bean的Name</span></span><br><span class="line">       String[] beanNames = <span class="built_in">this</span>.detectHandlersInAncestorContexts?</span><br><span class="line">           BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class):</span><br><span class="line">           applicationContext.getBeanNamesForType(Object.class);</span><br><span class="line"> String[] var3 = beanNames;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> beanNames.length;</span><br><span class="line">        <span class="comment">// 遍历beanNames,并找到这些bean对应的url</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">             <span class="comment">// 找bean上的所有url(controller上的url+方法上的url),该方法由对应的子类实现</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">            String[] urls = <span class="built_in">this</span>.determineUrlsForHandler(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">                  <span class="comment">// 保存urls和beanName的对应关系,put it to Map&lt;urls,beanName&gt;,该方法在父类AbstractUrlHandlerMapping中实现</span></span><br><span class="line">                <span class="built_in">this</span>.registerHandler(urls, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled() &amp;&amp; !<span class="built_in">this</span>.getHandlerMap().isEmpty() || <span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.getHandlerMap().size() + <span class="string">&quot; mappings in &quot;</span> + <span class="built_in">this</span>.formatMappingName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           </span><br><span class="line">    <span class="comment">/** 获取controller中所有方法的url,由子类实现,典型的模板模式 **/</span></span><br><span class="line">　　<span class="keyword">protected</span> <span class="keyword">abstract</span> String[] determineUrlsForHandler(String var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后的determineUrlsForHandler是获取每个controller的url，不同子类不同的实现。此处分析BeanNameUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取所有的url</span></span><br><span class="line"><span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">    <span class="comment">//用来保存url的容器</span></span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//判断beanName哪些是以&quot;/&quot;开头</span></span><br><span class="line">    <span class="keyword">if</span> (beanName.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        urls.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliases = <span class="built_in">this</span>.obtainApplicationContext().getAliases(beanName);</span><br><span class="line">    String[] var4 = aliases;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> aliases.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">        <span class="keyword">if</span> (alias.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            urls.add(alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br></pre></td></tr></table></figure><p>AbstractUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPaths, <span class="string">&quot;URL path array must not be null&quot;</span>);</span><br><span class="line">    String[] var3 = urlPaths;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> urlPaths.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">        <span class="built_in">this</span>.registerHandler((String)urlPath, (Object)beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    Assert.notNull(urlPath, <span class="string">&quot;URL path must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(handler, <span class="string">&quot;Handler object must not be null&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolvedHandler</span> <span class="operator">=</span> handler;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">//将handler转为beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String)handler;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">            <span class="comment">//根据beanName获取bean，一对一对应到controller类</span></span><br><span class="line">            resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot map &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler) + <span class="string">&quot; to URL path [&quot;</span> + urlPath + <span class="string">&quot;]: There is already &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(mappedHandler) + <span class="string">&quot; mapped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Root mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setRootHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Default mapping to &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.setDefaultHandler(resolvedHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//最终将结果put到map集合中，建立一一对应的关系</span></span><br><span class="line">        <span class="built_in">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Mapped [&quot;</span> + urlPath + <span class="string">&quot;] onto &quot;</span> + <span class="built_in">this</span>.getHandlerDescription(handler));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据url找到controller里处理请求方法"><a href="#根据url找到controller里处理请求方法" class="headerlink" title="根据url找到controller里处理请求方法"></a>根据url找到controller里处理请求方法</h3><p>因为找请求方法，所以看dispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//异步处理</span></span><br><span class="line">        <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//定义空的ModelAndView变量</span></span><br><span class="line">                <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//检查是否是文件上传的请求</span></span><br><span class="line">                    processedRequest = <span class="built_in">this</span>.checkMultipart(request);</span><br><span class="line">                    multipartRequestParsed = processedRequest != request;</span><br><span class="line">                    <span class="comment">//取得处理当前请求的controller（handler处理器），返回HandlerExecutionChain对象</span></span><br><span class="line">                    mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">                    <span class="comment">//handler不能为空</span></span><br><span class="line">                    <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//不同的controller类型交给不同的适配器</span></span><br><span class="line">                    <span class="comment">//若是bean，mappedHandler.getHandler()返回的对象</span></span><br><span class="line">                    <span class="comment">//若是method，返回的就是一个方法</span></span><br><span class="line">                    <span class="comment">//获取的就是handlerAdapter，方便后续找到对应的controller</span></span><br><span class="line">                    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">                    <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                        <span class="comment">//处理last-modified请求头</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">  <span class="comment">//拦截器预处理</span></span><br><span class="line">                    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">       <span class="comment">//通过适配器，处理请求</span></span><br><span class="line">  <span class="comment">//实际的处理器处理请求，返回结果视图对象</span></span><br><span class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">   <span class="comment">//结果视图对象处理</span></span><br><span class="line">                    <span class="built_in">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                    <span class="comment">//拦截器后置处理</span></span><br><span class="line">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">                    <span class="comment">//后面就是各种报错的判断反馈处理</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                    dispatchException = var20;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                    dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, var21);</span><br><span class="line">                <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, var23));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                <span class="built_in">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="与Struts2的区别"><a href="#与Struts2的区别" class="headerlink" title="与Struts2的区别"></a>与Struts2的区别</h2><table><thead><tr><th align="center">Struts2</th><th align="center">SpringMVC</th></tr></thead><tbody><tr><td align="center">filter为入口</td><td align="center">前端控制为入口</td></tr><tr><td align="center">基于类开发，传递参数通过类的属性，只能设置多例</td><td align="center">基于方法开发（一个url一个方法），请求参数传递到方法形参，可单例可多例</td></tr><tr><td align="center">值栈存储请求和响应的数据，OGNL存取数据</td><td align="center">通过参数解析器将request请求内容解析，给方法形参赋值，将数据视图封装成ModelAndView</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础</title>
      <link href="/2022/05/08/spring-1/"/>
      <url>/2022/05/08/spring-1/</url>
      
        <content type="html"><![CDATA[<h1 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h1><p><img src="/2022/05/08/spring-1/spring-model.png" alt="主要模块"></p><p>主要被分成：数据访问&#x2F;继承、web、AOP（面向切面编程）、工具、消息、测试</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>创建方式：构造器创建Bean<bean>标签、Setter方法、静态工厂方法创建bean、实例工厂方法创建bean</bean></p><p>获取bean：在初始化的时候保存ApplicationContext对象、通过Spring提供的工具类获取ApplicationContext对象、实现ApplicationContextAware接口、继承自抽象类ApplicationObjectSupport</p><p>配置Bean方式：基于XML配置、基于注解的配置、基于java的配置</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>默认下，spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例；所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为singleton，是所有bean的默认作用域</p><table><thead><tr><th align="center">类别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">在SpringIoc容器中仅存在一个bean实例,bean以单实例方式存在</td></tr><tr><td align="center">prototype</td><td align="center">每次调用getbean() 都将返回一个新的实例</td></tr><tr><td align="center">request</td><td align="center">每次Http请求都会创建一个新的bean,该作用域仅适合于WebApplicationContext 环境</td></tr><tr><td align="center">session</td><td align="center">同一个Http Session 共享一个bean,不同的Http Session使用不同的bean.该作用域仅适合 WebApplicationContext 环境</td></tr></tbody></table><p>singleton 默认值 当Ioc容器一创建就会创建bean实例,而且是单例的,每次得到的都是同一个<br>prototype 原型的 当Ioc容器一创建不实例化该bean,每次调用getBean() 方法时再实例化该bean,而且每次调用都是不同的bean实例<br>request 每次请求实例化一个bean<br>session 在一次会话中共享一个bean</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="创建前准备"><a href="#创建前准备" class="headerlink" title="创建前准备"></a>创建前准备</h3><p>​bean在开始加载之前，从上下文和配置中解析并查找bean有关的一些扩展实现。比如：init-method：容器在初始化时调用的；destroy-method：容器在销毁bean的时候会调用；BeanFactoryPostProcessor：加载过程中的前置、后置的一些处理拓展实现。</p><p>​这些类或配置时提供给开发者去实现bean加载过程中的拓展，在很多与spring集成的中间件常见。比如：Dubbo</p><h3 id="创建实例化"><a href="#创建实例化" class="headerlink" title="创建实例化"></a>创建实例化</h3><p>​通过反射去创建bean的实例对象，并且扫描和解析bean声明的一些属性</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>​若被实例化的bean存在依赖其他bean对象的一些情况，则需要对这些依赖的bean进行对象注入。比如：@Autowired、@Setter这样的配置形式。</p><p>​还会触发一些拓展的调用。比如：BeanPostProcessors：去实现bean初始化前后的拓展回调；</p><h3 id="容器缓存"><a href="#容器缓存" class="headerlink" title="容器缓存"></a>容器缓存</h3><p>​把bean缓存到容器里面以及spring的缓存中；这个阶段的bean就能被开发者拿去用。</p><h3 id="销毁实例"><a href="#销毁实例" class="headerlink" title="销毁实例"></a>销毁实例</h3><p>​当spring的应用上下文被关闭的时候，上下文中所有的bean会被销毁。若bean实现了诸如DisposableBean接口或者配置了destory-method属性的一些方法会在该阶段调用</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p> 一种设计思想，控制反转，<em><strong>将设计好的对象交给容器控制</strong></em>。在调用某个类时，容器会实例化，即容器控制对象的创建。</p><p>  IOC容器实例化过程中，一般不包含bean的依赖注入，bean的注册和依赖注入是两个过程，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xml中配置，在容器初始化的时候，这个bean就完成了初始化。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程基于IOC。简单说就是将部分重复的代码抽取出来，需要执行的时候用动态代理价技术。不修改代码进行功能增强。</p><p> 降低了耦合度，提高了程序的可重用性，同时提高了开发效率，实现业务和切入类的解耦</p><p>底层使用动态代理</p><p>与OOP相比，一个是横向一个纵向在</p><h1 id="涉及到的设计模式"><a href="#涉及到的设计模式" class="headerlink" title="涉及到的设计模式"></a>涉及到的设计模式</h1><p>IOC：工厂模式，单例模式，装饰器模式</p><p>AOP：代理模式，观察者模式（监听）</p><p>MVC:委派模式，适配者模式</p><p>JDBC：模板方法模式（RestTemplate）</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>有了IOC容器，对象间的依赖关系交给了spring，更专注业务逻辑代码</p><p>有AOP和OOP，很多功能更方便简单使用</p><p>简化开发</p><p>方便测试</p><p>声明式事务管理</p><p>减低API开发难度</p><p>低耦合</p><p>方便集成其他框架</p><h1 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h1><p>spring里面的核心功能是IOC容器，本质就是bean的容器、工厂，能去根据XML中声明的bean的配置去进行加载和初始化，然后beanFactory去生成我们所需要的各种各样的一个bean。</p><p>BeanFacory：是所有Spring Bean容器的顶级接口，为Spring的容器定义了一套规范，并提供像getBean等方法从容器中获取指定的Bean的实例；在产生bean的同时，提供解决bean之间依赖注入的能力；</p><p>FactoryBean：是一个工厂bean，接口，主要功能是去动态生成某一类型的bean的一个实例，即可以自定义一个bean并加载到IOC容器里，里面有个方法getObject就是实现动态构建bean的一个过程。OpenFeign组件客户端代理就是使用了FactoryBean实现</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2022/05/07/ThreadLocal-1/"/>
      <url>/2022/05/07/ThreadLocal-1/</url>
      
        <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/2022/05/07/ThreadLocal-1/first.png" alt="结构"></p><p>线程本地存储机制，数据缓存到线程内部</p><p>当thread销毁时，threadLocal也会随之销毁，减少内存的使用</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>Synchronized用于线程间的数据共享，ThreadLocal用于<em><strong>数据隔离</strong></em>，最适合多实例的对象的访问。</p><p>保存该线程变量，这样每个线程都有自己的数据，就做到了不同线程间数据的隔离。即多线程环境下，对于共享变量访问的安全性。</p><p>为每个使用该变量的线程提供独立的变量副本，所以<em><strong>每个线程都可独立改变自己副本</strong></em>，而不影响其他线程对应的副本，从而没必要对该变量进行同步了。</p><p>  提供了线程安全的共享对象，在多线程中，可把不安全的变量封装进ThreadLocal</p><p>创建一个TheadLocal变量，那么访问这个变量的每个线程都会有这个线程的本地副本。</p><p><em><strong>解决了线程安全问题，避免了多线程竞争锁的开销</strong></em></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>连接ThreadLocalMap和Thread，来处理Thread的ThreadLocalMap属性</p><p>  ThreadLocalMap用来存储数据，类似于hashmap，存储ThreadLocal为key，需要隔 离的数据为value的Entry键值对数据结构。可以理解：ThreadLocal只是ThreadLocalMap封装，传递了变量值。ThreadLocalMap&lt;ThreadLocal,数据&gt;</p><p>  ThreadLocalMap是ThreadLocal内部类，由ThreadLocal创建，ThreadLocal本身就是一个代理工具</p><p>  每个thread对象都会存一个theadLocalMap</p><p>  这样不容易产生内存泄露</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//   获取当前线程对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//再获取该线程下的threadlocalmap对象map</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)<span class="comment">//  Map若存在，则将参数设置到Map中</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);<span class="comment">// 否则就创建map（createMap(Thread t,T value)）并设置初始值</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//首先获取线程</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//根据线程获取map；</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">// 若map不为空，则在map下以threadlocal的引用作为key来在map中获取对应的entry e；</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;<span class="comment">//若e不为mull，则返回e.value；</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();<span class="comment">//Map为空或e为空，则initialValue函数获取初始值value，用threadlocal的引用和value作为键和值创建一个新map</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());<span class="comment">//获取当前线程，根据线程获取一个map；</span></span><br><span class="line">         <span class="keyword">if</span> (m != <span class="literal">null</span>)<span class="comment">//若map部位空则移除当前threadlocal对象对应的entry</span></span><br><span class="line">             m.remove(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="InitialValue"><a href="#InitialValue" class="headerlink" title="InitialValue"></a>InitialValue</h2><p>默认就返回null。延迟方法可重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">      SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">          <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> supplier.get();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>ThreadLocal没有被外部强引用的情况下，垃圾回收时key就会被清理，value不会，因为前者为弱引用，后者为强引用。</p><p>在线程池中使用ThreadLocal可能内存泄露：在线程池中线程的存活时间太长，往往都是和程序同生共死，这样thread持有的ThreadLocalMap一直不会被回收，又因为是弱引用，所以ThreadLocal结束生命就可以被回收。而Entry中的value被Entry强引用，所以机制value生命周期结束，也不会被回收，导致内存泄露</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>每一个线程分配一个和JDBC连接Connection，保证每个线程的都在各自的Coonection上进行数据库的操作</p><p><em><strong>变量在线程内部共享，线程间无关</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TheadLocal </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础</title>
      <link href="/2022/05/06/redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/06/redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="redis的基本性质"><a href="#redis的基本性质" class="headerlink" title="redis的基本性质"></a>redis的基本性质</h1><p>redis是<em><strong>完全基于内存</strong></em>，绝大部分请求是都是纯粹的内存操作</p><p>基于Reactor模式开发的网络处理器单多线程</p><p>6.0以前是单线程，利用队列技术将并发访问变为了串行访问，消除了传统数据库串行控制的开销</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>支持数据持久化，可以将内存的数据保存在磁盘中，重启的时候可以再次舒勇</p><p>提供各种数据结构进行存储</p><p>支持数据的备份</p><p>高性能、高并发，所以可以作为缓存</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>五种基础：</p><p>String：最基本的，动态字符串，存数字时底层是int；长字符串（长度&gt;39字节）raw；短字符串（长度&lt;39字节）embstr</p><p>利用key的生命周期做投票系统；String特点数据刷新；利用数值操作特征为分布式数据库自增。访问次数、点赞、转发量</p><hr><p>Hash：是一个键值对集合，是一个String类型的key和value的映射表。相当于hashmap。存放对象类型的数据，可避免键名冲突。 用户的购物车；hash作为商品秒杀技术对象完成商品秒杀系统</p><p>底层：ziplist（元素数量&lt;512，所有元素长度&lt;64字节）和哈希表。</p><hr><p>List：简单的字符串列表，底层是顺序的双向链表和ziplist（元素数量&lt;512，所有对象元素长度小于64字节）。可用于消息队列；顺序特性实现朋友圈点赞；顺序特性进行分布式日志顺序性展示</p><hr><p>Set:String类型的无序集合，底层哈希表和inset（所有元素是整数，元素数量小于512）</p><p>比如标签；黑白名单；获取所有业务的权限</p><hr><p>Zset（SortedSet）：ziplist（元素数量小于128，所有元素长度&lt;64）和跳表结合，value保证唯一性，又可为每个value代表权重的值。排行榜系统；带权重任务队列；根据权重进行排序</p><p>三种高级：</p><p>Bitmaps:String类型上的一组面向bit操作的集合，不是真的数据结构，优点就是存储信息可节省大量空间。一般用于实时分析，存储对象ID关联的节省空间且高性能的布尔信息。底层是String</p><hr><p>HyperLogLogs：用于计算唯一事物的概率数据结构。可用于计算用户每天在搜索框中执行唯一的搜索。底层是String</p><hr><p>GEO：存储用户给定的地理位置信息，并对这些信息操作。底层是zset</p><hr><p>Streams：内存版的kafka</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>速度快，支持丰富数据类型，支持事务、<em><strong>指令操作</strong></em>都是原子性的</p><p>容量收到物理内存限制，只适合较小数据量的高性能操作和运算上；</p><p>难在线扩容，在集群容量达到上限时在线扩容很复杂，所以运维人员在保证足够的空间</p><h1 id="redis6-0以后为什么引入多线程？"><a href="#redis6-0以后为什么引入多线程？" class="headerlink" title="redis6.0以后为什么引入多线程？"></a>redis6.0以后为什么引入多线程？</h1><p>多线程的情况下，线程切换换消耗CPU，<em><strong>CPU并不是redis的瓶颈</strong></em>。</p><p>引入多线程<em><strong>主要是为了提高网络IO读写性能</strong></em>：多线程只是在网络数据的读写这类耗时操作上使用，而执行命令仍是单线程顺序执行</p><p>redis将所有数据放在了内存中，对于小数据包，redis服务器已经处理80000到100000QPS，已经是极限，对大部分公司已经够用了</p><p>从redis自身角度，因为读写网络read&#x2F;write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p><ul><li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</li><li>使用多线程充分利用多核，典型的实现比如 Memcached</li></ul><p>小总结：</p><p>​可以充分利用服务器CPU资源，目前主线程只有一个核</p><p>​多线程可以分摊redis同步IO读写消耗</p><h1 id="redis6-0关于多线程"><a href="#redis6-0关于多线程" class="headerlink" title="redis6.0关于多线程"></a>redis6.0关于多线程</h1><p><em><strong>多线程默认是禁用的，只使用主线程</strong></em>。所以需要修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>仅仅是开启多线程是不生效，修改配置文件redis.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核使用2/3个线程，8核使设置6个线程</span></span><br></pre></td></tr></table></figure><p>实现机制：</p><p>​主线程负责接收建立连接请求，获取socket放入全局等待处理读处理队列</p><p>​主线程处理完读时间后，通过RR（Round Robin）将这些连接分配给这些IO线程</p><p>​主线程阻塞等待IO线程读取socket完毕</p><p>​主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但不执行</p><p>​主线程阻塞等待IO线程将数据收回，写socket完毕</p><p>​解除绑定，清空等待队列</p><h1 id="开启多线程后，是否有线程并发安全问题"><a href="#开启多线程后，是否有线程并发安全问题" class="headerlink" title="开启多线程后，是否有线程并发安全问题"></a>开启多线程后，是否有线程并发安全问题</h1><p>Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p><h1 id="redis经常提到IO多路复用，怎么理解？"><a href="#redis经常提到IO多路复用，怎么理解？" class="headerlink" title="redis经常提到IO多路复用，怎么理解？"></a>redis经常提到IO多路复用，怎么理解？</h1><p>这是IO模型的一种，即经典的Reactor设计模式，有时也称为异步阻塞IO。</p><p>多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>[Redis 6.0 新特性-多线程连环13问！](<a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis 6.0 新特性-多线程连环13问！ (qq.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis内存淘汰</title>
      <link href="/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
      <url>/2022/05/05/redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内存淘汰： 当内存的使用率到达了maxMemory的上限的时候，进行内存的释放。</p><p>redis提供了许多内存淘汰算法，主要分为4种：</p><p>​随机：随机移除某个key</p><p>​TTL算法：，在设置了过期时间的键里面去找更早过期时间的key进行有限的移除</p><p>​LRU算法：去移除最近很少使用的key。</p><p>​LFU算法：与LRU算法类似                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h1 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h1><p>​LRU算法会维护一个大小为16的侯选池，里面的数据会随着时间排序，每一次随机抽取5个key放入侯选池，当侯选池满了后，访问的时间间隔最大的key就从侯选池里面取出来并淘汰。这样就可以把真实的最少访问的key从内存里面淘汰。</p><p>​存在问题：若一个key很长时间没有访问，突然偶尔被访问，那LRU就会认为这是一个热点key就不会被淘汰。</p><h1 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h1><p>​相比于LRU算法，LFU增加了访问频率来统计数据的热点情况。</p><p>​主要设置是使用了两个双向链表形成了一个二维的双向链表，一个链表来保存访问频率，另一个保存访问频率相同的所有元素。当添加元素的时候，访问频次默认为1，找到相同频次的节点，然后添加到相同的频率节点对应的双向链表的头部，当元素被访问的时候，就增加对应key的访问频率，并把当前访问的节点移动到下一个频次的节点。</p><p>​可能出现某个数据前期的访问次数很多，但后续不再使用。若单纯按照这样的一个访问频次来进行淘汰的话，那这个key就很难被淘汰掉。该算法通过使用频率和上次访问的时间来标记数据的热度。若某个数据有读和写，那增加访问的频率；若一段时间内该数据没有读写，那就减少访问频率。</p><p>​经过LFU算法改进后就可以实现真正达到非热点数据的淘汰</p><p>​缺点：与LRU相比，增加了访问频次的维护以及实现的复杂度要比LRU更高</p><h1 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h1><p>定时策略：创建一个定时器，过期时间到，逻辑对键的删除</p><p>​对内存友好而CPU时间不好，redis还没有使用</p><p>惰性删除：过期键不管，每次从键空间获取键的时候，该键过期了删了，没过期就返回该键</p><p>​对内存不友好而CPU时间友好</p><p>定期删除：每隔一段时间就检查，删除过期键，由算法决定</p><p>​较为折中</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis和数据库的数据一致性</title>
      <link href="/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/05/04/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>redis用来实现应用和数据库之间读操作的缓存层，主要目的是去减少数据库的IO，并提升数据库的IO性能。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>当应用程序需要读取某个数据的时候，首先会尝试去redis里面加载，若命中就直接返回，反之就去数据库里面查询，查询到数据后再把数据缓存到redis里面。</p><h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>即一份数据同时保存在redis和数据库里面，当数据发生变化的时候需要同时更新数据库和redis，由于更新操作具有先后顺序且redis不像数据库中的多表事务操作（满足ACID的特性），所以会出现数据一致性的问题</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h2><p>此情况下，若缓存更新失败，就会导致数据库和redis的数据不一样。</p><p>线程1连接到数据库，读取到了数据A，此时线程1停顿，线程2连接到数据库将数据A更改为数据B，并将B写入了redis完成了线程2的操作，然后线程1将读取到的数据A写入redis即把B覆盖。此时，数据库里面的数据为B，而redis里的数据为A</p><h2 id="先删除缓存后更新数据库"><a href="#先删除缓存后更新数据库" class="headerlink" title="先删除缓存后更新数据库"></a>先删除缓存后更新数据库</h2><p>理想情况下是应用下次访问redis的时候，发现redis里面是空值，就会从数据库里加载并保存至数据库，理论上可行。但在极端情况下，由于删除redis和更新数据库的两个操作均不是原子操作，所以还是会出现数据不一致</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>基于RocketMQ的可靠性消息通信实现数据的最终一致性</p><p>通过Canal组件监控数据库里面的binlog的日志，把更新后的数据同步到redis里面</p><p>采用延时双删的原则：先淘汰缓存，再写数据库，休眠一会儿后再淘汰缓存。因为存在了延时时间，目的就是为了先把查到的数据写入redis再删redis</p><h1 id="redis的线程安全问题"><a href="#redis的线程安全问题" class="headerlink" title="redis的线程安全问题"></a>redis的线程安全问题</h1><h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h2><p>是一个线程安全的K-V数据库，即在redis-server端去执行指令的时候不要任何的同步机制，不存在任何线程安全的问题，虽然6.0之后增加了多线程的模型，但该模型只是去处理网络的IO事件，对于指令的执行还是采用主线程来处理的，所以并不会存在多个线程同时去执行操作指令的情况。</p><p>没有采用多线程执行指令：</p><p>​本身可能出现的性能瓶颈点无非是网络IO、CPU、内存，但是CPU不是redis的瓶颈，所以就没必要采用多线程执行指令</p><p>​若采用多线程，那么所有指令就必须要考虑线程安全的问题，也就需要加锁来解决，这种方式反而会对性能造成更大的影响</p><h2 id="redis-client"><a href="#redis-client" class="headerlink" title="redis-client"></a>redis-client</h2><p>里面的指令操作都是原子性，但若有多个redis客户端同时执行多个指令就无法保证原子性。</p><p>比如：两个client同时去获取server上的key1，同时去修改和写入，因为多线程下原子性不能保证以及多进程的情况下共享资源访问的竞争问题也不能保证数据安全性</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>尽可能使用redis里面的原子指令</p><p>对个客户端的资源访问加锁</p><p>通过lua脚本实现多个指令的操作，去满足原子性</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis理解和分布式锁</title>
      <link href="/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/03/redis%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="对redis的理解"><a href="#对redis的理解" class="headerlink" title="对redis的理解"></a>对redis的理解</h1><p>redis是一个高性能的基于Key-Value结构存储的NoSQL开源数据库，绝大部分都采用redis实现分布式缓存，从而去提高数据的的检索效率。</p><p>redis流行的原因：</p><p>​1 基于内存存储，在进行数据IO操作的时候能达到很高的QPS（官方给的10w）</p><p>​2 提供了非常丰富的数据存储结构，比如String、list、hash、set、zset</p><p>​3 底层采用单线程实现数据的IO，所以在数据算法层面不需要考虑并发安全性，从而让底层算法的时间复杂度基本都是常量复杂度</p><p>​4 虽然是内存存储，但却可以支持持久化，避免因服务器故障而导致的数据丢失问题</p><p>综上，redis一般是用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响，redis还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供了解决方案</p><h1 id="实现分布式锁中-zookeeper和redis的比较"><a href="#实现分布式锁中-zookeeper和redis的比较" class="headerlink" title="实现分布式锁中 zookeeper和redis的比较"></a>实现分布式锁中 zookeeper和redis的比较</h1><p>分布式锁：核心目的是为了解决在同一个时刻有多个进程或线程来访问共享资源所带来的安全性问题。锁又分为共享锁（在同一个时刻允许多个线程或进程访问共享资源，适用于幂等性场景，从而避免重复加锁的性能开销）和排它锁（同一个时刻只允许一个线程或进程访问该共享资源，适用于非幂等性场景）</p><p>实现分布式锁的最常用中间件就是zookeeper和redis</p><p>redis实现分布式锁方式：</p><p>​1 基于redis本身提供的指令：SET key value NX PX millisecounds。设置key的时候，若key已经存在与服务器上了会返回一个0，表示无法设置，否则就返回1表示设置成功。程序就根据0和1判断状态，从而表示去获得锁</p><p>​2 基于redission客户端实现，redission提供了分布式锁的封装方法，只需要调用封装好的api，<em><strong>lock()</strong></em> 和 ***unlock()***方法，就可以实现锁的抢占和释放。redission的所有指令都是通过lua脚本去实现，该脚本可以保证所有执行指令的原则性。另外，redission提供了一个watchdog，它会在我们获取锁后每隔10s去把key的时间延长，就避免锁的过期。</p><p>redis的缺点：</p><p>​在获得锁的时候，很简单，若获取不到锁就一直去尝试获取，会影响程序性能</p><p>​是一个&#x3D;&#x3D;AP模型&#x3D;&#x3D;，也就是可用性模型，集群模式中，存在数据一致性，会导致锁出现问题。即使使用了redlock算法实现分布式锁，但在某些复杂的场景下也不能保证锁的一定可用</p><p>zookeeper实现分布式锁：</p><p>​1 有序节点实现：每个线程或进程都到zookeeper上的<em><strong>lock</strong></em>目录下去创建一个临时有序节点，去表示抢占锁，所有创建的节点都会按照先后顺序生成带有有序编号的节点，线程创建节点后获取<em><strong>lock</strong></em>节点下的所有子节点，判断当前线程创建的节点是否是所有子节点里序号最小的，若是就获取锁成功。反之就需要对当前线程的前一个节点建立事件监听，当被监听的节点释放后，则触发回调告诉当前线程从而再次去尝试抢占锁</p><p> 使用redis还是比较常见，因为实际开发中极端情况少，redis本身的性能又高，在高并发中比较合适。</p><p>zookeeper是一个分布的协调组件，是&#x3D;&#x3D;一个CP模型&#x3D;&#x3D;所以更适合实现分布式锁。当获取不到锁就添加监听器，不用一直获取，就减少了性能。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java不可变类</title>
      <link href="/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/"/>
      <url>/2022/05/02/java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p><strong>不可变类</strong>：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p><p><strong>可变类</strong>：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><h1 id="不可变类优点"><a href="#不可变类优点" class="headerlink" title="不可变类优点"></a>不可变类优点</h1><p>主要有两点，效率和安全</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>当一个对象是不可变的，那么需要拷贝这个对象的内容时，就不用复制它的本身而只是复制它的地址，复制地址（通常一个指针的大小）只需要很小的内存空间，具有非常高的效率。同时，对于引用该对象的其他变量也不会造成影响。而且保证了hashCode 的唯一性，因此可以放心地进行缓存而不必每次重新计算新的哈希码。而哈希码被频繁地使用, 比如在hashMap 等容器中。将hashCode 缓存可以提高以不变类实例为key的容器的性能。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>是指线程安全</p><p>在多线程情况下，一个可变对象的值很可能被其他进程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况同时省去了同步加锁等过程，因此不可变类是线程安全的。</p><p>当然，不可变类也有缺点：不可变类的&#x3D;&#x3D;每一次“改变”都会产生新的对象，因此在使用中不可避免的会产生很多垃圾&#x3D;&#x3D;</p><h1 id="不可变类的设计"><a href="#不可变类的设计" class="headerlink" title="不可变类的设计"></a>不可变类的设计</h1><p>类使用final修饰，保证类不被继承</p><p>所有成员变量都被private和final修饰</p><p>不提供成员变量的setter方法</p><p>通过构造器初始化所有成员，进行深拷贝</p><p>在getter方法中，不直接返回对象本身，而是克隆对象并返回对象的拷贝内容</p><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>String源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length); <span class="comment">// deep copy操作</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> <span class="type">char</span>[] toCharArray() &#123;</span><br><span class="line">     <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">        <span class="type">char</span> result[] = <span class="keyword">new</span> <span class="title class_">char</span>[value.length];</span><br><span class="line">        System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可观察到</p><p>​String类被final修饰，就不能被继承</p><p>​内部变量所有成员都设置为私有变量</p><p>​没有setter方法</p><p>​&#x3D;&#x3D;传入可变数组时，进行copy而不是直接将数组赋值给内部变量&#x3D;&#x3D;</p><p>​获取value时不是直接返回对象引用，而是返回对象的copy</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​String不能被修改，让JVM可实现字符串常量池，该常量池可在运行时节约内存空间，不同字符串指向相同自变量时都指向字符串常量池中的同一对象，&#x3D;&#x3D;即提升了性能，节约了资源&#x3D;&#x3D;，更因为不可变性保证了线程安全</p><h2 id="String是否真的不可变"><a href="#String是否真的不可变" class="headerlink" title="String是否真的不可变"></a>String是否真的不可变</h2><p>虽然String对象将value设置为final,并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">char</span>[] valueCharArr = (<span class="type">char</span>[]) valueField.get(str);</span><br><span class="line">            valueCharArr[<span class="number">0</span>] = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">            valueField.set(str, <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hashCode = &quot;</span> + str.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = ABCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = GBCD</span><br><span class="line">hashCode = 2001986</span><br><span class="line">str = 12</span><br><span class="line">hashCode = 2001986</span><br></pre></td></tr></table></figure><p>由打印结果可知，字符串str的值发生了改变，哈希值没有发生变化。即通过反射可以修改“不可变”对象</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不可变类是实例创建后就不可以改变成员遍历的值。这种特性使得不可变类提供了线程安全的特性但同时也带来了对象创建的开销，每更改一个属性都是重新创建一个新的对象。JDK内部也提供了很多不可变类如Integer、Double、String等。</p><p>String的不可变特性主要为了满足<em><strong>常量池的使用</strong></em>、<em><strong>线程安全</strong></em>、<em><strong>类加载</strong></em>、<em><strong>提高运行速度</strong></em>、<em><strong>避免网络问题</strong></em>。合理使用不可变类可以带来极大的好处。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不可变类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
